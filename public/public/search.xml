<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>6.16逻辑</title>
    <url>/2020/06/16/6-16%E9%80%BB%E8%BE%91/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍6.16逻辑</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="关联字段逻辑"><a href="#关联字段逻辑" class="headerlink" title="关联字段逻辑"></a>关联字段逻辑</h2><h3 id="1-Controller"><a href="#1-Controller" class="headerlink" title="1 Controller"></a>1 Controller</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"warn/ChnlWarnEventContact"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChnlWarnEventContactController</span> <span class="keyword">extends</span> <span class="title">BaseController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WarnEventMapper warnEventMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ChannelExtendMapper channelExtendMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ChnlWarnEventContactMapper chnlWarnEventContactMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">""</span>)</span><br><span class="line">    <span class="meta">@RequiresPermissions</span>(<span class="string">"warn:ChnlWarnEventContact:list"</span>)</span><br><span class="line">    <span class="meta">@Log</span>(<span class="string">"跳转至预警事件渠道关联管理主界面"</span>)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @Author zhangxl</span></span><br><span class="line"><span class="comment">     * @Description //TODO</span></span><br><span class="line"><span class="comment">     * @Date 13:43 2020/6/16</span></span><br><span class="line"><span class="comment">     * @Param [correlationID, model]</span></span><br><span class="line"><span class="comment">     * @return java.lang.String</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function">String <span class="title">main</span><span class="params">(String correlationID, Model model)</span> </span>&#123;</span><br><span class="line">        WarnEventQueryReq warnEventQueryReq = <span class="keyword">new</span> WarnEventQueryReq();</span><br><span class="line">        List&lt;WarnEvent&gt; warnEventReqList = warnEventMapper.findByComplexCondition(correlationID, warnEventQueryReq, <span class="number">1</span>, <span class="number">1000</span>).getModel();</span><br><span class="line">        model.addAttribute(<span class="string">"warnEventReqList"</span>, warnEventReqList);</span><br><span class="line">        ChannelExtendComplexReq complexReq = <span class="keyword">new</span> ChannelExtendComplexReq();</span><br><span class="line">        List&lt;ChannelExtend&gt; chnlList = channelExtendMapper.findByComplexCondition(correlationID, complexReq, <span class="number">1</span>, <span class="number">10000</span>).getModel();</span><br><span class="line">        model.addAttribute(<span class="string">"chnList"</span>, chnlList);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"warn/ChnlWarnEventContact/main"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @Author zhangxl</span></span><br><span class="line"><span class="comment">     * @Description //TODO</span></span><br><span class="line"><span class="comment">     * @Date 14:08 2020/6/16</span></span><br><span class="line"><span class="comment">     * @Param [correlationID, model]</span></span><br><span class="line"><span class="comment">     * @return java.lang.String</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"add"</span>)</span><br><span class="line">    <span class="meta">@RequiresPermissions</span>(<span class="string">"warn:ChnlWarnEventContact:add"</span>)</span><br><span class="line">    <span class="meta">@Log</span>(<span class="string">"跳转至预警事件渠道关联添加页面"</span>)</span><br><span class="line">    <span class="function">String <span class="title">add</span><span class="params">(String correlationID, Model model)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"warn/ChnlWarnEventContact/edit"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @Author zhangxl</span></span><br><span class="line"><span class="comment">     * @Description //TODO</span></span><br><span class="line"><span class="comment">     * @Date 14:07 2020/6/16</span></span><br><span class="line"><span class="comment">     * @Param [correlationID, req]</span></span><br><span class="line"><span class="comment">     * @return com.atom.common.dto.Page&lt;com.lianxin.dialog.domain.ChnlWarnEvent&gt;</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"list"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@Log</span>(<span class="string">"查询"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Page&lt;ChnlWarnEvent&gt; <span class="title">list</span><span class="params">(String correlationID, ChnlWarnEventContactMngQueryReq req)</span> </span>&#123;</span><br><span class="line">        ChnlWarnEventQueryReq complexReq = <span class="keyword">new</span> ChnlWarnEventQueryReq();</span><br><span class="line">        Reflect.on(req).copy(complexReq);</span><br><span class="line">        ModelListResult listResult = chnlWarnEventContactMapper.findByComplexCondition(correlationID, complexReq, req.getPage(), req.getPageSize());</span><br><span class="line">        <span class="keyword">return</span> listResult.toPage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @Author zhangxl</span></span><br><span class="line"><span class="comment">     * @Description //TODO</span></span><br><span class="line"><span class="comment">     * @Date 14:08 2020/6/16</span></span><br><span class="line"><span class="comment">     * @Param [correlationID, info]</span></span><br><span class="line"><span class="comment">     * @return void</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/save"</span>)</span><br><span class="line">    <span class="meta">@RequiresPermissions</span>(<span class="string">"warn:ChnlWarnEventContact:add"</span>)</span><br><span class="line">    <span class="meta">@Log</span>(<span class="string">"进入预警事件渠道关联保存接口"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(String correlationID, @RequestBody ChnlWarnEvent info)</span> </span>&#123;</span><br><span class="line">        ValidatorWapper.from(info, <span class="string">"pojo"</span>).isNotNull().pojo().validate();</span><br><span class="line">        chnlWarnEventContactMapper.save(correlationID, info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/delete"</span>)</span><br><span class="line">    <span class="meta">@RequiresPermissions</span>(<span class="string">"warn:ChnlWarnEventContact:delete"</span>)</span><br><span class="line">    <span class="meta">@Log</span>(<span class="string">"进入预警事件渠道管理删除接口"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String correlationID, @RequestParam(<span class="string">"chnlId"</span>)</span> String chnlId, @<span class="title">RequestParam</span><span class="params">(<span class="string">"eventId"</span>)</span> String eventId)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ValidatorWapper.from(chnlId, <span class="string">"chnlId"</span>).isNotNull();</span><br><span class="line">        ValidatorWapper.from(eventId, <span class="string">"eventId"</span>).isNotNull();</span><br><span class="line">        ChnlWarnEventMutiKey key = <span class="keyword">new</span> ChnlWarnEventMutiKey();</span><br><span class="line">        key.setChnlId(chnlId);</span><br><span class="line">        key.setEventId(eventId);</span><br><span class="line">        chnlWarnEventContactMapper.delete(correlationID, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-Mapper"><a href="#2-Mapper" class="headerlink" title="2 Mapper"></a>2 Mapper</h3><p>1 findByComplexCondition 条件复杂查询 //筛选查询</p>
<p>(correlationID,dto,page,pageSize)   dto，所查询的对象dto 包装成dto对象 </p>
<p>2 save (correlationID,domain)    domain 实体类</p>
<p>domain类型  get()</p>
<p>3 get 单查询 展示main page   get(correlationID,domain)    如果是关联查询 mutikey</p>
<p>4 delete 删除  delete(correlationID,domain)  如果是关联查询 domain为mutikey</p>
<h3 id="3-前端"><a href="#3-前端" class="headerlink" title="3 前端"></a>3 前端</h3><h3 id="4-js"><a href="#4-js" class="headerlink" title="4 js"></a>4 js</h3>]]></content>
      <categories>
        <category>job</category>
      </categories>
      <tags>
        <tag>job</tag>
      </tags>
  </entry>
  <entry>
    <title>9.2面试总结</title>
    <url>/2020/09/02/9-2%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><p><strong>自我评价 ，对面试公司的热爱及了解、过往重点工作经历（匹配求职意向的内容）、简单的未来规划。</strong></p>
<p>1 linux命令</p>
<p>windows查看进程</p>
<p>netstat -ano </p>
<p>查看进程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps aux</span><br></pre></td></tr></table></figure>

<p> <strong>1. free</strong></p>
<p><strong>free命令用于显示内存状态</strong>。</p>
<p>free指令会显示内存的使用情况，包括实体内存，虚拟的交换文件内存，共享内存区段，以及系统核心使用的缓冲区等。</p>
<p>语法： free [-bkmotV][-s &lt;间隔秒数&gt;]</p>
<p>参数：</p>
<p><img src="https://img-blog.csdnimg.cn/20190129095712520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEzMTQ0NDI=,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>2. df</strong></p>
<p>df：<strong>列出文件系统的整体磁盘使用量</strong>。检查文件系统的磁盘空间占用情况。可用来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。</p>
<p>语法： df [-ahikHTm] [目录或文件名]</p>
<p>参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-a ：列出所有的文件系统，包括系统特有的 &#x2F;proc 等文件系统；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-k ：以 KBytes 的容量显示各文件系统；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-m ：以 MBytes 的容量显示各文件系统；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-H ：以 M&#x3D;1000K 取代 M&#x3D;1024K 的进位方式；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-i ：不用硬盘容量，而以 inode 的数量来显示</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190129100736892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEzMTQ0NDI=,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>3. du</strong></p>
<p> <strong>du 对文件和目录磁盘使用的空间的查看。</strong></p>
<p>语法：  du [-ahskm] 文件或目录名称 </p>
<p>参数：</p>
<p>检查根目录底下每个目录所占用的容量： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">du -sm &#x2F;*</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/2019012910322127.png" alt="img"><br>查看当前目录下每个文件夹的大小：</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">du -sh *</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190129103141765.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20190129101857201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEzMTQ0NDI=,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>4. fdisk</strong></p>
<p>fdisk 是 Linux 的磁盘分区表操作工具。</p>
<p>语法： fdisk [-l] 装置名称</p>
<p>参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-l ：输出后面接的装置所有的分区内容。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     若仅有 fdisk -l 时， 则系统将会把整个系统内能够搜寻到的装置的分区均列出来。</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190129102529296.png" alt="img"></p>
<h3 id="5-cat-proc-cpuinfo"><a href="#5-cat-proc-cpuinfo" class="headerlink" title="5.cat /proc/cpuinfo"></a>5.cat /proc/cpuinfo</h3><p>linux查看cpu核数</p>
<h2 id="6-int到Integer"><a href="#6-int到Integer" class="headerlink" title="6.int到Integer:"></a>6.<strong>int到Integer:</strong></h2><ul>
<li>自动装箱</li>
<li>自动拆箱GE</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="comment">//自动装箱</span></span><br><span class="line"><span class="number">2</span> Integer total = <span class="number">99</span>;</span><br><span class="line"><span class="number">3</span> </span><br><span class="line"><span class="number">4</span> <span class="comment">//自动拆箱</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">int</span> totalprim = total;</span><br></pre></td></tr></table></figure>

<p>简单一点说，装箱就是自动将基本数据类型转换为包装器类型；拆箱就是自动将包装器类型转换为基本数据类型。</p>
<ul>
<li><p><strong>Integer valueOf(int i)：</strong>返回一个表示指定的 int 值的 Integer 实例。</p>
</li>
<li><p><strong>Integer valueOf(String s):</strong>返回保存指定的 String 的值的 Integer 对象。</p>
</li>
<li><p>valueOf() 方法用于返回给定参数的原生 Number 对象值，参数可以是原生数据类型, String等。</p>
<p>该方法是静态方法。该方法可以接收两个参数一个是字符串，一个是基数。</p>
</li>
</ul>
<p><strong>int到Integer:</strong></p>
<p>int a=3;</p>
<p>Integer A=new Integer(a);</p>
<p>或:</p>
<p>Integer A=Integer.valueOf(a);</p>
<p><strong>Integer到int:</strong></p>
<p>Integer A=new Integer(5);</p>
<p>int a=A.intValue();</p>
<h2 id="7-Dubbo的RPC框架"><a href="#7-Dubbo的RPC框架" class="headerlink" title="7. Dubbo的RPC框架"></a>7. Dubbo的RPC框架</h2><p><img src="https://photos.alitaalice.cn/image/20200903110205.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200903110200.png" alt=""></p>
<h2 id="周期检测心跳机制"><a href="#周期检测心跳机制" class="headerlink" title="周期检测心跳机制"></a>周期检测心跳机制</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">每隔一定的时间向节点集群发送检测请求，设定一个超时时间，如果超过超时时间，则判定节点死亡</span><br></pre></td></tr></table></figure>

<ol start="8">
<li><p>单例模式懒汉和饿汉</p>
<p>懒汉：在初始化类的时候，不创建唯一的实例，而是等到真正需要用到的时候才创建。必须加上同步，否则有可能依然创建多个实例。<br>饿汉：在初始化的时候，就创建了唯一的实例，不管是否需要用到。不需要自己加同步，一定产生唯一的实例。</p>
<p>懒汉代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 私有的、静态的成员保存唯一的实例</span><br><span class="line">    private static Singleton inst;</span><br><span class="line">    &#x2F;&#x2F; 私有构造器，避免被别人创建实例</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 提供一个公共的、静态的方法，获取唯一的实例</span><br><span class="line">    public static Singleton getInstance()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 很多示例代码都是在方法上加同步，但是基于“最小范围原则”，应该要用同步代码块</span><br><span class="line">        &#x2F;&#x2F; 这样可以尽可能提升程序的并发性能</span><br><span class="line">        synchronized( Singleton.class )</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; 判断inst是否为null，如果是null则新建一个</span><br><span class="line">            if( inst &#x3D;&#x3D; null )</span><br><span class="line">            &#123;</span><br><span class="line">                inst &#x3D; new Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return inst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




</li>
</ol>
<p>   饿汉代码</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 私有的、静态的成员保存唯一的实例</span><br><span class="line">    &#x2F;&#x2F; 在类被第一次使用的时候，就已经完成了加载。类的加载过程，系统保证线程安全。</span><br><span class="line">    private static Singleton inst &#x3D; new Singleton();</span><br><span class="line">    &#x2F;&#x2F; 私有构造器，避免被别人创建实例</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 提供一个公共的、静态的方法，获取唯一的实例</span><br><span class="line">    public static Singleton getInstance()</span><br><span class="line">    &#123;</span><br><span class="line">        return inst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>   从上面两个代码来看，由于懒汉模式下，每次获取实例都需要判断，如果使用非常频繁的时候，这种方式性能肯定有所下降。</p>
<p>   因此懒汉模式下，不适合使用太频繁的对象。</p>
<p>   饿汉式是线程安全的,在类创建的同时就已经创建好一个静态的对象供系统使用,以后不在改变</p>
<p>   而在饿汉模式下，不管是否用到，都会初始化实例。<br>   这种是我比较推荐的做法：因为不使用对象的类，就不需要单例模式！既然需要用到对象，为何不在一开始就初始化好？</p>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>9.12打卡</title>
    <url>/2020/09/12/9-12%E6%89%93%E5%8D%A1/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍9.12打卡</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>1 leetcode</p>
]]></content>
      <categories>
        <category>打卡</category>
      </categories>
      <tags>
        <tag>打卡</tag>
      </tags>
  </entry>
  <entry>
    <title>ACID</title>
    <url>/2020/09/09/ACID/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍mysql事务acid</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h1 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h1><p>事务具有4个特征，分别是原子性、一致性、隔离性和持久性，简称事务的ACID特性；</p>
<h1 id="一、原子性（atomicity"><a href="#一、原子性（atomicity" class="headerlink" title="一、原子性（atomicity)"></a>一、原子性（atomicity)</h1><p>一个事务要么全部提交成功，要么全部失败回滚，不能只执行其中的一部分操作，这就是事务的原子性</p>
<h1 id="二、一致性（consistency"><a href="#二、一致性（consistency" class="headerlink" title="二、一致性（consistency)"></a>二、一致性（consistency)</h1><p>事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行之前和执行之后，数据库都必须处于一致性状态。</p>
<p>如果数据库系统在运行过程中发生故障，有些事务尚未完成就被迫中断，这些未完成的事务对数据库所作的修改有一部分已写入物理数据库，这是数据库就处于一种不正确的状态，也就是不一致的状态</p>
<h1 id="三、隔离性（isolation）"><a href="#三、隔离性（isolation）" class="headerlink" title="三、隔离性（isolation）"></a>三、隔离性（isolation）</h1><p><strong>事务的隔离性是指在并发环境中，并发的事务时相互隔离的，一个事务的执行不能不被其他事务干扰。</strong>不同的事务并发操作相同的数据时，每个事务都有各自完成的数据空间，即一个事务内部的操作及使用的数据对其他并发事务时隔离的，并发执行的各个事务之间不能相互干扰。</p>
<p>在标准SQL规范中，定义了4个事务隔离级别，不同的隔离级别对事务的处理不同，分别是：未授权读取，授权读取，可重复读取和串行化</p>
<p>1、读未提交（Read Uncommited），该隔离级别允许脏读取，其隔离级别最低；比如事务A和事务B同时进行，事务A在整个执行阶段，会将某数据的值从1开始一直加到10，然后进行事务提交，此时，<strong>事务B能够看到这个数据项在事务A操作过程中的所有中间值</strong>（如1变成2，2变成3等），而对这一系列的中间值的读取就是未授权读取</p>
<p>2、授权读取也称为已提交读（Read Commited），<strong>授权读取只允许获取已经提交的数据</strong>。比如事务A和事务B同时进行，事务A进行+1操作，此时，事务B无法看到这个数据项在事务A操作过程中的所有中间值，只能看到最终的10。另外，如果说有一个事务C，和事务A进行非常类似的操作，只是事务C是将数据项从10加到20，此时事务B也同样可以读取到20，即授权读取允许不可重复读取。</p>
<p>3、可重复读（Repeatable Read)</p>
<p><strong>就是保证在事务处理过程中，多次读取同一个数据时，其值都和事务开始时刻是一致的</strong>，因此该事务级别禁止不可重复读取和脏读取，但是有可能出现幻影数据。所谓幻影数据，就是指同样的事务操作，在前后两个时间段内执行对同一个数据项的读取，可能出现不一致的结果。在上面的例子中，可重复读取隔离级别能够保证事务B在第一次事务操作过程中，始终对数据项读取到1，但是在下一次事务操作中，即使事务B（注意，事务名字虽然相同，但是指的是另一个事务操作）采用同样的查询方式，就可能读取到10或20；</p>
<p>4、串行化</p>
<p>是最严格的事务隔离级别，它要求所有事务被串行执行，即事务只能一个接一个的进行处理，不能并发执行。</p>
<h1 id="四、持久性（durability）"><a href="#四、持久性（durability）" class="headerlink" title="四、持久性（durability）"></a>四、持久性（durability）</h1><p>事务一旦提交，其更改是永久性的，即使数据库系统崩溃也能恢复</p>
<p>保证持久性的策略就是<strong>Write Ahead Logging</strong>。在事务提交之前，备份一份事务的操作日志在磁盘上，备份成功再允许事务成功提交。</p>
<h3 id="2-1-事务的隔离级别分为："><a href="#2-1-事务的隔离级别分为：" class="headerlink" title="2.1 事务的隔离级别分为："></a>2.1 事务的隔离级别分为：</h3><ul>
<li>Read uncommitted(读未提交)</li>
<li>Read Committed(读已提交)</li>
<li>Repeatable Reads(可重复读)</li>
<li>Serializable(串行化)</li>
</ul>
<h4 id="Read-uncommitted"><a href="#Read-uncommitted" class="headerlink" title="Read uncommitted"></a>Read uncommitted</h4><p><code>读未提交</code>：隔离级别最低的一种事务级别。在这种隔离级别下，会引发脏读、不可重复读和幻读。</p>
<h4 id="Read-Committed"><a href="#Read-Committed" class="headerlink" title="Read Committed"></a>Read Committed</h4><p><code>读已提交</code>读到的都是别人提交后的值。这种隔离级别下，会引发不可重复读和幻读，但避免了脏读。</p>
<h4 id="Repeatable-Reads"><a href="#Repeatable-Reads" class="headerlink" title="Repeatable Reads"></a>Repeatable Reads</h4><p><code>可重复读</code>这种隔离级别下，会引发幻读，但避免了脏读、不可重复读。</p>
<h4 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h4><p><code>串行化</code>是最严格的隔离级别。在Serializable隔离级别下，所有事务按照次序依次执行。脏读、不可重复读、幻读都不会出现。</p>
<p><img src="https://img2018.cnblogs.com/blog/1629488/201906/1629488-20190622123004301-566049444.png" alt="隔离级别"></p>
<h1 id="五、脏读，不可重复读，幻读"><a href="#五、脏读，不可重复读，幻读" class="headerlink" title="五、脏读，不可重复读，幻读"></a>五、脏读，不可重复读，幻读</h1><p><strong>1.</strong> <strong>脏读</strong> ：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。</p>
<p><strong>2.</strong> <strong>不可重复读</strong> ：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两 次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不 可重复读。例如，一个编辑人员两次读取同一文档，但在两次读取之间，作者重写了该文档。当编辑人员第二次读取文档时，文档已更改。原始读取不可重复。如果 只有在作者全部完成编写后编辑人员才可以读取文档，则可以避免该问题。</p>
<p><strong>3.</strong> <strong>幻读</strong> : 是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。 同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象 发生了幻觉一样。例如，一个编辑人员更改作者提交的文档，但当生产部门将其更改内容合并到该文档的主复本时，发现作者已将未编辑的新材料添加到该文档中。 如果在编辑人员和生产部门完成对原始文档的处理之前，任何人都不能将新材料添加到文档中，则可以避免该问题。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList和LinkedList</title>
    <url>/2020/05/07/ArrayList%E5%92%8CLinkedList/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>List集合包括List接口和List接口所有的实现类</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="List接口定义的方法"><a href="#List接口定义的方法" class="headerlink" title="List接口定义的方法"></a>List接口定义的方法</h2><p>除了继承Collection外，List接口还有俩个重要的方法。</p>
<table>
<thead>
<tr>
<th>get(int index)</th>
<th>获得指定索引位置的元素</th>
</tr>
</thead>
<tbody><tr>
<td>set(int index,Object obj)</td>
<td>将集合中指定索引位置的对象修改为指定的对象</td>
</tr>
</tbody></table>
<h2 id="List接口的实现类"><a href="#List接口的实现类" class="headerlink" title="List接口的实现类"></a>List接口的实现类</h2><ul>
<li><p>ArrayList</p>
<p>实现了可变的数组，允许保存所有元素包括null .并且可以根据索引的位置对集合进行快速的随机访问，缺点是向指向的索引位置插入对象或删除对象时的速度较慢</p>
</li>
<li><p>LinkedList </p>
<p>采用链表的结构保存对象。优点是便于向集合中插入和删除对象</p>
<p>分别用ArrayList 和LinkedList来实例化集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;E&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;E&gt; list=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>E是合法的JAVA数据类型，也可以是字符串String</p>
<h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><p>1.接口实现：都实现了List接口，都是线性列表的实现</p>
<p>2.线程安全：都是线程不安全的</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>1.底层实现:ArrayList内部是数组实现，而LinkedList内部实现是双向链表结构</p>
<p>2.接口实现：ArrayList实现了RandomAccess可以支持随机元素访问，而LinkedList实现了Deque可以当做队列使用</p>
<p>3.性能：新增、删除元素时ArrayList需要使用到拷贝原数组，而LinkedList只需移动指针，查找元素 ArrayList支持随机元素访问,而LinkedList只能一个节点的去遍历</p>
</li>
</ul>
<p>下转<a href="https://www.jianshu.com/p/732b5294a985">https://www.jianshu.com/p/732b5294a985</a></p>
]]></content>
      <categories>
        <category>JAVA集合</category>
      </categories>
      <tags>
        <tag>JAVA集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Arrays类相关</title>
    <url>/2020/05/29/Arrays%E7%B1%BB%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍Arrays类相关.</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>转<a href="https://blog.csdn.net/LIU_YANZHAO/article/details/70847050?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase">https://blog.csdn.net/LIU_YANZHAO/article/details/70847050?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase</a></p>
<h1 id="java-List和数组相互转换方法"><a href="#java-List和数组相互转换方法" class="headerlink" title="java List和数组相互转换方法"></a>java List和数组相互转换方法</h1><h3 id="1-List转数组"><a href="#1-List转数组" class="headerlink" title="1 List转数组"></a>1 List转数组</h3><h4 id="toArray-方法"><a href="#toArray-方法" class="headerlink" title="toArray()方法"></a>toArray()方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">      list.add(<span class="string">"1"</span>);</span><br><span class="line">      String[] strings = <span class="keyword">new</span> String[list.size()];</span><br><span class="line">      list.toArray(strings);</span><br><span class="line">      System.out.println(strings);</span><br><span class="line">      System.out.println(strings.getClass());</span><br><span class="line">      System.out.println(Arrays.toString(strings));</span><br></pre></td></tr></table></figure>

<h3 id="2-数组转List"><a href="#2-数组转List" class="headerlink" title="2 数组转List"></a>2 数组转List</h3><h4 id="使用asList（）"><a href="#使用asList（）" class="headerlink" title="使用asList（）"></a>使用asList（）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(arrays));</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JAVASE</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>Collection</title>
    <url>/2020/05/06/Collection/</url>
    <content><![CDATA[<h2 id="Java容器可分为两大类："><a href="#Java容器可分为两大类：" class="headerlink" title="Java容器可分为两大类："></a>Java容器可分为两大类：</h2><ul>
<li><p>Collection接口 继承JAVA.lang.Object</p>
<ul>
<li>List接口<ul>
<li><strong>ArrayList</strong></li>
<li>LinkedList<a id="more"></a></li>
<li>Vector(了解，已过时)</li>
</ul>
</li>
<li>Set接口<ul>
<li>HashSet<ul>
<li>LinkedHashSet</li>
</ul>
</li>
<li>TreeSet</li>
</ul>
</li>
</ul>
</li>
<li><p>Map接口  继承JAVA.lang.Object</p>
<ul>
<li><p><strong>HashMap</strong></p>
<ul>
<li>LinkedHashMap</li>
</ul>
</li>
<li><p>TreeMap</p>
</li>
<li><p>ConcurrentHashMap</p>
</li>
<li><p>Hashtable(了解，，已过时)</p>
</li>
</ul>
</li>
</ul>
<h2 id="Collection接口："><a href="#Collection接口：" class="headerlink" title="Collection接口："></a>Collection接口：</h2><ul>
<li><p>Collection接口的常用方法</p>
</li>
<li><p>添加功能</p>
<ul>
<li><table>
<thead>
<tr>
<th>boolean add(Object obj)</th>
<th>添加一个元素</th>
</tr>
</thead>
<tbody><tr>
<td>boolean  addAll(Collection c)</td>
<td>添加一个集合的元素</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">static</span> Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"add:"</span>+c.add(<span class="string">"hello"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* 输出为 add:true */</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p>​             </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Collection c1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">static</span> Collection c2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        c1.add(<span class="string">"xxxx"</span>);</span><br><span class="line">        System.out.println(<span class="string">"add:"</span> + c1.add(<span class="string">"hello"</span>));</span><br><span class="line">        System.out.println(<span class="string">"addAll:"</span> + c2.addAll(c1));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* 输出add:true</span></span><br><span class="line"><span class="comment">addAll:true */</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>删除功能</p>
<ul>
<li><table>
<thead>
<tr>
<th>void clear()</th>
<th>移除所有元素</th>
</tr>
</thead>
<tbody><tr>
<td>boolean remove(Object o)</td>
<td>移除一个元素</td>
</tr>
<tr>
<td>boolean removeAll(Object o)</td>
<td>移除一个集合的所有元素</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>判断功能</p>
<ul>
<li><table>
<thead>
<tr>
<th>boolean contains(Object o)</th>
<th>判断集合中是否包含指定的元素</th>
</tr>
</thead>
<tbody><tr>
<td>boolean containsAll(Object o)</td>
<td>判断集合中是否包含指定的集合元素（一个集合中的所有元素</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>判断集合是否为空</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>获取功能</strong></p>
<p>重点：迭代器（Iterator） 下一篇中我们详细解释。</p>
<p>itetator()   返回在此 Collection 的元素上进行迭代的迭代器。用于遍历集合中的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Muster</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"a"</span>);</span><br><span class="line">        list.add(<span class="string">"b"</span>);</span><br><span class="line">        list.add(<span class="string">"c"</span>);</span><br><span class="line">        Iterator&lt;String&gt; it=list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            String str=(String) it.next();</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>JAVA集合</category>
      </categories>
      <tags>
        <tag>JAVA集合</tag>
      </tags>
  </entry>
  <entry>
    <title>ConcurrentHashMap</title>
    <url>/2020/09/09/ConcurrentHashMap/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍ConcurrentHashMap</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>ConcurrentHashMap是线程安全且高效的HashMap。在介绍Concurrenthashmap之前，我们先来看一下HashMap。</p>
<p><strong>1.  HashMap概述</strong></p>
<p>​    HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键（除了不同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同）。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>
<p>　　值得注意的是HashMap不是线程安全的，如果想要线程安全的HashMap，可以通过Collections类的静态方法synchronizedMap获得线程安全的HashMap。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Map map &#x3D; Collections.synchronizedMap(new HashMap());</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title="** **"></a>** **</h2><h2 id="2、HashMap的数据结构"><a href="#2、HashMap的数据结构" class="headerlink" title="2、HashMap的数据结构"></a><strong>2、HashMap的数据结构</strong></h2><p>HashMap的底层主要是基于<strong><em>\</em>数组和链表**</strong>来实现的，它之所以有相当快的查询速度主要是因为它是通过计算散列码来决定存储的位置。HashMap中主要是通过key的hashCode来计算hash值的，只要hashCode相同，计算出来的hash值就一样。如果存储的对象对多了，就有可能不同的对象所算出来的hash值是相同的，这就出现了所谓的hash冲突。学过数据结构的同学都知道，解决hash冲突的方法有很多，HashMap底层是通过链表来解决hash冲突的。也就是说，其链表结果主要是用来解决hash冲突的。</p>
<p>hashmap结构：哈希表是由数组+链表组成的，数组的默认长度为16（<em>可以自动变长。在构造HashMap\</em>的时候也可以指定一个长度<strong>），数组里每个元素存储的是一个链表的头结点。而组成链表的结点其实就是hashmap内部定义的一个类：Entity。Entity<em>包含三个元素：key\</em>，value*和指向下一个Entity*的next。（<a href="https://www.cnblogs.com/xdxs/p/4982158.html）">https://www.cnblogs.com/xdxs/p/4982158.html）</a>**</strong></p>
<p>****<img src="https://img-blog.csdn.net/2018052116182936?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ltMTIzNDU2Njc3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<hr>
<hr>
<hr>
<p>以上的是1.7之前的，JDK1.8中：</p>
<p>使用一个Node数组来存储数据，但这个Node可能是链表结构，也可能是红黑树结构</p>
<p>如果插入的key的hashcode相同，那么这些key也会被定位到Node数组的同一个格子里。</p>
<p>如果同一个格子里的key不超过8个，使用链表结构存储。</p>
<p>如果超过了8个，那么会调用treeifyBin函数，将链表转换为红黑树。</p>
<p>那么即使hashcode完全相同，由于红黑树的特定，查找某个特定元素，也只需要O(log n)的开销</p>
<p>也就是说put/get的操作的时间复杂度只有O(log n)</p>
<p>备注：当数组大小已经超过64并且链表中的元素个数超过默认设定（8个）时，将链表转化为红黑树</p>
<hr>
<hr>
<p><strong><strong>下面我们来谈一下为什么要使用ConcurrentHashMap。</strong></strong></p>
<p><strong><strong>在并发编程中使用HashMap可能导致程序死循环。而使用线程安全的HashTable效率又非</strong></strong>常低下，基于以上两个原因，便有了ConcurrentHashMap的登场机会</p>
<p><strong><strong>1）线程不安全的HashMap</strong></strong></p>
<p>****在多线程环境下，使用HashMap进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap。HashMap在并发执行put操作时会引起死循环，是因为多线程会导致HashMap的Entry链表形成环形数据结构，一旦形成环形数据结构，Entry的next节点永远不为空，就会产生死循环获取Entry。</p>
<hr>
<p>****2）效率低下的HashTable</p>
<hr>
<p>****HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法，其他线程也访问HashTable的同步方法时，会进入阻塞或轮询状态。如线程1使用put进行元素添加，线程2不但不能使用put方法添加元素，也不能使用get方法来获取元素，所以竞争越激烈效率越低。</p>
<hr>
<p>****3）ConcurrentHashMap的锁分段技术可有效提升并发访问率</p>
<hr>
<p>****HashTable容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问HashTable的线程都必须竞争同一把锁，假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术。首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p>
<hr>
<hr>
<hr>
<p><strong><strong>下面我们来详细介绍一下ConcurrentHashMap的结构</strong></strong></p>
<p>jdk1.7中采用<code>Segment</code> + <code>HashEntry</code>的方式进行实现，结构如下：</p>
<p><img src="https://img-blog.csdn.net/20180522145823781?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ltMTIzNDU2Njc3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>****ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁（ReentrantLock），在ConcurrentHashMap里扮演锁的角色；HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组。Segment的结构和HashMap类似，是一种数组和链表结构。一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得与它对应的Segment锁，如下图所示。</p>
<hr>
<p>****<img src="https://img-blog.csdn.net/20180521171105146?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ltMTIzNDU2Njc3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<hr>
<hr>
<hr>
<p>****<code>ConcurrentHashMap</code>初始化时，计算出<code>Segment</code>数组的大小<code>ssize</code>和每个<code>Segment</code>中<code>HashEntry</code>数组的大小<code>cap</code>，并初始化<code>Segment</code>数组的第一个元素；其中<code>ssize</code>大小为2的幂次方，默认为16，<code>cap</code>大小也是2的幂次方，最小值为2，最终结果根据根据初始化容量<code>initialCapacity</code>进行计算，其中<code>Segment</code>在实现上继承了<code>ReentrantLock</code>，这样就自带了锁的功能。</p>
<hr>
<p>****当执行<code>put</code>方法插入数据时，根据key的hash值，在<code>Segment</code>数组中找到相应的位置，如果相应位置的<code>Segment</code>还未初始化，则通过CAS进行赋值，接着执行<code>Segment</code>对象的<code>put</code>方法通过加锁机制插入数据。</p>
<hr>
<p>****1、线程A执行<code>tryLock()</code>方法成功获取锁，则把<code>HashEntry</code>对象插入到相应的位置；<br>2、线程B获取锁失败，则执行<code>scanAndLockForPut()</code>方法，在<code>scanAndLockForPut</code>方法中，会通过重复执行<code>tryLock()</code>方法尝试获取锁，在多处理器环境下，重复次数为64，单处理器重复次数为1，当执行<code>tryLock()</code>方法的次数超过上限时，则执行<code>lock()</code>方法挂起线程B；</p>
<hr>
<p><strong><strong>3、当线程A执行完插入操作时，会通过<code>unlock()</code>方法释放锁，接着唤醒线程B继续执行；</strong></strong></p>
<hr>
<hr>
<h4 id="size实现"><a href="#size实现" class="headerlink" title="size实现"></a>size实现</h4><p>因为<code>ConcurrentHashMap</code>是可以并发插入数据的，所以在准确计算元素时存在一定的难度，一般的思路是统计每个<code>Segment</code>对象中的元素个数，然后进行累加，但是这种方式计算出来的结果并不一样的准确的，因为在计算后面几个<code>Segment</code>的元素个数时，已经计算过的<code>Segment</code>同时可能有数据的插入或则删除，在1.7的实现中，采用了如下方式：</p>
<p>先采用不加锁的方式，连续计算元素的个数，最多计算3次：<br>1、如果前后两次计算结果相同，则说明计算出来的元素个数是准确的；<br>2、如果前后两次计算结果都不同，则给每个<code>Segment</code>进行加锁，再计算一次元素的个数；</p>
<hr>
<hr>
<h3 id="1-8实现"><a href="#1-8实现" class="headerlink" title="1.8实现"></a>1.8实现</h3><h4 id="ConcurrentHashMap在1-8中的实现，相比于1-7的版本基本上全部都变掉了。首先，取消了Segment分段锁的数据结构，取而代之的是数组-链表（红黑树）的结构。而对于锁的粒度，调整为对每个数组元素加锁（Node）。然后是定位节点的hash算法被简化了，这样带来的弊端是Hash冲突会加剧。因此在链表节点数量大于8时，会将链表转化为红黑树进行存储。这样一来，查询的时间复杂度就会由原先的O-n-变为O-logN-。下面是其基本结构："><a href="#ConcurrentHashMap在1-8中的实现，相比于1-7的版本基本上全部都变掉了。首先，取消了Segment分段锁的数据结构，取而代之的是数组-链表（红黑树）的结构。而对于锁的粒度，调整为对每个数组元素加锁（Node）。然后是定位节点的hash算法被简化了，这样带来的弊端是Hash冲突会加剧。因此在链表节点数量大于8时，会将链表转化为红黑树进行存储。这样一来，查询的时间复杂度就会由原先的O-n-变为O-logN-。下面是其基本结构：" class="headerlink" title="ConcurrentHashMap在1.8中的实现，相比于1.7的版本基本上全部都变掉了。首先，取消了Segment分段锁的数据结构，取而代之的是数组+链表（红黑树）的结构。而对于锁的粒度，调整为对每个数组元素加锁（Node）。然后是定位节点的hash算法被简化了，这样带来的弊端是Hash冲突会加剧。因此在链表节点数量大于8时，会将链表转化为红黑树进行存储。这样一来，查询的时间复杂度就会由原先的O(n)变为O(logN)。下面是其基本结构："></a>ConcurrentHashMap在1.8中的实现，相比于1.7的版本基本上全部都变掉了。首先，取消了Segment分段锁的数据结构，取而代之的是数组+链表（红黑树）的结构。而对于锁的粒度，调整为对每个数组元素加锁（Node）。然后是定位节点的hash算法被简化了，这样带来的弊端是Hash冲突会加剧。因此在链表节点数量大于8时，会将链表转化为红黑树进行存储。这样一来，查询的时间复杂度就会由原先的O(n)变为O(logN)。下面是其基本结构：</h4><p> <img src="https://img-blog.csdn.net/20180522155453418?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ltMTIzNDU2Njc3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>1.8中放弃了<code>Segment</code>臃肿的设计，取而代之的是采用<code>Node</code> + <code>CAS</code> + <code>Synchronized</code>来保证并发安全进行实现，</p>
<p>只有在执行第一次<code>put</code>方法时才会调用<code>initTable()</code>初始化<code>Node</code>数组，实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    table = tab = nt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="put实现"><a href="#put实现" class="headerlink" title="put实现"></a>put实现</h4><p>当执行<code>put</code>方法插入数据时，根据key的hash值，在<code>Node</code>数组中找到相应的位置，实现如下：</p>
<p>1、如果相应位置的<code>Node</code>还未初始化，则通过CAS插入相应的数据；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>, <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、如果相应位置的<code>Node</code>不为空，且当前该节点不处于移动状态，则对该节点加<code>synchronized</code>锁，如果该节点的<code>hash</code>不小于0，则遍历链表更新节点或插入新节点；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    binCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        K ek;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            ((ek = e.key) == key ||</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">             (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            oldVal = e.val;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                e.val = value;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Node&lt;K,V&gt; pred = e;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、如果该节点是<code>TreeBin</code>类型的节点，说明是红黑树结构，则通过<code>putTreeVal</code>方法往红黑树中插入节点；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Node&lt;K,V&gt; p;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    binCount = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        oldVal = p.val;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            p.val = value;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、如果<code>binCount</code>不为0，说明<code>put</code>操作对数据产生了影响，如果当前链表的个数达到8个，则通过<code>treeifyBin</code>方法转化为红黑树，如果<code>oldVal</code>不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        treeifyBin(tab, i);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> oldVal;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、如果插入的是一个新节点，则执行<code>addCount()</code>方法尝试更新元素个数<code>baseCount</code>；</p>
<h4 id="size实现-1"><a href="#size实现-1" class="headerlink" title="size实现"></a>size实现</h4><p>1.8中使用一个<code>volatile</code>类型的变量<code>baseCount</code>记录元素的个数，当插入新数据或则删除数据时，会通过<code>addCount()</code>方法更新<code>baseCount</code>，实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">as</span> = counterCells) != <span class="literal">null</span> ||</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    CounterCell a; long v; int m;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    boolean uncontended = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">as</span> == <span class="literal">null</span> || (m = <span class="keyword">as</span>.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        (a = <span class="keyword">as</span>[ThreadLocalRandom.getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        !(uncontended =</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        fullAddCount(x, uncontended);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    s = sumCount();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、初始化时<code>counterCells</code>为空，在并发量很高时，如果存在两个线程同时执行<code>CAS</code>修改<code>baseCount</code>值，则失败的线程会继续执行方法体中的逻辑，使用<code>CounterCell</code>记录元素个数的变化；</p>
<p>2、如果<code>CounterCell</code>数组<code>counterCells</code>为空，调用<code>fullAddCount()</code>方法进行初始化，并插入对应的记录数，通过<code>CAS</code>设置cellsBusy字段，只有设置成功的线程才能初始化<code>CounterCell</code>数组，实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; counterCells == <span class="keyword">as</span> &amp;&amp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    boolean init = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (counterCells == <span class="keyword">as</span>) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            CounterCell[] rs = <span class="keyword">new</span> CounterCell[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> CounterCell(x);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            counterCells = rs;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            init = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        cellsBusy = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (init)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、如果通过<code>CAS</code>设置cellsBusy字段失败的话，则继续尝试通过<code>CAS</code>修改<code>baseCount</code>字段，如果修改<code>baseCount</code>字段成功的话，就退出循环，否则继续循环插入<code>CounterCell</code>对象；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, v = baseCount, v + x))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>所以在1.8中的<code>size</code>实现比1.7简单多，因为元素个数保存<code>baseCount</code>中，部分元素的变化个数保存在<code>CounterCell</code>数组中，实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> n = sumCount();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            (<span class="keyword">int</span>)n);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> sum = baseCount;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                sum += a.value;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过累加<code>baseCount</code>和<code>CounterCell</code>数组中的数量，即可得到元素的总个数；</p>
]]></content>
      <categories>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>DFA_NFA</title>
    <url>/2020/08/24/DFA-NFA/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍DFA_NFA</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="NFA-DFA"><a href="#NFA-DFA" class="headerlink" title="NFA_DFA"></a>NFA_DFA</h2><p><img src="https://photos.alitaalice.cn/image/20200824120137.png" alt=""></p>
<p>![](<a href="https://photos.al">https://photos.al</a> itaalice.cn/image/20200824151626.png)</p>
<p><img src="https://photos.alitaalice.cn/image/20200824152805.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200824153438.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200824154417.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200824154443.png" alt=""></p>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Dp动态规划</title>
    <url>/2020/09/09/Dp%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="动态规划算法的基本思想是："><a href="#动态规划算法的基本思想是：" class="headerlink" title="动态规划算法的基本思想是："></a>动态规划算法的基本思想是：</h2><p>将待求解的问题分解成若干个相互联系的子问题，先求解子问题，然后从这些子问题的解得到原问题的解；</p>
<p>对于重复出现的子问题，只在第一次遇到的时候对它进行求解，并把答案保存起来，让以后再次遇到时直接引用答案，不必重新求解</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>GetMapping和PostMapping的区别</title>
    <url>/2020/06/29/GetMapping%E5%92%8CPostMapping%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍GetMapping和PostMapping的区别</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>最近刚学完三大框架，回过头来做东西发现很多东西都忘了，GET\POST是有区别的<br>spring4.3中引进了｛@GetMapping、@PostMapping、@PutMapping、@DeleteMapping、@PatchMapping｝，来帮助简化常用的HTTP方法的映射，并更好地表达被注解方法的语义。<br>以@GetMapping为例，Spring官方文档说：<br>@GetMapping是一个组合注解，是@RequestMapping(method = RequestMethod.GET)的缩写。该注解将HTTP Get 映射到 特定的处理方法上。</p>
<p>以下是官方解释，供大家参考：</p>
<p>哪一些情况下，浏览器会发送get请求</p>
<ol>
<li><p>直接在浏览器地址栏输入某个地址</p>
</li>
<li><p>点击链接</p>
</li>
<li><p>表单默认的提交方式</p>
</li>
</ol>
<p>哪一些情况下，浏览器会发送post请求？</p>
<ol>
<li>设置表单method = “post”</li>
</ol>
<p>get请求的特点</p>
<ol>
<li><p>请求参数会添加到请求资源路劲的后面，只能添加少量参数（因为请求行只有一行，大约只能存放2K左右的数据）（2K左右的数据，看起来也不少。。。）</p>
</li>
<li><p>请求参数会显示在浏览器地址栏，路由器会记录请求地址</p>
</li>
</ol>
<p>post请求的特点</p>
<ol>
<li><p>请求参数添加到实体内容里面，可以添加大量的参数（也解释了为什么浏览器地址栏不能发送post请求，在地址栏里我们只能填写URL，并不能进入到Http包的实体当中）</p>
</li>
<li><p>相对安全，但是，post请求不会对请求参数进行加密处理（可以使用https协议来保证数据安全）。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常用命令</title>
    <url>/2020/06/03/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>初始化仓库</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>查看仓库的状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>

<p>向暂存区添加文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add</span><br></pre></td></tr></table></figure>

<p>保存仓库的历史记录</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">"first commit"</span></span><br></pre></td></tr></table></figure>

<p>查看提交日志</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>

<p>查看更改前后的差别</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure>

<p>显示分支一览表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>

<p>创建、切换分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b alita</span><br><span class="line">&#x2F;* 创建名为alita的分支 *&#x2F;</span><br></pre></td></tr></table></figure>

<p>合并分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">&#x2F;* 为了在历史记录中明确记录下本次分支合并。我们需要创建合并并提交 *&#x2F;</span><br><span class="line">git merge --no-ff alita</span><br></pre></td></tr></table></figure>

<p>以图表形式查看分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --graph</span><br></pre></td></tr></table></figure>

<p>添加远程仓库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:xxx</span><br></pre></td></tr></table></figure>

<p>推送至远程仓库</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p>从远程仓库获取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git@xxx</span><br></pre></td></tr></table></figure>

<p>获取最新的远程仓库分支</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git pull origin alita</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP协议</title>
    <url>/2020/05/18/HTTP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍HTTP协议</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-HTTP-协议用于客户端和服务器端之间的通信"><a href="#1-HTTP-协议用于客户端和服务器端之间的通信" class="headerlink" title="1 HTTP 协议用于客户端和服务器端之间的通信"></a>1 HTTP 协议用于客户端和服务器端之间的通信</h3><p>HTTP 协议能够明确区分哪端是客户端，哪端是服务器端  </p>
<h3 id="2-通过请求和响应的交换达成通信"><a href="#2-通过请求和响应的交换达成通信" class="headerlink" title="2 通过请求和响应的交换达成通信"></a>2 通过请求和响应的交换达成通信</h3><p>HTTP 协议规定，请求从客户端发出，最后服务器端响应该请求并返回  </p>
<p><img src="https://photos.alitaalice.cn/image/20200518114122.png" alt=""></p>
<p>起始行开头的GET表示请求访问服务器的类型，称为方法（method）。随后的字符串 /index.htm 指明了请求访问的资源对象，也叫做请求 URI（request-URI）。最后的 HTTP/1.1，即 HTTP 的版本号，用来提示客户端使用的 HTTP 协议功能  .</p>
<p>请求首部字段及内容实体稍后会作详细说明。接下来，我们继续讲解。接收到请求的服务器，会将请求内容的处理结果以响应的形式返回。  </p>
<p><img src="https://photos.alitaalice.cn/image/20200518114432.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200518114521.png" alt=""></p>
<h3 id="3-HTTP-是不保存状态的协议"><a href="#3-HTTP-是不保存状态的协议" class="headerlink" title="3 HTTP 是不保存状态的协议"></a>3 HTTP 是不保存状态的协议</h3><p>HTTP 是一种不保存状态，即无状态（stateless）协议。HTTP 协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。  </p>
<p><img src="https://photos.alitaalice.cn/image/20200518114709.png" alt=""></p>
<h3 id="4-请求URI定位资源"><a href="#4-请求URI定位资源" class="headerlink" title="4 请求URI定位资源"></a>4 请求URI定位资源</h3><p><img src="https://photos.alitaalice.cn/image/20200518115112.png" alt=""></p>
<h3 id="5-HTTP方法"><a href="#5-HTTP方法" class="headerlink" title="5 HTTP方法"></a>5 HTTP方法</h3><p><img src="https://photos.alitaalice.cn/image/20200518164346.png" alt=""></p>
<h3 id="6-持久连接"><a href="#6-持久连接" class="headerlink" title="6 持久连接"></a>6 持久连接</h3><p>持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态，持久连接旨在建立 1 次 TCP 连接后进行多次请求和响应的交互。</p>
<h3 id="7-管线化"><a href="#7-管线化" class="headerlink" title="7 管线化"></a>7 管线化</h3><p>持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。<br>这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。  </p>
<p><img src="https://photos.alitaalice.cn/image/20200518164857.png" alt=""></p>
<h3 id="8-使用Cookie的状态管理"><a href="#8-使用Cookie的状态管理" class="headerlink" title="8 使用Cookie的状态管理"></a>8 使用Cookie的状态管理</h3><p><img src="https://photos.alitaalice.cn/image/20200518165228.png" alt=""></p>
<h3 id="各层对应的协议"><a href="#各层对应的协议" class="headerlink" title="各层对应的协议"></a>各层对应的协议</h3><h3 id="OSI七层对各层协议"><a href="#OSI七层对各层协议" class="headerlink" title="OSI七层对各层协议"></a>OSI七层对各层协议</h3>]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap默认加载因子为什么选择0.75</title>
    <url>/2020/05/13/HashMap%E9%BB%98%E8%AE%A4%E5%8A%A0%E8%BD%BD%E5%9B%A0%E5%AD%90%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A90.75/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍HashMap加载因子和初始容量</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>转载自<a href="https://www.cnblogs.com/aspirant/p/11470928.html">https://www.cnblogs.com/aspirant/p/11470928.html</a></p>
]]></content>
      <categories>
        <category>JAVA源码</category>
      </categories>
      <tags>
        <tag>JAVA源码</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA_String_API</title>
    <url>/2020/05/06/JAVA-String-API/</url>
    <content><![CDATA[<p>String API</p>
<ul>
<li>append()</li>
</ul>
<p>  在由许多小段的字符串构建一个字符串时，则使用StringBuilder类（字符串构造器）</p>
<p>  首先构造一个空的字符串构造器：<br>  <a id="more"></a></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder builder =<span class="keyword">new</span> StringBuilder();</span><br></pre></td></tr></table></figure>

<p>  当需要添加一部分内容时，调用append()方法</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">builder.append(ch);</span><br><span class="line">builder.append(str);</span><br><span class="line">String completedString=builder.toString(); <span class="comment">/*调用toString()方法，得到String对象。*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>char charAt(int index)</p>
<p>返回给定位置的代码单元。</p>
</li>
<li><p>int length()</p>
</li>
</ul>
<p>​         返回字符串代码单元的个数</p>
<ul>
<li><p>String repeat(int count)</p>
<p>返回一个字符串，将当前字符重复count次</p>
</li>
<li><p>boolean equals() </p>
<p>用来检测俩个字符串是否相等</p>
<p>boolean equalsIgnoreCase() </p>
<p>用来检测俩个字符串是否相等（不区分大小写）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">"hello"</span>.equals(greeting);</span><br><span class="line"><span class="string">"HELLO"</span>.equalsIgnoreCase(<span class="string">"hello"</span>); <span class="comment">/* 不区分大小写 */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注意：</p>
<p><strong>不要用==运算符检测是否相等。</strong></p>
<p><strong>这个运算符只能够确定俩个字符串是否存放在同一个位置上。</strong>当然如果字符串存放在同一个位置上，它们必然相等，但是完全有可能把内容相同的多个字符串副本放置在不同的位置上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String greeting=<span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">if</span>(greeting ==<span class="string">"Hello"</span>)</span><br><span class="line">  -- <span class="keyword">true</span></span><br><span class="line"> <span class="keyword">if</span>(greeting.substring(<span class="number">0</span>,<span class="number">3</span>)==<span class="string">"Hel"</span>)</span><br><span class="line">  --<span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<p>实际上只有字符串字面量共享，而+或者substring操作得到的字符串并不共享。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JAVASE</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP状态码</title>
    <url>/2020/05/13/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍返回结果的HTTP状态码。</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h1 id="1-状态码告知从服务器端返回的请求结果"><a href="#1-状态码告知从服务器端返回的请求结果" class="headerlink" title="1 状态码告知从服务器端返回的请求结果"></a>1 状态码告知从服务器端返回的请求结果</h1><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误  </p>
<p><img src="https://photos.alitaalice.cn/image/20200513120418.png" alt=""></p>
<p>状态码如 200 OK，以 3 位数字和原因短语组成。<br>数字中的第一位指定了响应类别，后两位无分类。响应类别有以下 5 种  </p>
<p><img src="https://photos.alitaalice.cn/image/20200513120523.png" alt=""></p>
<h2 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h2><h3 id="2-1-200-OK"><a href="#2-1-200-OK" class="headerlink" title="2.1 200 OK"></a>2.1 200 OK</h3><p><img src="https://photos.alitaalice.cn/image/20200513120936.png" alt=""></p>
<p>表示从客户端发来的请求在服务器端被正常处理了。<br>在响应报文内，随状态码一起返回的信息会因方法的不同而发生改变。比如，使用 GET 方法时，对应请求资源的实体会作为响应返回；而使用 HEAD 方法时，对应请求资源的实体首部不随报文主体作为响应返回（即在响应中只返回首部，不会返回实体的主体部分）  </p>
<h3 id="2-2-204-NOT-Content"><a href="#2-2-204-NOT-Content" class="headerlink" title="2.2 204 NOT Content"></a>2.2 204 NOT Content</h3><p><img src="https://photos.alitaalice.cn/image/20200513121124.png" alt=""></p>
<p>该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。比如，当从浏览器发出请求处理后，返回 204 响应，那么浏览器显示的页面不发生更新。<br>一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。  </p>
<h3 id="2-3-206-Partial-Content"><a href="#2-3-206-Partial-Content" class="headerlink" title="2.3 206 Partial Content"></a>2.3 206 Partial Content</h3><p><img src="https://photos.alitaalice.cn/image/20200513121229.png" alt=""></p>
<p>该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中包含由Content-Range 指定范围的实体内容。  </p>
<h2 id="3-3XX-重定向"><a href="#3-3XX-重定向" class="headerlink" title="3 3XX 重定向"></a>3 3XX 重定向</h2><p>3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。  </p>
<h3 id="3-1-301-Moved-Permanently"><a href="#3-1-301-Moved-Permanently" class="headerlink" title="3.1 301 Moved Permanently"></a>3.1 301 Moved Permanently</h3><p><img src="https://photos.alitaalice.cn/image/20200513121404.png" alt=""></p>
<p>永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。也就是说，如果已经把资源对应的 URI 保存为书签了，这时应该按 Location 首部字段提示的 URI 重新保存。像下方给出的请求 URI，当指定资源路径的最后忘记添加斜杠“/”，就会产生 301 状态码。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;example.com&#x2F;sample</span><br></pre></td></tr></table></figure>

<h3 id="3-2-302-Found"><a href="#3-2-302-Found" class="headerlink" title="3.2 302 Found"></a>3.2 302 Found</h3><p><img src="https://photos.alitaalice.cn/image/20200513121815.png" alt=""></p>
<h3 id="3-3-303-See-Other"><a href="#3-3-303-See-Other" class="headerlink" title="3.3  303 See Other"></a>3.3  303 See Other</h3><p><img src="https://photos.alitaalice.cn/image/20200513122022.png" alt=""></p>
<p>该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。<br>303 状态码和 302 Found 状态码有着相同的功能，但 303 状态码明确表示客户端应当采用 GET 方法获取资源，这点与 302 状态码有区别。<br>比如，当使用 POST 方法访问 CGI 程序，其执行后的处理结果是希望客户端能以 GET 方法重定向到另一个 URI 上去时，返回 303 状态码。虽然 302 Found 状态码也可以实现相同的功能，但这里使用 303 状态码是最理想的。  </p>
<h3 id="3-4-304-Not-Modified"><a href="#3-4-304-Not-Modified" class="headerlink" title="3.4 304 Not Modified"></a>3.4 304 Not Modified</h3><p><img src="C:%5CUsers%5C16508%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200513122317593.png" alt="image-20200513122317593"></p>
<p>该状态码表示客户端发送附带条件的请求 2 时，服务器端允许请求访问资源，但未满足条件的情况。304状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系。  </p>
<h3 id="3-5-307-Temporary-Redirect"><a href="#3-5-307-Temporary-Redirect" class="headerlink" title="3.5 307 Temporary Redirect"></a>3.5 307 Temporary Redirect</h3><p>临时重定向。该状态码与 302 Found 有着相同的含义。尽管 302 标准禁止 POST 变换成 GET，但实际使用时大家并不遵守。<br>307 会遵照浏览器标准，不会从 POST 变成 GET。但是，对于处理响应时的行为，每种浏览器有可能出现不同的情况。</p>
<h2 id="4-4XX客户端错误"><a href="#4-4XX客户端错误" class="headerlink" title="4 4XX客户端错误"></a>4 4XX客户端错误</h2><h3 id="4-1-400-Bad-Request"><a href="#4-1-400-Bad-Request" class="headerlink" title="4.1 400 Bad Request"></a>4.1 400 Bad Request</h3><p><img src="https://photos.alitaalice.cn/image/20200513122701.png" alt=""></p>
<p>该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。  </p>
<h3 id="4-2-401-Unauthorized"><a href="#4-2-401-Unauthorized" class="headerlink" title="4.2 401 Unauthorized"></a>4.2 401 Unauthorized</h3><p>-+<img src="https://photos.alitaalice.cn/image/20200513122941.png" alt=""></p>
<p>该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。另外若之前已进行过 1 次请求，则表示用户认证失败。  </p>
<h3 id="4-3-403-Forbidden"><a href="#4-3-403-Forbidden" class="headerlink" title="4.3 403 Forbidden"></a>4.3 403 Forbidden</h3><p><img src="https://photos.alitaalice.cn/image/20200513123055.png" alt=""></p>
<p>该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了。<br>未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源 IP 地址试图访问）等列举的情况都可能是发生 403 的原因。  </p>
<h3 id="4-4-404-Not-Found"><a href="#4-4-404-Not-Found" class="headerlink" title="4.4 404 Not Found"></a>4.4 404 Not Found</h3><p><img src="https://photos.alitaalice.cn/image/20200513123152.png" alt=""></p>
<p>该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。  </p>
<h2 id="5-5XX-服务器错误"><a href="#5-5XX-服务器错误" class="headerlink" title="5 5XX 服务器错误"></a>5 5XX 服务器错误</h2><p>5XX 的响应结果表明服务器本身发生错误。  </p>
<h3 id="5-1-500-Internal-Server-Error"><a href="#5-1-500-Internal-Server-Error" class="headerlink" title="5.1 500 Internal Server Error"></a>5.1 500 Internal Server Error</h3><p>该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。  <img src="C:%5CUsers%5C16508%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200513123521561.png" alt="image-20200513123521561"></p>
<h3 id="5-2-503-Service-Unavailable"><a href="#5-2-503-Service-Unavailable" class="headerlink" title="5.2 503 Service Unavailable"></a>5.2 503 Service Unavailable</h3><p><img src="https://photos.alitaalice.cn/image/20200513123558.png" alt=""></p>
<p>该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入 RetryAfter 首部字段再返回给客户端。  </p>
]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA中的输入与输出</title>
    <url>/2020/05/06/JAVA%E4%B8%AD%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<h1 id="JAVA中的输入"><a href="#JAVA中的输入" class="headerlink" title="JAVA中的输入"></a>JAVA中的输入</h1><h2 id="读取输入"><a href="#读取输入" class="headerlink" title="读取输入"></a>读取输入</h2><p>  要想通过输入台进行输入，首先需要构造一个与“标准输入流”System.in关联的Scanner对象。<br>  <a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner scanner=<span class="keyword">new</span> Scanner(System.in);</span><br></pre></td></tr></table></figure>

<p>Scanner类中的方法：</p>
<p>API  JAVA.util.Scanner</p>
<table>
<thead>
<tr>
<th>String nextLine()</th>
<th>读取输入的下一行内容  以enter作为结束符  能得到带空格的字符串</th>
</tr>
</thead>
<tbody><tr>
<td>String next()</td>
<td>读取输入的下一个单词（以空格作为分隔符）空格视而不见</td>
</tr>
<tr>
<td>int nextInt()</td>
<td>只读取int值</td>
</tr>
<tr>
<td>double nextDouble()</td>
<td>只读取double值</td>
</tr>
<tr>
<td>boolean hasNext()</td>
<td>检测输入中是否还有其他的单词</td>
</tr>
<tr>
<td>boolean hasNextInt()</td>
<td>检测输入中是否还有表示整数</td>
</tr>
<tr>
<td>boolean hasNextDouble()</td>
<td>检测输入中是否还有表示浮点数</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>JAVASE</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA中this和super的用法总结</title>
    <url>/2020/05/09/JAVA%E4%B8%ADthis%E5%92%8Csuper%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍这几天看到类在继承时会用到<strong>this</strong>和<strong>super</strong>，这里就做了一点总结，与各位共同交流，有错误请各位指正~</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><strong>this</strong></p>
<p>this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。</p>
<h2 id="this的用法在java中大体可以分为3种："><a href="#this的用法在java中大体可以分为3种：" class="headerlink" title="this的用法在java中大体可以分为3种："></a>this的用法在java中大体可以分为3种：</h2><p><strong>1.普通的直接引用</strong></p>
<p>这种就不用讲了，this相当于是指向当前对象本身。</p>
<p><strong>2.形参与成员名字重名，用this来区分：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"初始化年龄："</span>+age);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person Harry = <span class="keyword">new</span> Person();</span><br><span class="line">        System.out.println(<span class="string">"Harry's age is "</span>+Harry.GetAge(<span class="number">12</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><strong>初始化年龄：10</strong><br><strong>Harry’s age is 12</strong></p>
<p>可以看到，这里age是GetAge成员方法的形参，this.age是Person类的成员变量。</p>
<p><strong>3.引用构造函数</strong></p>
<p>这个和super放在一起讲，见下面。</p>
<h2 id="super"><a href="#super" class="headerlink" title="super"></a><strong>super</strong></h2><p>super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。</p>
<h3 id="super也有三种用法："><a href="#super也有三种用法：" class="headerlink" title="super也有三种用法："></a>super也有三种用法：</h3><p>1.普通的直接引用</p>
<p>与this类似，super相当于是指向当前对象的父类，这样就可以用super.xxx来引用父类的成员。</p>
<p>2.子类中的成员变量或方法与父类中的成员变量或方法同名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Country</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       name = <span class="string">"China"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">City</span> <span class="keyword">extends</span> <span class="title">Country</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    name = <span class="string">"Shanghai"</span>;</span><br><span class="line">    <span class="keyword">super</span>.value();      <span class="comment">//调用父类的方法</span></span><br><span class="line">    System.out.println(name);</span><br><span class="line">    System.out.println(<span class="keyword">super</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       City c=<span class="keyword">new</span> City();</span><br><span class="line">       c.value();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><strong>Shanghai</strong><br><strong>China</strong></p>
<p>可以看到，这里既调用了父类的方法，也调用了父类的变量。若不调用父类方法value()，只调用父类变量name的话，则父类name值为默认值null。</p>
<p>3.引用构造函数</p>
<p>super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。</p>
<p>this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prt</span><span class="params">(String s)</span> </span>&#123; </span><br><span class="line">       System.out.println(s); </span><br><span class="line">    &#125; </span><br><span class="line">   </span><br><span class="line">    Person() &#123; </span><br><span class="line">       prt(<span class="string">"父类·无参数构造方法： "</span>+<span class="string">"A Person."</span>); </span><br><span class="line">    &#125;<span class="comment">//构造方法(1) </span></span><br><span class="line">    </span><br><span class="line">    Person(String name) &#123; </span><br><span class="line">       prt(<span class="string">"父类·含一个参数的构造方法： "</span>+<span class="string">"A person's name is "</span> + name); </span><br><span class="line">    &#125;<span class="comment">//构造方法(2) </span></span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line">    Chinese() &#123; </span><br><span class="line">       <span class="keyword">super</span>(); <span class="comment">// 调用父类构造方法（1） </span></span><br><span class="line">       prt(<span class="string">"子类·调用父类”无参数构造方法“： "</span>+<span class="string">"A chinese coder."</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    Chinese(String name) &#123; </span><br><span class="line">       <span class="keyword">super</span>(name);<span class="comment">// 调用父类具有相同形参的构造方法（2） </span></span><br><span class="line">       prt(<span class="string">"子类·调用父类”含一个参数的构造方法“： "</span>+<span class="string">"his name is "</span> + name); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    Chinese(String name, <span class="keyword">int</span> age) &#123; </span><br><span class="line">       <span class="keyword">this</span>(name);<span class="comment">// 调用具有相同形参的构造方法（3） </span></span><br><span class="line">       prt(<span class="string">"子类：调用子类具有相同形参的构造方法：his age is "</span> + age); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">       Chinese cn = <span class="keyword">new</span> Chinese(); </span><br><span class="line">       cn = <span class="keyword">new</span> Chinese(<span class="string">"codersai"</span>); </span><br><span class="line">       cn = <span class="keyword">new</span> Chinese(<span class="string">"codersai"</span>, <span class="number">18</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><strong>父类·无参数构造方法： A Person.</strong><br><strong>子类·调用父类”无参数构造方法“： A chinese coder.</strong><br><strong>父类·含一个参数的构造方法： A person’s name is codersai</strong><br><strong>子类·调用父类”含一个参数的构造方法“： his name is codersai</strong><br><strong>父类·含一个参数的构造方法： A person’s name is codersai</strong><br><strong>子类·调用父类”含一个参数的构造方法“： his name is codersai</strong><br><strong>子类：调用子类具有相同形参的构造方法：his age is 18</strong></p>
<p>从本例可以看到，可以用super和this分别调用父类的构造方法和本类中其他形式的构造方法。</p>
<p>例子中Chinese类第三种构造方法调用的是本类中第二种构造方法，而第二种构造方法是调用父类的，因此也要先调用父类的构造方法，再调用本类中第二种，最后是重写第三种构造方法。</p>
<p><strong>super和this的异同：</strong></p>
<ul>
<li>super（参数）：调用基类中的某一个构造函数（应该为构造函数中的第一条语句） </li>
<li>this（参数）：调用本类中另一种形成的构造函数（应该为构造函数中的第一条语句）</li>
<li>super:　它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名  super.成员函数据名（实参）</li>
<li>this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）</li>
<li>调用super()必须写在子类构造方法的第一行，否则编译不通过。每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。</li>
<li>super()和this()类似,区别是，super()从子类中调用父类的构造方法，this()在同一类内调用其它方法。</li>
<li>super()和this()均需放在构造方法内第一行。</li>
<li>尽管可以用this调用一个构造器，但却不能调用两个。</li>
<li>this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。</li>
<li>this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。</li>
<li>从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap相关</title>
    <url>/2020/05/29/HashMap%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍HashMap相关</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="1-基于拉链和线性探测法的散列表"><a href="#1-基于拉链和线性探测法的散列表" class="headerlink" title="1 基于拉链和线性探测法的散列表"></a>1 基于拉链和线性探测法的散列表</h2><p><a href="https://www.alitaalice.cn/2020/05/13/%E5%9F%BA%E4%BA%8E%E6%8B%89%E9%93%BE%E5%92%8C%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95%E7%9A%84%E6%95%A3%E5%88%97%E8%A1%A8/">https://www.alitaalice.cn/2020/05/13/%E5%9F%BA%E4%BA%8E%E6%8B%89%E9%93%BE%E5%92%8C%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95%E7%9A%84%E6%95%A3%E5%88%97%E8%A1%A8/</a></p>
<h2 id="2-hashcode"><a href="#2-hashcode" class="headerlink" title="2 hashcode()"></a>2 hashcode()</h2><p><a href="https://www.alitaalice.cn/2020/05/13/%E6%95%A3%E5%88%97%E8%A1%A8%E8%AF%A6%E8%A7%A3/">https://www.alitaalice.cn/2020/05/13/%E6%95%A3%E5%88%97%E8%A1%A8%E8%AF%A6%E8%A7%A3/</a></p>
<h2 id="3-HashMap加载因子和初始容量"><a href="#3-HashMap加载因子和初始容量" class="headerlink" title="3 HashMap加载因子和初始容量"></a>3 HashMap加载因子和初始容量</h2><p>转载自<a href="https://www.cnblogs.com/aspirant/p/11470928.html4">https://www.cnblogs.com/aspirant/p/11470928.html4</a></p>
<h3 id="4-当两个对象的hashcode相同时会发生什么，如何获取对象"><a href="#4-当两个对象的hashcode相同时会发生什么，如何获取对象" class="headerlink" title="4 当两个对象的hashcode相同时会发生什么，如何获取对象"></a>4 当两个对象的hashcode相同时会发生什么，如何获取对象</h3><p>因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。这个时候要理解根据hashcode来划分的数组，如果数组的坐标相同，则进入链表这个数据结构中了，一般的添加都在最前面，也就是和数组下标直接相连的地方，链表长度到达8的时候，jdk1.8上升为红黑树.</p>
<h3 id="5-HashMap中的tableSizeFor方法"><a href="#5-HashMap中的tableSizeFor方法" class="headerlink" title="5  HashMap中的tableSizeFor方法"></a>5  HashMap中的tableSizeFor方法</h3><p>在使用指定数组的初始容量时上面说过，<strong>数组容量必须是2的次方。所以就需要通过算法将我们给定的数值转换成2的次方。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个方法可以将任意一个整数转换成2的次方。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-重新调整HashMap大小存在什么问题吗"><a href="#6-重新调整HashMap大小存在什么问题吗" class="headerlink" title="6 重新调整HashMap大小存在什么问题吗"></a>6 重新调整HashMap大小存在什么问题吗</h3><p>当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。(多线程的环境下不使用HashMap）</p>
<p>HashMap的容量是有限的。当经过多次元素插入，使得HashMap达到一定饱和度时，Key映射位置发生冲突的几率会逐渐提高。这时候，HashMap需要扩展它的长度，也就是进行Resize。</p>
<ol>
<li>扩容：创建一个新的Entry空数组，长度是原数组的2倍。</li>
<li>ReHash：遍历原Entry数组，把所有的Entry重新Hash到新数组。</li>
</ol>
<h3 id="7-如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？"><a href="#7-如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？" class="headerlink" title="7 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？"></a>7 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</h3><p>默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。这个值只可能在两个地方，一个是原下标的位置，另一种是在下标为&lt;原下标+原容量&gt;的位置</p>
<h3 id="8-我们可以使用自定义的对象作为HashMap的键吗"><a href="#8-我们可以使用自定义的对象作为HashMap的键吗" class="headerlink" title="8 我们可以使用自定义的对象作为HashMap的键吗"></a>8 我们可以使用自定义的对象作为HashMap的键吗</h3><p>作为HashMap的key的自定义类需要重写hashCode()和equals()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xxx.demo;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用HashMap集合,存储自定义的对象。 如果自定义的对象作为键(键不能重复),需要重写自定义类型的hashCode()和equals()方法。</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		function();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">		HashMap&lt;Person, String&gt; map = <span class="keyword">new</span> HashMap&lt;Person, String&gt;();</span><br><span class="line">		map.put(<span class="keyword">new</span> Person(<span class="string">"a"</span>,<span class="number">20</span>), <span class="string">"里约热内卢"</span>);</span><br><span class="line">		map.put(<span class="keyword">new</span> Person(<span class="string">"b"</span>,<span class="number">18</span>), <span class="string">"索马里"</span>);</span><br><span class="line">		map.put(<span class="keyword">new</span> Person(<span class="string">"b"</span>,<span class="number">18</span>), <span class="string">"索马里"</span>);</span><br><span class="line">		map.put(<span class="keyword">new</span> Person(<span class="string">"c"</span>,<span class="number">19</span>), <span class="string">"百慕大"</span>);</span><br><span class="line">		<span class="keyword">for</span>(Person key : map.keySet())&#123;  <span class="comment">// 通过keySet()遍历</span></span><br><span class="line">			String value = map.get(key);</span><br><span class="line">			System.out.println(key+<span class="string">"..."</span>+value);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"==================="</span>);</span><br><span class="line">		<span class="keyword">for</span>(Map.Entry&lt;Person, String&gt; entry : map.entrySet())&#123;  <span class="comment">// 通过entrySet()遍历</span></span><br><span class="line">			System.out.println(entry.getKey()+<span class="string">"..."</span>+entry.getValue());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-jdk7和jdk8的HashMap实现的区别"><a href="#9-jdk7和jdk8的HashMap实现的区别" class="headerlink" title="9 jdk7和jdk8的HashMap实现的区别"></a>9 jdk7和jdk8的HashMap实现的区别</h3><p>JDK7中的HashMap</p>
<p>基于链表+数组实现,底层维护一个Entry数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Entry&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>

<p>根据计算的hashCode将对应的KV键值对存储到该table中，一旦发生hashCode冲突，那么就会将该KV键值对放到对应的已有元素的后面， 此时，形成了一个链表式的存储结构,如下图<img src="https://photos.alitaalice.cn/image/20200601154028.png" alt=""></p>
<p>JDK8中的HashMap</p>
<p>基于位桶+链表/红黑树的方式实现,底层维护一个Node数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>

<p>在JDK7中HashMap,当成百上千个节点在hash时发生碰撞，存储一个链表中，那么如果要查找其中一个节点，那就不可避免的花费O(N)的查找时间，这将是多么大的性能损失,这个问题终于在JDK8中得到了解决。</p>
<p>JDK8中,HashMap采用的是位桶+链表/红黑树的方式,当链表的存储的数据个数大于等于8的时候，不再采用链表存储，而采用了红黑树存储结构。这是JDK7与JDK8中HashMap实现的最大区别。 如下图所示：<img src="https://photos.alitaalice.cn/image/20200601154120.png" alt=""></p>
<h3 id="10-HashMap与LinkedHashMap和TreeMap-Hashtable的区别"><a href="#10-HashMap与LinkedHashMap和TreeMap-Hashtable的区别" class="headerlink" title="10  HashMap与LinkedHashMap和TreeMap Hashtable的区别"></a>10  HashMap与LinkedHashMap和TreeMap Hashtable的区别</h3><p><strong>HashMap</strong>: 最常用的Map,它根据键的HashCode 值存储数据,根据键可以直接获取它的值，具有很快的访问速度。HashMap最多只允许一条记录的键为Null(多条会覆盖);允许多条记录的值为 Null。非同步的。 </p>
<p><strong>TreeMap</strong>: 能够把它保存的记录根据键(key)排序,默认是按升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。TreeMap不允许key的值为null。非同步的。 </p>
<p><strong>Hashtable:</strong> 与 HashMap类似,不同的是:key和value的值均不允许为null;它支持线程的同步，即任一时刻只有一个线程能写Hashtable,因此也导致了Hashtable在写入时会比较慢。 </p>
<p><strong>LinkedHashMap</strong>: 保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.在遍历的时候会比HashMap慢。key和value均允许为空，非同步的。 </p>
<h3 id="11-为什么-HashMap-中-String、Integer-这样的包装类适合作为-key-键，即为什么使用它们可以减少哈希碰撞？"><a href="#11-为什么-HashMap-中-String、Integer-这样的包装类适合作为-key-键，即为什么使用它们可以减少哈希碰撞？" class="headerlink" title="11 为什么 HashMap 中 String、Integer 这样的包装类适合作为 key 键，即为什么使用它们可以减少哈希碰撞？"></a>11 为什么 HashMap 中 String、Integer 这样的包装类适合作为 key 键，即为什么使用它们可以减少哈希碰撞？</h3><p>答：因为 String、Integer 等包装类是 <strong>final 类型的，具有不可变性，而且已经重写了 equals() 和 hashCode() 方法。</strong>不可变性保证了计算 hashCode() 后键值的唯一性和缓存特性，不会出现放入和获取时哈希码不同的情况且读取哈希值的高效性，此外官方实现的 equals() 和 hashCode() 都是严格遵守相关规范的，不会出现错误</p>
<p>12.HashMap是线程安全的吗，为什么</p>
<p>13.哪些是线程安全的容器</p>
<p>同步容器类：</p>
<p>使用了synchronized<br>1.Vector<br>2.HashTable</p>
<p>并发容器：<br>3.ConcurrentHashMap:　底层哈希实现的同步Map(Set)。效率高，线程安全。使用系统底层技术实现线程安全。量级较synchronized低。key和value不能为null<br>4.CopyOnWriteArrayList：写时复制<br>5.CopyOnWriteArraySet：写时复制</p>
]]></content>
      <categories>
        <category>JAVA集合</category>
      </categories>
      <tags>
        <tag>JAVA集合</tag>
      </tags>
  </entry>
  <entry>
    <title>I/O</title>
    <url>/2020/07/09/I-O/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍I/O</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h1 id="字符流和字节流"><a href="#字符流和字节流" class="headerlink" title="字符流和字节流"></a>字符流和字节流</h1><ul>
<li>字节流：一次读入或读出是8位二进制。</li>
<li>字符流：一次读入或读出是16位二进制。</li>
</ul>
<p><strong>设备上的数据无论是图片或者视频，文字，它们都以二进制存储的。二进制的最终都是以一个8位为数据单元进行体现，所以计算机中的最小数据单元就是字节。意味着，字节流可以处理设备上的所有数据，所以字节流一样可以处理字符数据。</strong></p>
<h4 id="结论：只要是处理纯文本数据，就优先考虑使用字符流。-除此之外都使用字节流。"><a href="#结论：只要是处理纯文本数据，就优先考虑使用字符流。-除此之外都使用字节流。" class="headerlink" title="结论：只要是处理纯文本数据，就优先考虑使用字符流。 除此之外都使用字节流。"></a><strong>结论：只要是处理纯文本数据，就优先考虑使用字符流。 除此之外都使用字节流。</strong></h4><h1 id="输入流和输出流"><a href="#输入流和输出流" class="headerlink" title="输入流和输出流"></a>输入流和输出流</h1><h2 id="输入字节流-InputStream"><a href="#输入字节流-InputStream" class="headerlink" title="输入字节流 InputStream"></a>输入字节流 InputStream</h2><ul>
<li><code>InputStream</code> 是所有的输入字节流的父类，它是一个抽象类。</li>
<li><code>ByteArrayInputStream</code>、<code>StringBufferInputStream</code>、<code>FileInputStream</code> 是三种基本的介质流，它们分别从<code>Byte 数组</code>、<code>StringBuffer</code>、和<code>本地文件</code>中读取数据。</li>
<li><code>PipedInputStream</code> 是从与其它线程共用的管道中读取数据，与Piped 相关的知识后续单独介绍。</li>
<li><code>ObjectInputStream</code> 和所有<code>FilterInputStream</code> 的子类都是装饰流（装饰器模式的主角）。</li>
</ul>
<h2 id="输出字节流-OutputStream"><a href="#输出字节流-OutputStream" class="headerlink" title="输出字节流 OutputStream"></a>输出字节流 OutputStream</h2><ul>
<li><code>OutputStream</code> 是所有的输出字节流的父类，它是一个抽象类。</li>
<li><code>ByteArrayOutputStream</code>、<code>FileOutputStream</code> 是两种基本的介质流，它们分别向<code>Byte 数组</code>、和<code>本地文件</code>中写入数据。</li>
<li><code>PipedOutputStream</code> 是向与其它线程共用的管道中写入数据。</li>
<li><code>ObjectOutputStream</code> 和所有<code>FilterOutputStream</code> 的子类都是装饰流。</li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li><p>输入流：InputStream或者Reader：从文件中读到程序中；</p>
</li>
<li><p>输出流：OutputStream或者Writer：从程序中输出到文件中；</p>
</li>
<li><h1 id="装饰流使用"><a href="#装饰流使用" class="headerlink" title="装饰流使用"></a>装饰流使用</h1><p>​     除了按照流的方向可以把流划分为输入流和输出流两类，按照流读写数据的基本单位把流划分为字节流和字符流两类以外，还可以按照流是否直接连接实际数据源，例如文件、网络、字节数组等，将流又可以划分为实体流和装饰流两大类。</p>
<p>​     其中实体流指直接连接数据源的流类，如前面介绍的<strong>FileInputStream/FileOutputStream</strong>和<strong>FileReader和FileWriter</strong>，该类流直接实现将数据源转换为流对象，在实体流类中实现了流和数据源之间的转换，实体流类均可单独进行使用。</p>
<p>​     而装饰流指不直接连接数据源，而是以其它流对象(实体流对象或装饰流对象)为基础建立的流类，该类流实现了将实体流中的数据进行转换，增强流对象的读写能力，比较常用的有DataInputStream/DataOutputStream和BufferedReader/BufferedWriter等，装饰流类不可以单独使用，必须配合实体流或装饰流进行使用。</p>
<p>​     </p>
</li>
</ul>
<h1 id="流必须要关闭的原因"><a href="#流必须要关闭的原因" class="headerlink" title="流必须要关闭的原因"></a>流必须要关闭的原因</h1><p>java相对C,C++来说不需要手动释放内存,在对象引用被消除之后,正常情况下内存资源是会被垃圾回收,那么在使用完IO流之后为什么需要手动关闭.<br>这是<strong>为了回收系统资源</strong>,比如<strong>释放占用的端口,文件句柄,网络操作数据库应用</strong>等.对Unix系统来说,所有的资源都可以抽象成文件,所以可以通过lsof来观察。</p>
<p>看下面这个例子,我们创建许多的IO流，但是不关闭</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            FileInputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">"/tmp/data/data"</span>+i);</span><br><span class="line">            <span class="keyword">byte</span>[] bs = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">512</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(bs)) != -<span class="number">1</span>) ;</span><br><span class="line">            Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">10000L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行这个程序之后,使用losf命令查看相关的文件句柄,会发现文件句柄始终在增长,当积累到一定时间之后会出现too many open files错误</p>
<h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alita.demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Title:</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * Company:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> im.alitaalice@gmail.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> Created in 20:08 2020/8/19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputStreamController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FileInputStreamController fileInputStreamController = <span class="keyword">new</span> FileInputStreamController();</span><br><span class="line">        String filePath = <span class="string">"E:/Demo/abc.txt"</span>;</span><br><span class="line">        String result = fileInputStreamController.readFile(filePath);</span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readFile</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">null</span>;</span><br><span class="line">        String result = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileInputStream = <span class="keyword">new</span> FileInputStream(filePath);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * available():返回与之关联的文件的字节数</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">int</span> lenth = fileInputStream.available();</span><br><span class="line">            <span class="keyword">byte</span>[] array = <span class="keyword">new</span> <span class="keyword">byte</span>[lenth];</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 把数据读到数组中去</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            fileInputStream.read(array);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 根据获取到的Byte数组新建一个字符串，然后输出</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            result = <span class="keyword">new</span> String(array);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                fileInputStream.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">############################</span><br><span class="line">    abcsdadasd</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alita.demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Title:</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * Company:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> im.alitaalice@gmail.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> Created in 20:33 2020/8/19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileOutputSteamController</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FileOutputSteamController fileOutputSteamController = <span class="keyword">new</span> FileOutputSteamController();</span><br><span class="line">        String filePath = <span class="string">"E:/Demo/abc.txt"</span>;</span><br><span class="line">        String content = <span class="string">"今天天气很好，hello world"</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * it will replace</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        fileOutputSteamController.writeFile(filePath, content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFile</span><span class="params">(String filePath, String content)</span> </span>&#123;</span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            fileOutputStream = <span class="keyword">new</span> FileOutputStream(filePath);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] array = content.getBytes();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * array写入到filePath</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            fileOutputStream.write(array);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                fileOutputStream.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">#############################</span><br><span class="line">    今天天气很好，hello world</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JAVASE</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA内存区域与内存溢出异常</title>
    <url>/2020/05/15/JAVA%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍JAVA内存区域与内存溢出异常</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>类文件(<code>.class</code>文件扩展名)是包含Java字节码 <code>ByteCode</code>的文件，可以在Java虚拟机上执行，每个类文件包含了一个类，接口或者模块（Java 9）的定义.Java程序（<code>.java</code> 文件）可以通过 Java compiler 生成字节码文件，其他基于JVM的语言也都可以通过自己的编译器生成字节码文件，例如Scala，Groovy等JVM是与平台无关的，类文件可以在多个平台上执行，这使得相应的语言也与平台无关.</p>
<h2 id="JVM的内存布局"><a href="#JVM的内存布局" class="headerlink" title="JVM的内存布局"></a>JVM的内存布局</h2><p>虚拟机中，Java 内存区域可以划分为 6 个部分，程序计数器、虚拟机栈、本地方法栈（以上三个是线程私有的）、堆和方法区（里面有常量池，方法区与堆是线程共享的 )、直接内存（不受 JVM GC 管理）。除了直接内存，其他都是运行时数据区。</p>
<p><img src="https://photos.alitaalice.cn/image/20200517164736.png" alt=""></p>
<h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p><img src="https://photos.alitaalice.cn/image/20200517165000.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200517165050.png" alt=""></p>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p><img src="https://photos.alitaalice.cn/image/20200517164220.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200517165147.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200517165221.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200517165249.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200517165303.png" alt=""></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多态</title>
    <url>/2020/05/06/JAVA%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<h1 id="JAVA多态"><a href="#JAVA多态" class="headerlink" title="JAVA多态"></a>JAVA多态</h1><p>JAVA的三大特性为：</p>
<ul>
<li><p>封装</p>
</li>
<li><p>继承</p>
</li>
<li><p>多态</p>
<p>今天我们就来说一说到底什么是多态，以及多态到底有什么用。</p>
<a id="more"></a>

<h2 id="多态的定义"><a href="#多态的定义" class="headerlink" title="多态的定义"></a>多态的定义</h2><p>定义： <strong>事物的不同形态。</strong>多态多应用在向上转型。</p>
<p>多态的用处：在实际开发中，如果发现某个类的方法可以做出改进，但工程已经交付给用户使用，但是不想影响其他部分对于该方法的调用。那么通过创建子类对象，对于父类方法进行<strong>重写</strong>（Override）。<strong>但是此时父类的其他成员方法和成员属性却不能进行利用</strong>。此时就需要用到<strong>向上转型</strong>，将子类向上转换为父类，此时程序的相应方法做出了改进，程序的其他地方也不会受此影响。</p>
</li>
</ul>
<h2 id="多态的三个前提："><a href="#多态的三个前提：" class="headerlink" title="多态的三个前提："></a>多态的三个前提：</h2><ul>
<li><p>存在继承关系，子类继承父类</p>
</li>
<li><p>子类要重写父类的方法 </p>
<p>子类重写父类的成员方法。</p>
</li>
<li><p>父类数据类型的引用要指向子类对象 （向上转型）</p>
<p>如 Animal am=new Cat();</p>
<h2 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h2><p>向上转型之后，<strong>不能够引用子类特有的成员属性和子类特有的成员方法</strong>。</p>
</li>
</ul>
<p>  <strong>注意：静态方法不能被重写，所以也不存在多态，即使向上转型，子类重写了父类的静态方法，子类调用父类的静态方法，输出依然是父类静态方法中的值。</strong></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA和C++的区别</title>
    <url>/2020/05/11/JAVA%E5%92%8CC++%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍JAVA和C++的区别</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="JAVA和C-的区别"><a href="#JAVA和C-的区别" class="headerlink" title="JAVA和C++的区别"></a>JAVA和C++的区别</h2><ul>
<li>都是面向对象的语言，并且都支持封装，继承和多态</li>
<li>指针：JAVA不提供指针来直接访问内存，程序更加安全。</li>
<li>继承：JAVA中的类是单继承的，但是C++允许多继承，JAVA中允许一个类实现多个接口来实现C++中的多冲继承。</li>
<li>内存：JAVA有自动内存管理机制，不需要程序员手动释放无用内存。</li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA注解</title>
    <url>/2020/05/11/JAVA%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍 JAVA注解</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="1-注解的概述"><a href="#1-注解的概述" class="headerlink" title="1.注解的概述"></a>1.注解的概述</h2><p>注解的语法： @注解名称</p>
<p>注解的作用:  替代xml配置文件</p>
<p>我们以前总是要写一些配置文件，如web.xml 里面要写<servlet> 和<sevlet-mapping></p>
<p>tomcat用来读取配置文件</p>
<p>而在servlet3.0中可以使用注解来代替配置文件，@WebServlet 用来代替该配置文件</p>
<h2 id="2-JAVA中的注解"><a href="#2-JAVA中的注解" class="headerlink" title="2. JAVA中的注解"></a>2. JAVA中的注解</h2><ul>
<li>@Override</li>
<li>@Deprecated: 作用在方法上，标记该方法为作废方法 （已经过时的方法）</li>
<li>@SuppressWarning :作用在方法上，压制警告@SuppressWarnings(“all”)压制所有警告</li>
</ul>
<h2 id="3-注解的使用"><a href="#3-注解的使用" class="headerlink" title="3. 注解的使用"></a>3. 注解的使用</h2><ul>
<li>定义注解类：框架的工作</li>
<li>使用注解类：我们的工作</li>
<li>读取注解（反射）：框架的工作</li>
</ul>
<h2 id="4-自定义注解类"><a href="#4-自定义注解类" class="headerlink" title="4.自定义注解类"></a>4.自定义注解类</h2><p><strong>@interface</strong></p>
<p>eg:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnn&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-使用注解的目标"><a href="#5-使用注解的目标" class="headerlink" title="5.使用注解的目标"></a>5.使用注解的目标</h2><p>注解可以使用在类（接口或者枚举），属性，方法，构造器，包，参数，局部变量</p>
<p>eg:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MyAnn</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="meta">@MyAnn</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="meta">@MyAnn</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line"><span class="meta">@MyAnn</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line"><span class="meta">@MyAnn</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">(@MyAnn String s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="meta">@MyAnn</span></span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-注解的属性"><a href="#6-注解的属性" class="headerlink" title="6.注解的属性"></a>6.注解的属性</h2><p>定义注解时，也可以给出属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnn</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span></span>;  <span class="keyword">default</span> <span class="string">"hello world"</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">value1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中value就是属性，你可能会说value是一个方法，没错，它是一个方法，但是我们非要称之为属性，是因为把它当作属性更好理解:</p>
<p>eg:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MyAnn</span>(value1=<span class="number">100</span>,value=<span class="string">"hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class"></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注解的属性后面要有一对圆括号，而且圆括号内不能给出东西。就像是无参的方法一样；<br>注解的属性类型只能是：基本类型、String、Enum、Class、注解类型、以上类型的一维数组类型；<br>注解的属性可以有默认值，例如：int a() default 100;<br>数组的属性默认值：int[] arr() default {1,2,3}，这里不能使用new int[]{1,2,3}<br>使用注解时，在给数组属性赋值时的格式：@MyAnn(arr={1,2,3})；</li>
</ul>
<h2 id="7-元注解"><a href="#7-元注解" class="headerlink" title="7.元注解"></a>7.元注解</h2><p><strong>元注解：用于描述注解的注解</strong></p>
<p>@Target ：描述注解作用的位置</p>
<ul>
<li>ElementType取值：</li>
<li>TYPE：作用在类上</li>
<li>METHOD ：作用在方法上</li>
<li>FIELD ：作用在成员变量上</li>
</ul>
<p>eg：</p>
<p>Target 注解的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;  </span><br><span class="line">    ElementType[] value();  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ElementType &#123;  </span><br><span class="line">  TYPE,FIELD,METHOD,PARAMETED,CONSTRUCTOR,LOCAL_VARIABLE,ANNOCATION_TYPE,PACKAGE  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在定义注解时，可以使用@Target 注解来限制注解的作用目标</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnn</span><br><span class="line">&#123;&#125;  <span class="comment">/* 该注解定义在类和方法上 */</span></span><br><span class="line"><span class="meta">@MyAnn</span>()  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@MyAnn</span>()  <span class="comment">//报错  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;  </span><br><span class="line">      </span><br><span class="line">    <span class="meta">@MyAnn</span>()  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-注解的保留策略"><a href="#8-注解的保留策略" class="headerlink" title="8.注解的保留策略"></a>8.注解的保留策略</h2><ul>
<li><p>注解的保留策略是指</p>
<ul>
<li>注解保留在源代码（SOURCE)上</li>
<li>注解保留在class文件上（CLASS）</li>
<li>注解保留在类运行时（RUNTIME），可以被类加载器加载到内存中</li>
</ul>
</li>
<li><p>如果希望注解被反射，那么注解就是保留到运行时，而不是源代码或者类文件上</p>
</li>
<li><p>指定注解的保留策略需要使用元注解@Retention ，它有一个value属性，类型为RetentionPolicy</p>
<p>RetentionPolicy是枚举类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retention &#123;  </span><br><span class="line">    <span class="function">RetentionPolicy <span class="title">value</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RetentionPolicy &#123;  </span><br><span class="line">    SOURCE, CLASS, RUNTIME  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>eg：指定注解保留到运行时</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetionOPlicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnn</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> "hello"</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">value1</span><span class="params">()</span> <span class="keyword">default</span> 100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="9-注解处理器"><a href="#9-注解处理器" class="headerlink" title="9.注解处理器"></a>9.注解处理器</h2>]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA的静态方法不能被重写</title>
    <url>/2020/05/06/JAVA%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8D%E8%83%BD%E8%A2%AB%E9%87%8D%E5%86%99/</url>
    <content><![CDATA[<h1 id="JAVA的静态方法不能被重写"><a href="#JAVA的静态方法不能被重写" class="headerlink" title="JAVA的静态方法不能被重写"></a>JAVA的静态方法不能被重写</h1><p>堆区：</p>
<ul>
<li>存储的全部都是对象，每个对象都包含一个与之对应的class信息。<a id="more"></a>

</li>
</ul>
<p>栈区:</p>
<p>方法区：</p>
<ul>
<li>方法区包含所有的class和static变量  class可以直接调用static</li>
</ul>
]]></content>
      <categories>
        <category>JAVASE</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA源码问题</title>
    <url>/2020/05/14/JAVA%E6%BA%90%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍JAVA源码问题</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="说说常见的集合有哪些吧？"><a href="#说说常见的集合有哪些吧？" class="headerlink" title="说说常见的集合有哪些吧？"></a>说说常见的集合有哪些吧？</h2><p>答：Map 接口和 Collection 接口是所有集合框架的父接口：</p>
<ol>
<li>Collection 接口的子接口包括：Set 接口和 List 接口；</li>
<li>Map 接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap 以及 Properties 等；</li>
<li>Set 接口的实现类主要有：HashSet、TreeSet、LinkedHashSet 等；</li>
<li>List 接口的实现类主要有：ArrayList、LinkedList、Stack 以及 Vector 等。</li>
</ol>
<h3 id="当两个对象的hashcode相同时会发生什么，如何获取对象？"><a href="#当两个对象的hashcode相同时会发生什么，如何获取对象？" class="headerlink" title="当两个对象的hashcode相同时会发生什么，如何获取对象？"></a>当两个对象的hashcode相同时会发生什么，如何获取对象？</h3><p>因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。</p>
<p>两个对象的hashCode相同所以它们的bucket位置相同，找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点 <strong><code>(key != null &amp;&amp; key.equals(k)</code></strong>。</p>
<p>因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。这个时候要理解根据hashcode来划分的数组，如果数组的坐标相同，则进入链表这个数据结构中了，一般的添加都在最前面，也就是和数组下标直接相连的地方，链表长度到达8的时候，jdk1.8上升为红黑树。</p>
<h3 id="HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办"><a href="#HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办" class="headerlink" title="HashMap的大小超过了负载因子(load factor)定义的容量，怎么办"></a>HashMap的大小超过了负载因子(load factor)定义的容量，怎么办</h3><p>会调用<strong><code>resize()</code></strong>进行数组扩容。</p>
<h2 id="HashMap中的tableSizeFor方法"><a href="#HashMap中的tableSizeFor方法" class="headerlink" title="HashMap中的tableSizeFor方法"></a>HashMap中的tableSizeFor方法</h2><p>在使用指定数组的初始容量时上面说过，数组容量必须是2的次方。所以就需要通过算法将我们给定的数值转换成2的次方。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个方法可以将任意一个整数转换成2的次方。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashMap是线程安全的吗，为什么"><a href="#HashMap是线程安全的吗，为什么" class="headerlink" title="HashMap是线程安全的吗，为什么"></a>HashMap是线程安全的吗，为什么</h2><p>HashMap底层是一个Entry数组，当发生hash冲突的时候，hashmap是采用链表的方式来解决的，在对应的数组位置存放链表的头结点。对链表而言，新加入的节点会从头结点加入。</p>
<p>1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">	Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">        table[bucketIndex] = <span class="keyword">new</span> Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">        <span class="keyword">if</span> (size++ &gt;= threshold)</span><br><span class="line">            resize(<span class="number">2</span> * table.length);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在hashmap做put操作的时候会调用到以上的方法。现在假如A线程和B线程同时对同一个数组位置调用addEntry，两个线程会同时得到现在的头结点，然后A写入新的头结点之后，B也写入新的头结点，那B的写入操作就会覆盖A的写入操作造成A的写入操作丢失</p>
<p>2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeEntryForKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">        Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">        Entry&lt;K,V&gt; e = prev;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                modCount++;</span><br><span class="line">                size--;</span><br><span class="line">                <span class="keyword">if</span> (prev == e)</span><br><span class="line">                    table[i] = next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    prev.next = next;</span><br><span class="line">                e.recordRemoval(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>删除键值对的代码如上：</p>
<p>当多个线程同时操作同一个数组位置的时候，也都会先取得现在状态下该位置存储的头结点，然后各自去进行计算操作，之后再把结果写会到该数组位置去，其实写回的时候可能其他的线程已经就把这个位置给修改过了，就会覆盖其他线程的修改</p>
<p>3、addEntry中当加入新的键值对后键值对总数量超过门限值的时候会调用一个resize操作，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">        Entry[] oldTable = table;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">        transfer(newTable);</span><br><span class="line">        table = newTable;</span><br><span class="line">        threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个操作会新生成一个新的容量的数组，然后对原数组的所有键值对重新进行计算和写入新的数组，之后指向新生成的数组。</p>
<p>当多个线程同时检测到总数量超过门限值的时候就会同时调用resize操作，各自生成新的数组并rehash后赋给该map底层的数组table，结果最终只有最后一个线程生成的新数组被赋给table变量，其他线程的均会丢失。而且当某些线程已经完成赋值而其他线程刚开始的时候，就会用已经被赋值的table作为原始数组，这样也会有问题。</p>
<h2 id="哪些是线程安全的容器"><a href="#哪些是线程安全的容器" class="headerlink" title="哪些是线程安全的容器"></a>哪些是线程安全的容器</h2><p>同步容器类：</p>
<p>使用了synchronized<br>1.Vector<br>2.HashTable</p>
<p>并发容器：<br>3.ConcurrentHashMap:分段<br>4.CopyOnWriteArrayList：写时复制<br>5.CopyOnWriteArraySet：写时复制</p>
<h3 id="Hashtable和HashMap的区别"><a href="#Hashtable和HashMap的区别" class="headerlink" title="Hashtable和HashMap的区别"></a>Hashtable和HashMap的区别</h3><h3 id="HashMap多线程处理之快速失败机制"><a href="#HashMap多线程处理之快速失败机制" class="headerlink" title="HashMap多线程处理之快速失败机制"></a>HashMap多线程处理之快速失败机制</h3><h3 id="jdk7和jdk8的HashMap实现的区别"><a href="#jdk7和jdk8的HashMap实现的区别" class="headerlink" title="jdk7和jdk8的HashMap实现的区别"></a>jdk7和jdk8的HashMap实现的区别</h3><h3 id="HashMap与LinkedHashMap和TreeMap的区别"><a href="#HashMap与LinkedHashMap和TreeMap的区别" class="headerlink" title="HashMap与LinkedHashMap和TreeMap的区别"></a>HashMap与LinkedHashMap和TreeMap的区别</h3>]]></content>
      <categories>
        <category>JAVA源码</category>
      </categories>
      <tags>
        <tag>JAVA源码</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA泛型</title>
    <url>/2020/05/12/JAVA%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍 <a href="http://lib.csdn.net/base/java">Java</a>中的泛型</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>\1. <a href="http://lib.csdn.net/base/java">Java</a>中的泛型是什么 ? 使用泛型的好处是什么?</p>
<p>这是在各种Java泛型<a href="http://yjbys.com/mianshi/">面试</a>中，一开场你就会被问到的问题中的一个，主要集中在初级和中级面试中。那些拥有Java1.4或更早版本的开发背景的人 都知道，在集合中存储对象并在使用前进行类型转换是多么的不方便。泛型防止了那种情况的发生。它提供了编译期的类型安全，确保你只能把正确类型的对象放入 集合中，避免了在运行时出现ClassCastException。</p>
<p>\2. Java的泛型是如何工作的 ? 什么是类型擦除 ?</p>
<p>这是一道更好的泛型面试题。泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。例如 List<String>在运行时仅用一个List来表示。这样做的目的，是确保能和<a href="http://lib.csdn.net/base/java">Java </a>5之前的版本开发二进制类库进行兼容。你无法在运行时访问到类型参数，因为编译器已经把泛型类型转换成了原始类型。根据你对这个泛型问题的回答情况，你会 得到一些后续提问，比如为什么泛型是由类型擦除来实现的或者给你展示一些会导致编译器出错的错误泛型代码。请阅读我的Java中泛型是如何工作的来了解更 多信息。</p>
<p>\3. 什么是泛型中的限定通配符和非限定通配符 ?</p>
<p>这是另一个非常流行的Java泛型面试题。限定通配符对类型进行了限制。有两种限定通配符，一种是<? extends T>它通过确保类型必须是T的子类来设定类型的上界，另一种是<? super T>它通过确保类型必须是T的父类来设定类型的下界。泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。另一方面<?>表 示了非限定通配符，因为&lt;?&gt;可以用任意类型来替代。更多信息请参阅我的文章泛型中限定通配符和非限定通配符之间的区别。</p>
<p>\4. List&lt;? extends T&gt;和List &lt;? super T&gt;之间有什么区别 ?</p>
<p>这和上一个面试题有联系，有时面试官会用这个问题来评估你对泛型的理解，而不是直接问你什么是限定通配符和非限定通配符。这两个List的声明都是 限定通配符的例子，List&lt;? extends T&gt;可以接受任何继承自T的类型的List，而List&lt;? super T&gt;可以接受任何T的父类构成的List。例如List&lt;? extends Number&gt;可以接受List<Integer>或List<Float>。在本段出现的连接中可以找到更多信息。</p>
<p>\5. 如何编写一个泛型方法，让它能接受泛型参数并返回泛型类型?</p>
<p>编写泛型方法并不困难，你需要用泛型类型来替代原始类型，比如使用T, E or K,V等被广泛认可的类型占位符。泛型方法的例子请参阅Java集合类框架。最简单的情况下，一个泛型方法可能会像这样:</p>
<p>public V put(K key, V value) {</p>
<p>return cache.put(key, value);</p>
<p>}</p>
<p>\6. Java中如何使用泛型编写带有参数的类?</p>
<p>这是上一道面试题的延伸。面试官可能会要求你用泛型编写一个类型安全的类，而不是编写一个泛型方法。关键仍然是使用泛型类型来代替原始类型，而且要使用JDK中采用的标准占位符。</p>
<p>\7. 编写一段泛型程序来实现LRU缓存?</p>
<p>对于喜欢Java编程的人来说这相当于是一次练习。给你个提示，LinkedHashMap可以用来实现固定大小的LRU缓存，当LRU缓存已经满 了的时候，它会把最老的键值对移出缓存。LinkedHashMap提供了一个称为removeEldestEntry()的方法，该方法会被put() 和putAll()调用来删除最老的键值对。当然，如果你已经编写了一个可运行的JUnit<a href="http://lib.csdn.net/base/softwaretest">测试</a>，你也可以随意编写你自己的实现代码。</p>
<p>\8. 你可以把List<String>传递给一个接受List<Object>参数的方法吗？</p>
<p>对任何一个不太熟悉泛型的人来说，这个Java泛型题目看起来令人疑惑，因为乍看起来String是一种Object，所以 List<String>应当可以用在需要List<Object>的地方，但是事实并非如此。真这样做的话会导致编译错误。如 果你再深一步考虑，你会发现Java这样做是有意义的，因为List<Object>可以存储任何类型的对象包括String, Integer等等，而List<String>却只能用来存储Strings。</p>
<p>List<Object> objectList;</p>
<p>List<String> stringList;</p>
<p>objectList = stringList; //compilation error incompatible types</p>
<p>\9. Array中可以用泛型吗?</p>
<p>这可能是Java泛型面试题中最简单的一个了，当然前提是你要知道Array事实上并不支持泛型，这也是为什么Joshua Bloch在Effective Java一书中建议使用List来代替Array，因为List可以提供编译期的类型安全保证，而Array却不能。</p>
<p>\10. 如何阻止Java中的类型未检查的警告?</p>
<p>如果你把泛型和原始类型混合起来使用，例如下列代码，<a href="http://lib.csdn.net/base/java">java </a>5的javac编译器会产生类型未检查的警告，例如</p>
<p>List<String> rawList = new ArrayList()</p>
<p>注意: Hello.java使用了未检查或称为不安全的操作;</p>
<p>这种警告可以使用@SuppressWarnings(“unchecked”)注解来屏蔽。</p>
<p>Java泛型面试题补充更新:</p>
<p>我手头又拿到了几个Java泛型面试题跟大家分享下，这几道题集中在泛型类型和原始类型的区别上，以及我们是否可以用Object来代替限定通配符的使用等等：</p>
<p>Java中List<Object>和原始类型List之间的区别?</p>
<p>原始类型和带参数类型<Object>之间的主要区别是，在编译时编译器不会对原始类型进行类型安全检查，却会对带参数的类型进行检 查，通过使用Object作为类型，可以告知编译器该方法可以接受任何类型的对象，比如String或Integer。这道题的考察点在于对泛型中原始类 型的正确理解。它们之间的第二点区别是，你可以把任何带参数的类型传递给原始类型List，但却不能把List<String>传递给接受 List<Object>的方法，因为会产生编译错误。更多详细信息请参阅Java中的泛型是如何工作的。</p>
<p>Java中List&lt;?&gt;和List<Object>之间的区别是什么?</p>
<p>这道题跟上一道题看起来很像，实质上却完全不同。List<?> 是一个未知类型的List，而List<Object> 其实是任意类型的List。你可以把List<String>, List<Integer>赋值给List<?>，却不能把List<String>赋值给 List<Object>。   </p>
<p>List&lt;?&gt; listOfAnyType;</p>
<p>List<Object> listOfObject = new ArrayList<Object>();</p>
<p>List<String> listOfString = new ArrayList<String>();</p>
<p>List<Integer> listOfInteger = new ArrayList<Integer>();</p>
<p>listOfAnyType = listOfString; //legal</p>
<p>listOfAnyType = listOfInteger; //legal</p>
<p>listOfObjectType = (List<Object>) listOfString; //compiler error – in-convertible types</p>
<p>想了解更多关于通配符的信息请查看Java中的泛型通配符示例</p>
<p>List<String>和原始类型List之间的区别.</p>
<p>该题类似于“原始类型和带参数类型之间有什么区别”。带参数类型是类型安全的，而且其类型安全是由编译器保证的，但原始类型List却不是类型安全 的。你不能把String之外的任何其它类型的Object存入String类型的List中，而你可以把任何类型的对象存入原始List中。使用泛型的 带参数类型你不需要进行类型转换，但是对于原始类型，你则需要进行显式的类型转换。</p>
<p>List listOfRawTypes = new ArrayList();</p>
<p>listOfRawTypes.add(“abc”);</p>
<p>listOfRawTypes.add(123); //编译器允许这样 – 运行时却会出现异常</p>
<p>String item = (String) listOfRawTypes.get(0); //需要显式的类型转换</p>
<p>item = (String) listOfRawTypes.get(1); //抛ClassCastException，因为Integer不能被转换为String</p>
<p>List<String> listOfString = new ArrayList();</p>
<p>listOfString.add(“abcd”);</p>
<p>listOfString.add(1234); //编译错误，比在运行时抛异常要好</p>
<p>item = listOfString.get(0); //不需要显式的类型转换 – 编译器自动转换</p>
<p>这些都是Java泛型面试中 频繁出现的问题及其答案。所有这些面试题都不困难，其实它们都是基于泛型的基础知识。任何对泛型有不错了解的Java程序员都肯定熟知这些泛型题目。如果 你有任何好的面试题，不管是在什么面试中碰到的，或者如果你想知道任何Java泛型面试题的答案。</p>
]]></content>
      <categories>
        <category>JAVASE</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA程序的编译和运行过程</title>
    <url>/2020/06/02/JAVA%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>JAVA程序的编译和运行过程：<br>JAVA程序代码经过编译之后转换为一种称为JAVA字节码的中间语言，JAVA虚拟机(JVM）将对字节码进行解释和运行。编译只进行一次，而解释在每次运行程序时都会运行，编译的字节码采用一种针对JVM优化过度机器码的形式进行保存。虚拟机将字节码解释为机器码，然后在计算机上运行。<br>JAVA语言程序代码的编译和运行过程如图：<br><img src="https://photos.alitaalice.cn/image/20200602091745.png" alt=""></p>
]]></content>
      <categories>
        <category>JAVASE</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA编译和运行的过程</title>
    <url>/2020/05/11/JAVA%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍JAVA编译和运行的过程</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><ul>
<li><p>JAVA程序源码 </p>
</li>
<li><p>——-&gt; JAVA字节码（经过编译器编译)</p>
</li>
<li><p>——-&gt;JVM （对字节码进行解释和运行）</p>
<p>编译只进行一次，但是解释在每次运行程序时都会运行，编译的字节码采用一种针对JVM优化过度机器码的形式进行保存</p>
</li>
<li><p>——&gt;机器码（虚拟机将字节码解释为机器码，在计算机上运行）</p>
<p><img src="Screenshot.png" alt=""></p>
</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA面试</title>
    <url>/2020/05/11/JAVA%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><img src="E:%5Cdev%5CMYBLOG%5Cblog%5Csource_posts%5CJAVA%E9%9D%A2%E8%AF%95%5C2020-05-11_205422.png" alt=""></p>
]]></content>
  </entry>
  <entry>
    <title>JDK7和JDK8的区别</title>
    <url>/2020/05/29/JDK7%E5%92%8CJDK8%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍JDK7和JDK8的区别</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="JDK-7"><a href="#JDK-7" class="headerlink" title="JDK 7"></a><strong>JDK 7</strong></h2><ol>
<li>对集合类的语言支持；</li>
<li>try-with-resources 语句</li>
<li>使用文件 Path</li>
<li>改进的通用实例创建类型推断；(？？)</li>
<li>数字字面量下划线支持；（√）</li>
<li>switch中使用string；（√）</li>
<li>二进制字面量；（√）</li>
<li>简化可变参数方法调用。</li>
<li>map集合支持并发请求 ，且可以写成 Map map = {name:”xxx”,age:18};</li>
<li>Boolean类型反转，空指针安全,参与位运算；</li>
<li>新增一些取环境信息的工具方法；</li>
</ol>
<h2 id="JDK-8"><a href="#JDK-8" class="headerlink" title="JDK 8"></a>JDK 8</h2><p>1、<strong>接口可以添加默认方法，default;</strong><br>2、<strong>lambda表达式，对于接口可以直接用()-&gt;{}方式来表达，小括号表示方法入参，花括号内表示方法返回值，如Collections的sort()方法</strong>：<br>3、<strong>函数式接口</strong><br>4、新的日期和时间API<br>5、并发增强<br>6、支持多重注解<br>7、<strong>特性四、反射的加强 。JDK8加强了反射，它允许你直接通过反射获取参数的名字</strong><br>8、 <strong>Stream API</strong> </p>
<p>Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。</p>
<p>Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。</p>
<p>Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。 9、  JavaScript引擎Nashorn<br>10、Java虚拟机（JVM）的新特性<br>PermGen空间被移除了，取而代之的是Metaspace（JEP 122）。JVM选项-XX:PermSize与-XX:MaxPermSize分别被-XX:MetaSpaceSize与-XX:MaxMetaspaceSize所代替。</p>
]]></content>
      <categories>
        <category>JAVASE</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK中常用的包有哪些？</title>
    <url>/2020/05/11/JDK%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8C%85%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍JDK中常用的包</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>JDK中常用的包有哪些？</p>
<ul>
<li>JAVA.lang  java语言的核心类，如String,Math,Interger,System,和Thread</li>
<li>java.io 提供多种输入/输出功能的类</li>
<li>java.net 包括执行与网络相关的操作的类</li>
<li>java.util 包括一些实用的工具类，如定义系统的特性，与日期日历相关的方法</li>
<li>java.awt 抽象窗口工具集，用来构建和管理应用程序的GUI</li>
<li>java.applet 包含applet运行所需的类</li>
<li>java.swing 用来建立图形用户界面</li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK和JRE</title>
    <url>/2020/05/09/JDK%E5%92%8CJRE/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍JDK和JRE的区别，他们的作用分别是什么？</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h2><p>JDK是JAVA Development Kit (JAVA开发套件) ，是JAVA的开发工具包。主要包含了类库和工具。</p>
<p>JDK中包含了JRE 而且在JDK安装目录/JRE/bin/server 文件夹下包含jvm.dll</p>
<p><img src="QQ20200509115538.png" alt=""></p>
<p>这说明JDK提供了一个虚拟机。</p>
<p>另外JDK的bin目录下有各种JAVA程序需要用到的命令。</p>
<p>与JRE明显的区别就是JDK文件下才会有javac</p>
<p><img src="QQ20200509115836.png" alt=""></p>
<p>因为JRE只是一个运行环境，与开发无关。</p>
<h2 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h2><p>JRE是JAVA Runtime Environment的缩写。是JAVA程序的运行环境。既然是运行，那么当然要包含JVM,也就是JAVA虚拟机，还有所有JAVA类库的class文件，都在lib下，并且被打包成了jar </p>
<p><img src="Screenshot.png" alt=""></p>
<h2 id="问题：jdk里的jre与外面jre的区别"><a href="#问题：jdk里的jre与外面jre的区别" class="headerlink" title="问题：jdk里的jre与外面jre的区别"></a>问题：jdk里的jre与外面jre的区别</h2><p>分析：如果我们安装了JDK，那么我们的电脑中将会有C:\Program Files (x86)\Java\jdk1.8.0_05文件夹 ，这个文件夹里面有一个jre文件夹。然后我们再安装jre，此时我们的电脑中有C:\Program Files (x86)\Java\jre8文件夹。</p>
<p>通过对比jre和jre8文件夹中的东西，我们发现基本是一样的，那么这俩文件夹到底有啥区别呢？</p>
<p>我们暂且称jre为自带jdk-jre，jre8为公共jre。</p>
<p>jdk-jre与公共jre的主要区别在于jdk-jre多了一个server的vm执行选项。</p>
<p>sever与client使用不同的vm虚拟机。如果电脑运行一个java程序的时候，会自动调用client vm。但是如果开发java程序时使用的就是server vm（server vm启动时间较长，占用内存较多，但是启动后执行性能更高，适合开发）。</p>
<p><strong>换句话说：公共jre是给普通电脑用户使用的，假如你安装了一个java程序，这个java程序启动运行的时候就会调用jre（java runtime environment）；如果你是一个java开发者，那么你就需要安装jdk（java development kit），这时你开发调试java程序的时候就会调用jdk里面的jre。</strong></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC</title>
    <url>/2020/09/06/JUC/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍JUC</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h1 id="1-线程和进程的区别"><a href="#1-线程和进程的区别" class="headerlink" title="1 线程和进程的区别"></a>1 线程和进程的区别</h1>]]></content>
      <categories>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM初探</title>
    <url>/2020/09/01/JVM%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><img src="https://photos.alitaalice.cn/image/20200901225519.png" alt=""></p>
<ul>
<li><img src="https://photos.alitaalice.cn/image/20200901225829.png" alt=""></li>
</ul>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><img src="https://photos.alitaalice.cn/image/20200901230041.png" alt=""></p>
<p> 1</p>
<p><img src="https://photos.alitaalice.cn/image/20200902090342.png" alt=""></p>
<h1 id="2-JVM模型"><a href="#2-JVM模型" class="headerlink" title="2  JVM模型"></a>2  JVM模型<img src="https://photos.alitaalice.cn/image/20200902090937.png" alt=""></h1><p><img src="https://photos.alitaalice.cn/image/20200902091021.png" alt=""></p>
<h1 id="3-类加载器："><a href="#3-类加载器：" class="headerlink" title="3.类加载器："></a>3.类加载器：</h1><h2 id="如何new一个文件？"><a href="#如何new一个文件？" class="headerlink" title="如何new一个文件？"></a>如何new一个文件？</h2><p>加载Class文件  经过class loader 创建class模板 根据class模板再去统一创建实例对象</p>
<p><img src="https://photos.alitaalice.cn/image/20200902092146.png" alt=""></p>
<h1 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h1><p>1 应用程序加载器   AppClassLoader</p>
<p>2 扩展类加载器   ExtClassLoader</p>
<p>3 启动类（根）加载器  Root</p>
<p>4 虚拟机自带的加载器</p>
<p>5 类加载器的双亲委派机制</p>
<p><img src="https://photos.alitaalice.cn/image/20200902093939.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200902094216.png" alt=""></p>
<ol start="5">
<li><h1 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h1></li>
</ol>
<p><img src="https://photos.alitaalice.cn/image/20200902095820.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200902095925.png" alt=""></p>
<ol start="6">
<li><h1 id="Native关键字"><a href="#Native关键字" class="headerlink" title="Native关键字"></a>Native关键字</h1><p><img src="https://photos.alitaalice.cn/image/20200902100616.png" alt=""></p>
</li>
</ol>
<p>7 <img src="https://photos.alitaalice.cn/image/20200902101021.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200902102517.png" alt=""></p>
<p>String类型的赋值放在常量池中</p>
<p>String.intern()</p>
<p>尽管在输出中调用intern方法并没有什么效果，但是实际上后台这个方法会做一系列的动作和操作。在调用”ab”.intern()方法的时候会返回”ab”，但是这个方法会首先检查字符串池中是否有”ab”这个字符串，如果存在则返回这个字符串的引用，否则就将这个字符串添加到字符串池中，然会返回这个字符串的引用。</p>
<p>9 <img src="https://photos.alitaalice.cn/image/20200902104147.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200902104531.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200902105001.png" alt=""></p>
<h3 id="New对象"><a href="#New对象" class="headerlink" title="New对象"></a>New对象</h3><p><img src="https://photos.alitaalice.cn/image/20200902222748.png" alt=""></p>
<h2 id="3种JVM"><a href="#3种JVM" class="headerlink" title="3种JVM"></a>3种JVM</h2><p>栈是线程级别的</p>
<p><img src="https://photos.alitaalice.cn/image/20200902223356.png" alt=""></p>
<h1 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h1><p><img src="https://photos.alitaalice.cn/image/20200903095800.png" alt=""></p>
<p>在JAVA1.8中永久存储区上升到元空间</p>
<p><strong>常量(字符串常量和基本类型常量)通常直接存储在程序代码内部（常量池）</strong></p>
<p><img src="https://photos.alitaalice.cn/image/20200903100927.png" alt=""></p>
<p>GC垃圾回收，主要在伊甸园区和养老区</p>
<p>假设内存满了，OOM，堆内存不够</p>
<p><img src="https://photos.alitaalice.cn/image/20200903100824.png" alt=""></p>
<h1 id="新生区"><a href="#新生区" class="headerlink" title="新生区"></a>新生区</h1><p><img src="https://photos.alitaalice.cn/image/20200903150323.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200903151013.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200903151401.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200903151701.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200903155605.png" alt=""></p>
<h4 id="元空间-逻辑上存在，物理上不存在"><a href="#元空间-逻辑上存在，物理上不存在" class="headerlink" title="元空间 逻辑上存在，物理上不存在"></a>元空间 逻辑上存在，物理上不存在</h4><p><img src="https://photos.alitaalice.cn/image/20200903160153.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200903160434.png" alt=""></p>
<p>StackOverflowError异常  递归调用函数， 线程栈溢出：通过大量的递归调用来消耗线程栈内存。</p>
<h1 id="JVM参数"><a href="#JVM参数" class="headerlink" title="JVM参数"></a>JVM参数</h1><p>1 Xms JVM初始大小   Xmx 总大小</p>
<p>产生Dump文件 </p>
<ul>
<li>VM options -Xms1m -Xmx8m -XX: +HeapDumpOutOfMemoryError</li>
</ul>
<p>后在代码目录下找到Dump文件，使用Jprofiler来分析，快速定位内存泄漏</p>
<h1 id="GC：垃圾回收"><a href="#GC：垃圾回收" class="headerlink" title="GC：垃圾回收"></a>GC：垃圾回收</h1><p><img src="https://photos.alitaalice.cn/image/20200906133926.png" alt=""></p>
<p>yin</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM内存模型概述</title>
    <url>/2020/05/20/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍JVM内存模型概述</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>转<a href="https://blog.csdn.net/justloveyou_/article/details/71189093">https://blog.csdn.net/justloveyou_/article/details/71189093</a></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8函数式接口与lambda表达式</title>
    <url>/2020/05/28/Java8%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E4%B8%8ELambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍lambda</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>转自<a href="https://blog.csdn.net/justloveyou_/article/details/89066782">https://blog.csdn.net/justloveyou_/article/details/89066782</a></p>
<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>lambda表达式采用一种简洁的语法来定义代码块。lambda表达式是一个可传递的代码块，可以在以后执行一次或者多次。</p>
<p>eg:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LengthComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String first,String second)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> first.length()-senond.length;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">Arrays.sort(strings,<span class="keyword">new</span> LenthComparator());</span><br><span class="line">在JAVA中传递一个代码段并不容易，你不能直接传递代码段，JAVA是一种面向对象的语言，所以必须构造一个对象，这个对象的类需要有一个方法来包含所必须的代码段。</span><br></pre></td></tr></table></figure>

<h2 id="lambda表达式的语法"><a href="#lambda表达式的语法" class="headerlink" title="lambda表达式的语法"></a>lambda表达式的语法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(String first,String second)</span><br><span class="line">-&gt;first.length()-second.length()</span><br><span class="line">这是一个lambda表达式，lambda表达式是一个代码块，以及必须传入代码的变量规范，</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(String first,String second)-&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(first.length() &lt;second.length() <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(first.length() &gt;second.length() <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">以上包含显式的<span class="keyword">return</span> 语句</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">即使lambda表达式没有参数，仍然要提供空括号</span><br><span class="line">()-&gt;&#123;<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">100</span>;i&gt;=<span class="number">0</span>;i--) System.out.println(i);&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">如果可以推导出一个lambda表达式的参数类型，则可以忽略其类型。</span><br><span class="line">Comparator&lt;String&gt; compatator=(first,second) -&gt;first.length()-second.length();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">如果方法只有一个参数，并且这个参数的类型可以推导得出，那么甚至可以省略括号</span><br><span class="line">ActionListener listener =event -&gt;System.out.println(<span class="string">"this time is"</span> +Instant.ofEpochMilli(event.getWhen()));</span><br><span class="line"><span class="function">instead <span class="title">of</span> <span class="params">(event)</span>-&gt;...<span class="title">or</span><span class="params">(ActionEvent event)</span>-&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JAVASE</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>Java修饰符：public，protected，private，不加修饰符。有什么区别呢？</title>
    <url>/2020/05/28/Java%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9Apublic%EF%BC%8Cprotected%EF%BC%8Cprivate%EF%BC%8C%E4%B8%8D%E5%8A%A0%E4%BF%AE%E9%A5%B0%E7%AC%A6%E3%80%82%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%91%A2%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍JAVA修饰符</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><img src="https://photos.alitaalice.cn/image/20200715095509.png" alt=""></p>
]]></content>
      <categories>
        <category>JAVASE</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM详解</title>
    <url>/2020/09/11/JVM%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍JVM</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>JAVA 1.7之前</p>
<p>栈 8大基本类型 对象引用 实例方法</p>
<p>堆  方法 变量 常量  引用类型的真实对象</p>
<p>方法区  类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。方法区是堆的一个逻辑部分</p>
<p>永久代  方法区它为“永久代”（Permanent Generation），更确切来说，应该是“HotSpot使用永久代实现了方法区”</p>
<p>元空间 ：<strong>元数据区取代了永久代</strong>，就是JDK8没有了<strong>PermSize</strong>相关的参数配置了。元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：<strong>元数据空间并不在虚拟机中，而是使用本地内存</strong>。</p>
<h3 id="二、JVM运行时数据区域"><a href="#二、JVM运行时数据区域" class="headerlink" title="二、JVM运行时数据区域"></a>二、JVM运行时数据区域</h3><p>根据《Java虚拟机规范（Java SE 7版）》的规定，Java虚拟机所管理的内存将会包括以下几个运行时的数据区域：程序计数器(Program Counter Register)、Java栈(VM Stack)、本地方法栈(Native Method Stack)、方法区(Method Area)、堆(Heap)。</p>
<p>如图所示:</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2R1Znl1bi5naXRlZS5pby9pbWFnZXNfYmVkL2ltYWdlcy90ZWNoeS9KVk0wMy0wMS5wbmc" alt="运行时数据区"></p>
<p><strong>注：上图的虚拟机运行时数据区是Java虚拟机规范所规定的区域，不同的虚拟机有不同的实现。</strong></p>
<p>上面图片有线程共享和线程隔离的区域，下面在通过一张图片来进行简单说明，让你更加清晰的理解什么是线程共享和什么是线程隔离。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2R1Znl1bi5naXRlZS5pby9pbWFnZXNfYmVkL2ltYWdlcy90ZWNoeS9KVk0wMy0wMi5wbmc" alt="线程共享和线程隔离区域"></p>
<p>通过上面的两个图，大概对JVM的内存模型有个初步的认识，下面我们在看一下具体的每一个区域到底是什么东东。</p>
<h4 id="1、程序计数器"><a href="#1、程序计数器" class="headerlink" title="1、程序计数器"></a>1、程序计数器</h4><p>程序计数器（Program Counter Register)是一块较小的内存空间，它可以是看作当前线程所执行的字节码的行号指示器。说简单一点就是一个计数器，当字节码解释器工作是能够通过改变这个计数器的值来选取下一条需要执行的字节码指令。在说明一点，各条线程之间计数器互不影响，独立存储，程序计数器器内存区域为 <strong>线程私有</strong> 的。</p>
<p>类比汇编语言中的程序计数器：在汇编语言中，程序计数器是指CPU中的寄存器，它保存的是程序当前执行的指令的地址（也可以说保存下一条指令的所在存储单元的地址），当CPU需要执行指令时，需要从程序计数器中得到当前需要执行的指令所在存储单元的地址，然后根据得到的地址获取到指令，在得到指令之后，程序计数器便自动加1或者根据转移指针得到下一条指令的地址，如此循环，直至执行完所有的指令。</p>
<p>在JVM规范中规定，如果线程执行的是非native方法，则程序计数器中保存的是当前需要执行的指令的地址；如果线程执行的是native方法，则程序计数器中的值是undefined。由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，因此，此内存区域是唯一一个在JVM规范中没有规定任何OutOfMemoryError情况的区域。</p>
<h4 id="2-本地方法栈"><a href="#2-本地方法栈" class="headerlink" title="2.本地方法栈"></a>2.本地方法栈</h4><p>本地方法栈和虚拟机栈所发挥的作用是很相似的，它们之间的区别不过是 虚拟机栈为虚拟机执行Java方法（字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。Sun HotSpot 直接就把本地方法栈和虚拟机栈合二为一。本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。</p>
<h4 id="3、Java虚拟机栈"><a href="#3、Java虚拟机栈" class="headerlink" title="3、Java虚拟机栈"></a>3、Java虚拟机栈</h4><p>　Java栈也称作虚拟机栈（Java Vitual Machine Stack），也是常说的栈。Java栈是Java方法执行的内存模型。Java栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法，在栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、指向当前方法所属的类的运行时常量池（运行时常量池的概念在方法区部分会谈到）的引用(Reference to runtime constant pool)、方法返回地址(Return Address)和一些额外的附加信息。栈也是<strong>线程私有</strong>的。</p>
<p>下图表示了一个Java栈的模型</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2R1Znl1bi5naXRlZS5pby9pbWFnZXNfYmVkL2ltYWdlcy90ZWNoeS9KVk0wMy0wMy5wbmc" alt="栈示意图1"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2R1Znl1bi5naXRlZS5pby9pbWFnZXNfYmVkL2ltYWdlcy90ZWNoeS9KVk0wMy0wMy0yLnBuZw" alt="栈示意图2"></p>
<p>1）、局部变量表</p>
<p>就是用来存储方法中的局部变量（包括在方法中声明的非静态变量以及函数形参）。对于基本数据类型的变量，则直接存储它的值，对于引用类型的变量，则存的是指向对象的引用。局部变量表的大小在编译器就可以确定其大小了，因此在程序执行期间局部变量表的大小是不会改变的。</p>
<p>2）、操作数栈</p>
<p>想必学过数据结构中的栈的朋友想必对表达式求值问题不会陌生，栈最典型的一个应用就是用来对表达式求值。想想一个线程执行方法的过程中，实际上就是不断执行语句的过程，而<a href="https://www.baidu.com/s?wd=归根到底&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd">归根到底</a>就是进行计算的过程。因此可以这么说，程序中的所有计算过程都是在借助于操作数栈来完成的。</p>
<p>3）、指向运行时常量池的引用</p>
<p>因为在方法执行的过程中有可能需要用到类中的常量，所以必须要有一个引用指向运行时常量。</p>
<p>4）、方法返回地址</p>
<p>当一个方法执行完毕之后，要返回之前调用它的地方，因此在栈帧中必须保存一个方法返回地址。由于每个线程正在执行的方法可能不同，因此每个线程都会有一个自己的Java栈，互不干扰。也就解释了栈是线程私有的。</p>
<p>当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。因此可知，线程当前执行的方法所对应的栈帧必定位于Java栈的顶部。在这个区域规定了两种异常状况：</p>
<ul>
<li>如果线程请求的栈深入大于虚拟机所允许的深度，将抛出StackOverFlowError异常！  </li>
<li>如果虚拟机栈可以动态扩展，当扩展到无法申请内存到足够的内存，就会抛出OutOfMemoryError异常!</li>
</ul>
<h4 id="4、Java堆"><a href="#4、Java堆" class="headerlink" title="4、Java堆"></a>4、Java堆</h4><p><strong>堆是jvm内存管理的最大的一块区域，此内存区域的唯一目的就是存放对象的实例，所有对象实例与数组都要在堆上分配内存。它也是垃圾收集器的主要管理区域</strong>。java对可以处于物理上不连续的空间，只要逻辑上是连续的即可。<strong>线程共享的区域</strong>。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将抛出OutOfMemoryError异常。</p>
<p>为了支持垃圾收集，堆被分为三个部分：</p>
<ul>
<li><strong>年轻代</strong> ： 常常又被划分为Eden区和Survivor（From Survivor To Survivor）区(<strong>Eden空间、From Survivor空间、To Survivor空间（空间分配比例是8：1：1</strong>）</li>
<li><strong>老年代</strong></li>
<li><strong>永久代</strong> （jdk 8已移除永久代，下面会讲解）</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2R1Znl1bi5naXRlZS5pby9pbWFnZXNfYmVkL2ltYWdlcy90ZWNoeS9KVk0wMy0wNC5wbmc" alt="堆内存划分"></p>
<p>1） 堆是JVM中所有线程共享的，因此在其上进行对象内存的分配均需要进行加锁，这也导致了new对象的开销是比较大的（2） Sun Hotspot JVM为了提升对象内存分配的效率，对于所创建的线程都会分配一块独立的空间TLAB（Thread Local Allocation Buffer），其大小由JVM根据运行的情况计算而得，在TLAB上分配对象时不需要加锁，因此JVM在给线程的对象分配内存时会尽量的在TLAB上分配，在这种情况下JVM中分配对象内存的性能和C基本是一样高效的，但如果对象过大的话则仍然是直接使用堆空间分配（3） TLAB仅作用于新生代的Eden Space，因此在编写Java程序时，通常多个小的对象比大的对象分配起来更加高效。</p>
<p>（4） 所有新创建的Object 都将会存储在新生代Yong Generation中。如果Young Generation的数据在一次或多次GC后存活下来，那么将被转移到OldGeneration。新的Object总是创建在Eden Space。</p>
<p>这些知识在后面学习GC和内存调优方面非常重要。</p>
<h4 id="5、方法区"><a href="#5、方法区" class="headerlink" title="5、方法区"></a>5、方法区</h4><p>方法区在JVM中也是一个非常重要的区域，它与堆一样，是被线程共享的区域。在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。方法区是堆的一个逻辑部分，为了区分Java堆，它还有一个别名Non-Heap（非堆）。相对而言，GC对于这个区域的收集是很少出现的。<strong>当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</strong></p>
<p>在Java 7及之前版本，我们也习惯称方法区它为“永久代”（Permanent Generation），更确切来说，应该是“HotSpot使用永久代实现了方法区”！</p>
<h4 id="6、运行时常量池"><a href="#6、运行时常量池" class="headerlink" title="6、运行时常量池"></a>6、运行时常量池</h4><p>运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外,还有一项信息是常量池( Constant pool table)，用于<strong>存放编译期生成的各种字面量和符号引用</strong>，这部分内容将在类加载后进入运行时常量池中存放。运行时常量池相对于class文件常量池的另外一个特性是<strong>具备动态性</strong>，java语言并不要求常量一定只有编译器才产生，也就是并非预置入class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中。</p>
<h4 id="7、直接内存"><a href="#7、直接内存" class="headerlink" title="7、直接内存"></a>7、直接内存</h4><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是JVM规范中定义的内存区域。但这部分内存也被频繁的使用，而且<strong>也可能导致OutOfMemoryError异常出现</strong>。</p>
<p>JDK1.4中新引入了NIO机制，它是一种基于通道与缓冲区的新I/O方式，可以直接从操作系统中分配直接内存，即<strong>直接堆外分配内存</strong>，这样能在一些场景中提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p>
<h3 id="三、JDK7和JDK8的JVM内存模型的总结"><a href="#三、JDK7和JDK8的JVM内存模型的总结" class="headerlink" title="三、JDK7和JDK8的JVM内存模型的总结"></a>三、JDK7和JDK8的JVM内存模型的总结</h3><h4 id="1、方法区变化"><a href="#1、方法区变化" class="headerlink" title="1、方法区变化"></a>1、方法区变化</h4><p>这里介绍的是JDK1.8 JVM内存模型。1.8同1.7比，最大的差别就是：<strong>元数据区取代了永久代</strong>，就是JDK8没有了<strong>PermSize</strong>相关的参数配置了。元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：<strong>元数据空间并不在虚拟机中，而是使用本地内存</strong>。</p>
<p>1）方法区与永久代的区别？</p>
<p>方法区只是JVM规范定义，而永久代为具体的实现，元空间也是方法区在jdk1.8中的一种实现。</p>
<p>2）为什么废除永久代？</p>
<p>1.官方文档：移除永久代是为融合HotSpot JVM与 JRockit VM而做出的努力，因为JRockit没有永久代，不需要配置永久代</p>
<p>2..PermGen很难调整，PermGen中类的元数据信息在每次FullGC的时候可能被收集，但成绩很难令人满意。</p>
<p>而且应该为PermGen分配多大的空间很难确定，因为PermSize的大小依赖于很多因素，比如JVM加载的class总数，常量池的大小，方法的大小等。</p>
<p>并且永久代内存经常不够用发生内存泄露。</p>
<h4 id="2、运行时常量池变化"><a href="#2、运行时常量池变化" class="headerlink" title="2、运行时常量池变化"></a>2、运行时常量池变化</h4><p>在近三个JDK版本（1.6、1.7、1.8）中， 运行时常量池（Runtime Constant Pool）的所处区域一直在不断的变化，在JDK1.6时它是方法区的一部分；1.7又把他放到了堆内存中；1.8之后出现了元空间，它又回到了方法区。其实，这也说明了官方对“永久代”的优化从1.7就已经开始了。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2R1Znl1bi5naXRlZS5pby9pbWFnZXNfYmVkL2ltYWdlcy90ZWNoeS9KVk0wMy0wMy02LnBuZw" alt="各个版本的变化"></p>
<p>贴一张 Java 8 的内存模型图：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2R1Znl1bi5naXRlZS5pby9pbWFnZXNfYmVkL2ltYWdlcy90ZWNoeS9KVk0wMy0wMy01LnBuZw" alt="JVM8内存图"></p>
<h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>运行时区域大概了解后，我们在来总结一下：</p>
<table>
<thead>
<tr>
<th>运行时区域</th>
<th>异常</th>
<th><strong>主要原因</strong></th>
</tr>
</thead>
<tbody><tr>
<td>虚拟机栈和本地方法栈</td>
<td>StackOverflowError、OutOfMemoryError</td>
<td>StackOverflowError：线程请求的栈深度大于虚拟机所允许的最大深度；OutOfMemoryError：虚拟机在扩展栈时无法申请足够的内存空间</td>
</tr>
<tr>
<td>程序计数器</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>堆</td>
<td>OutOfMemoryError</td>
<td>对象数量到达最大堆的容量，内存泄漏、内存溢出</td>
</tr>
<tr>
<td>方法区和运行时常量池</td>
<td>OutOfMemoryError</td>
<td>反射，动态代理：CGLib、JSP、OSGI等</td>
</tr>
</tbody></table>
<p>最后在说两个概念：</p>
<p><strong>内存泄露（Memory Leak）</strong>：程序在申请内存后，对象没有被GC所回收，它始终占用内存，内存泄漏的堆积最终会造成内存溢出。</p>
<p><strong>内存溢出（Memory Overflow）</strong>：程序运行过程中无法申请到足够的内存而导致的一种错误。内存溢出通常发生于OLD段或Perm段垃圾回收后，仍然无内存空间容纳新的Java对象的情况。通常都是由于内存泄露导致堆栈内存不断增大，从而引发内存溢出。</p>
<p>当我们了解了JVM和JVM里面有什么区域，对后面学习和理解JVM的一些规范或者排查JVM相关的问题也更加容易一点，当我们知道了JVM哪些地方报什么样的错误的时候，在出现问题的时候，能够快速的定位和解决，这样对于我们的成长来说帮助也是非常大的，继续学习JVM，深入对JVM的认识，也了解更加有趣的Java世界。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript语法</title>
    <url>/2020/06/13/JavaScript%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍JavaScript语法</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><img src="https://photos.alitaalice.cn/image/20200613082401.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200613082541.png" alt=""></p>
<p> JavaScript 语句和 JavaScript 变量都对大小写敏感。</p>
<p><img src="https://photos.alitaalice.cn/image/20200613083857.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200613085322.png" alt=""></p>
<h3 id="声明对象"><a href="#声明对象" class="headerlink" title="声明对象"></a>声明对象</h3><p><img src="https://photos.alitaalice.cn/image/20200613085835.png" alt=""></p>
<h3 id="js调用带参数的函数"><a href="#js调用带参数的函数" class="headerlink" title="js调用带参数的函数"></a>js调用带参数的函数</h3><p><img src="https://photos.alitaalice.cn/image/20200613090436.png" alt=""></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Java值传递和引用传递基础分析</title>
    <url>/2020/05/11/Java%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E5%9F%BA%E7%A1%80%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍JAVA的值传递和引用传递</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="java内的基础类型数据传递都是值传递-java中实例对象的传递是引用传递。"><a href="#java内的基础类型数据传递都是值传递-java中实例对象的传递是引用传递。" class="headerlink" title="java内的基础类型数据传递都是值传递. java中实例对象的传递是引用传递。"></a>java内的基础类型数据传递都是值传递. java中实例对象的传递是引用传递。</h2><p><strong>值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量。引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。</strong></p>
<p>首先，不要纠结于 Pass By Value 和 Pass By Reference 的字面上的意义，否则很容易陷入所谓的“一切传引用其实本质上是传值”这种并不能解决问题无意义论战中。<br>更何况，要想知道Java到底是传值还是传引用，起码你要先知道传值和传引用的准确含义吧？可是如果你已经知道了这两个名字的准确含义，那么你自己就能判断Java到底是传值还是传引用。</p>
<h2 id="一：搞清楚-基本类型-和-引用类型的不同之处"><a href="#一：搞清楚-基本类型-和-引用类型的不同之处" class="headerlink" title="一：搞清楚 基本类型 和 引用类型的不同之处"></a>一：搞清楚 基本类型 和 引用类型的不同之处</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">String str = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure>

<p><img src="2020-05-12_112353.png" alt=""></p>
<p>如图所示，num是基本类型，值就直接保存在变量中。而str是引用类型，变量中保存的只是实际对象的地址。一般称这种变量为”引用”，引用指向实际对象，实际对象中保存着内容。</p>
<p>二：搞清楚赋值运算符（=）的作用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">num &#x3D; 20;</span><br><span class="line">str &#x3D; &quot;java&quot;;</span><br></pre></td></tr></table></figure>

<p>对于基本类型 num ，赋值运算符会直接改变变量的值，原来的值被覆盖掉。<br>对于引用类型 str，赋值运算符会改变引用中所保存的地址，原来的地址被覆盖掉。但是原来的对象不会被改变（重要）。<br>如上图所示，”hello” 字符串对象没有被改变。（没有被任何引用所指向的对象是垃圾，会被垃圾回收器回收）</p>
<p><img src="2020-05-12_112409.png" alt=""></p>
<h2 id="三：调用方法时发生了什么？参数传递基本上就是赋值操作"><a href="#三：调用方法时发生了什么？参数传递基本上就是赋值操作" class="headerlink" title="三：调用方法时发生了什么？参数传递基本上就是赋值操作"></a>三：调用方法时发生了什么？参数传递基本上就是赋值操作</h2><p>第一个例子：基本类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    value = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">foo(num); <span class="comment">// num 没有被改变</span></span><br></pre></td></tr></table></figure>

<p>第二个例子：没有提供改变自身方法的引用类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">    text = <span class="string">"windows"</span>;  <span class="comment">//String没改变是因为赋值新的字符串直接导致新new了一个String</span></span><br><span class="line">&#125;</span><br><span class="line">foo(str); <span class="comment">// str 也没有被改变</span></span><br></pre></td></tr></table></figure>

<p>第三个例子：提供改变自身方法的引用类型</p>
<p>builder的引用对象也是StringBuilder</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"iphone"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(StringBuilder builder)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    builder.append(<span class="string">"4"</span>); <span class="comment">//没有生成新的stringBuilder对象</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">foo(sb); <span class="comment">// sb 被改变了，变成了"iphone4"。</span></span><br></pre></td></tr></table></figure>

<p>第四个例子：提供了改变自身方法的引用类型，但是不使用，而是使用赋值运算符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"iphone"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(StringBuilder builder)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    builder = <span class="keyword">new</span> StringBuilder(<span class="string">"ipad"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(sb); <span class="comment">// sb 没有被改变，还是 "iphone"。</span></span><br></pre></td></tr></table></figure>

<p>重点理解为什么，第三个例子和第四个例子结果不同？</p>
<p>下面是第三个例子的图解：</p>
<p><img src="2020-05-12_112424.png" alt=""></p>
<p>builder = new StringBuilder(“ipad”); 之后</p>
<p><img src="2020-05-12_112435.png" alt=""></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>LR分析法</title>
    <url>/2020/08/23/LR%E5%88%86%E6%9E%90%E6%B3%95/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍LR分析法</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><img src="https://photos.alitaalice.cn/image/20200824110156.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200824112132.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200824112300.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200824113538.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200824113825.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200824114100.png" alt=""></p>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>List接口</title>
    <url>/2020/05/07/List%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>List集合包括List接口和List接口所有的实现类</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="List接口定义的方法"><a href="#List接口定义的方法" class="headerlink" title="List接口定义的方法"></a>List接口定义的方法</h2><p>除了继承Collection外，List接口还有俩个重要的方法。</p>
<table>
<thead>
<tr>
<th>get(int index)</th>
<th>获得指定索引位置的元素</th>
</tr>
</thead>
<tbody><tr>
<td>set(int index,Object obj)</td>
<td>将集合中指定索引位置的对象修改为指定的对象</td>
</tr>
</tbody></table>
<h2 id="List接口的实现类"><a href="#List接口的实现类" class="headerlink" title="List接口的实现类"></a>List接口的实现类</h2><ul>
<li><p>ArrayList</p>
<p>实现了可变的数组，允许保存所有元素包括null .并且可以根据索引的位置对集合进行快速的随机访问，缺点是向指向的索引位置插入对象或删除对象时的速度较慢</p>
</li>
<li><p>LinkedList </p>
<p>采用链表的结构保存对象。优点是便于向集合中插入和删除对象</p>
<p>分别用ArrayList 和LinkedList来实例化集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;E&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;E&gt; list=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>E是合法的JAVA数据类型，也可以是字符串String</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JAVA集合</category>
      </categories>
      <tags>
        <tag>JAVA集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql自定义函数</title>
    <url>/2020/05/18/Mysql%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍Mysql自定义函数</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>创建函数语法：<br>CREATE FUNCTION fn_name(func_parameter[,…])<br>RETURNS type<br>[characteristic…]<br>routine_body</p>
<p>eg:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#创建一个函数</span><br><span class="line">DELIMITER $$ -- 定界符</span><br><span class="line">-- 开始创建函数</span><br><span class="line"><span class="function">CREATE FUNCTION <span class="title">user_main_fn</span><span class="params">(v_id INT)</span></span></span><br><span class="line"><span class="function">RETURNS <span class="title">VARCHAR</span><span class="params">(<span class="number">50</span>)</span></span></span><br><span class="line"><span class="function">BEGIN</span></span><br><span class="line"><span class="function">  -- 定义变量</span></span><br><span class="line"><span class="function">  DECLARE v_userName <span class="title">VARCHAR</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line">  -- 给定义的变量赋值</span><br><span class="line">  SELECT f_userName INTO v_userName FROM t_user_main </span><br><span class="line">  WHERE f_userId = v_id;</span><br><span class="line">  -- 返回函数处理结果</span><br><span class="line">  RETURN v_userName;</span><br><span class="line">END $$ -- 函数创建定界符</span><br><span class="line">DELIMITER;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#创建第二个函数，使用第一个函数</span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="function">CREATE FUNCTION <span class="title">user_main_fn2</span><span class="params">(v_id INT)</span></span></span><br><span class="line"><span class="function">RETURNS <span class="title">VARCHAR</span><span class="params">(<span class="number">100</span>)</span></span></span><br><span class="line"><span class="function">BEGIN </span></span><br><span class="line"><span class="function">  #定义变量</span></span><br><span class="line"><span class="function">  DECLARE v_userName <span class="title">VARCHAR</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line">  <span class="function">DECLARE  v_userNameNew <span class="title">VARCHAR</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line">  #通过into赋值</span><br><span class="line">  SELECT f_userName INTO v_userName FROM t_user_main WHERE f_userId = v_id;</span><br><span class="line">  #使用函数</span><br><span class="line">  <span class="function">SELECT <span class="title">user_main_fn</span><span class="params">(v_id)</span> INTO v_userNameNew FROM DUAL</span>;</span><br><span class="line">  #返回函数处理结果</span><br><span class="line">  <span class="function">RETURN <span class="title">CONCAT</span><span class="params">(v_userName,<span class="string">'***'</span>,v_userNameNew)</span></span>;</span><br><span class="line">END $$</span><br><span class="line">DELIMITER;</span><br></pre></td></tr></table></figure>

<p>DUAL 虚拟表</p>
<h3 id="查看函数状态语法："><a href="#查看函数状态语法：" class="headerlink" title="查看函数状态语法："></a>查看函数状态语法：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SHOW FUNCTION STATUS [LIKE <span class="string">'pattern'</span>]</span><br></pre></td></tr></table></figure>



<h4 id="查看函数的定义语法："><a href="#查看函数的定义语法：" class="headerlink" title="查看函数的定义语法："></a>查看函数的定义语法：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SHOW CREATE FUNCTION fn_name;</span><br></pre></td></tr></table></figure>

<p>eg:  输出第n高的工资</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">CREATE FUNCTION <span class="title">getNthHighestSalary</span><span class="params">(N INT)</span> RETURNS INT</span></span><br><span class="line"><span class="function">BEGIN</span></span><br><span class="line"><span class="function">  SET N</span>=N-<span class="number">1</span>;</span><br><span class="line">  RETURN (</span><br><span class="line">      # Write your MySQL query statement below.</span><br><span class="line">      SELECT  DISTINCT Salary  FROM Employee ORDER BY Salary DESC  limit N,<span class="number">1</span></span><br><span class="line">  );</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Nosql</title>
    <url>/2020/08/15/Nosql/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><blockquote>
<p>NOSQL 的特点    </p>
</blockquote>
<p>1 方便扩展（数据之间没有关系，很好扩展）</p>
<p>2 大数据量高性能(Redis 读11W 写 8W  ，Nosql的缓存记录及，是一种细粒度的缓存，性能比较高)</p>
<p>3 数据类型是多样型的（不需要事先设计数据库！随取随用，如果是数据量十分大的表，很多人无法设计了）</p>
<p><img src="https://photos.alitaalice.cn/image/20200815100825.png" alt=""></p>
<p>4 传统RDBMS和NOSQL的区别</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">传统的RDBMS</span><br><span class="line">-结构化组织</span><br><span class="line">sql</span><br><span class="line">数据和关系存在单独的表中 row column</span><br><span class="line">操作操作，数据定义语言 </span><br><span class="line">严格的一致性</span><br><span class="line">基础的事务</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nosql</span><br><span class="line">-不仅仅是数据</span><br><span class="line">-没有固定的查询语言</span><br><span class="line">-键值对存储，列存储，文档存储，图形数据库</span><br><span class="line">-最终一致性</span><br><span class="line">-CAP定理 和BASE（异地多活） </span><br><span class="line">-高性能高可用高可扩</span><br></pre></td></tr></table></figure>



<blockquote>
<p>了解：3V+3高</p>
</blockquote>
<p><img src="https://photos.alitaalice.cn/image/20200815101725.png" alt=""></p>
<p>真正在公司中的实践：NOSQL+RDBMS</p>
<h2 id="阿里巴巴演进分析"><a href="#阿里巴巴演进分析" class="headerlink" title="阿里巴巴演进分析"></a>阿里巴巴演进分析</h2><p><img src="https://photos.alitaalice.cn/image/20200815103607.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200815103826.png" alt=""> </p>
<h3 id="NOSqL的四大分类"><a href="#NOSqL的四大分类" class="headerlink" title="NOSqL的四大分类"></a>NOSqL的四大分类</h3><p><img src="https://photos.alitaalice.cn/image/20200815105535.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200815105609.png" alt=""></p>
<p>他不是存储图形的，放的是关系，比如朋友圈社交网络，广告推荐0</p>
<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p><img src="https://photos.alitaalice.cn/image/20200815105745.png" alt=""> </p>
<h3 id="Redis入门"><a href="#Redis入门" class="headerlink" title="Redis入门"></a>Redis入门</h3><blockquote>
<p>redis是什么？</p>
</blockquote>
<p>Remote Dictionary Server 远程字典服务  </p>
<p>key-value数据库 </p>
<p>并提供多种语言的API</p>
<p>最热门的NOSQL技术之一  也被人们称为结构化数据库</p>
<p><img src="https://photos.alitaalice.cn/image/20200815160754.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200815160856.png" alt=""></p>
<h3 id="windows安装"><a href="#windows安装" class="headerlink" title="windows安装"></a>windows安装</h3><p><img src="https://photos.alitaalice.cn/image/20200815162024.png" alt=""></p>
<p>推荐使用linux学习</p>
<h3 id="linux安装"><a href="#linux安装" class="headerlink" title="linux安装"></a>linux安装</h3>]]></content>
  </entry>
  <entry>
    <title>OSI参考模型</title>
    <url>/2020/08/20/OSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍OSI参考模型</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><img src="https://photos.alitaalice.cn/image/20200820102841.png" alt=""></p>
<h1 id="OSI-7层网络架构"><a href="#OSI-7层网络架构" class="headerlink" title="OSI 7层网络架构"></a>OSI 7层网络架构</h1><h1 id="应用层——所有能产生网络流量的程序"><a href="#应用层——所有能产生网络流量的程序" class="headerlink" title="应用层——所有能产生网络流量的程序"></a>应用层——所有能产生网络流量的程序</h1><h1 id="表示层——在传输之前是否进行加密-或-压缩-处理，二进制或ASCII码表示"><a href="#表示层——在传输之前是否进行加密-或-压缩-处理，二进制或ASCII码表示" class="headerlink" title="表示层——在传输之前是否进行加密 或 压缩 处理，二进制或ASCII码表示"></a>表示层——在传输之前是否进行加密 或 压缩 处理，二进制或ASCII码表示</h1><h1 id="会话层——查木马，看需求端和网站之间的连接"><a href="#会话层——查木马，看需求端和网站之间的连接" class="headerlink" title="会话层——查木马，看需求端和网站之间的连接"></a>会话层——查木马，看需求端和网站之间的连接</h1><h1 id="传输层——可靠传输，流量控制，不可靠传输-一个数据包即可，不需要建立会话，例如向DNS查询网站IP地址"><a href="#传输层——可靠传输，流量控制，不可靠传输-一个数据包即可，不需要建立会话，例如向DNS查询网站IP地址" class="headerlink" title="传输层——可靠传输，流量控制，不可靠传输(一个数据包即可，不需要建立会话，例如向DNS查询网站IP地址)"></a>传输层——可靠传输，流量控制，不可靠传输(一个数据包即可，不需要建立会话，例如向DNS查询网站IP地址)</h1><h2 id="网络层——负责选择最佳路径，规划IP地址-ipv4和ipv6变化只会影响网络层"><a href="#网络层——负责选择最佳路径，规划IP地址-ipv4和ipv6变化只会影响网络层" class="headerlink" title="网络层——负责选择最佳路径，规划IP地址(ipv4和ipv6变化只会影响网络层)"></a>网络层——负责选择最佳路径，规划IP地址(ipv4和ipv6变化只会影响网络层)</h2><p>网络层的主要任务是为网络上的不同主机提供通信。它通过路由选择算法，为分组通过通信子网选择最适当的路径，以实现网络的<a href="https://baike.baidu.com/item/互连/5922473">互连</a>功能。具体地说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、<a href="https://baike.baidu.com/item/流量控制/3441910">流量控制</a>、<a href="https://baike.baidu.com/item/拥塞控制/732651">拥塞控制</a>等将信息从一台网络设备传送到另一台网络设备。网络层负责在网络中传送的数据单元是分组或包。该层协议的代表包括<a href="https://baike.baidu.com/item/IP/224599">IP</a>、<a href="https://baike.baidu.com/item/IPX/609379">IPX</a>、<a href="https://baike.baidu.com/item/RIP/571852">RIP</a>、<a href="https://baike.baidu.com/item/OSPF/1166620">OSPF</a>等</p>
<h1 id="数据链路层——帧的开始和结束，还有透明传输，差错校验-纠错由传输层解决"><a href="#数据链路层——帧的开始和结束，还有透明传输，差错校验-纠错由传输层解决" class="headerlink" title="数据链路层——帧的开始和结束，还有透明传输，差错校验(纠错由传输层解决)"></a>数据链路层——帧的开始和结束，还有透明传输，差错校验(纠错由传输层解决)</h1><p>它的主要任务是负责在两个相邻结点之间的线路上无差错地传输以<a href="https://baike.baidu.com/item/帧/23750184">帧</a>为单位的数据，即将一条有可能出差错的实际链路转变成让网络层向下看去好像是一条不出差错的<a href="https://baike.baidu.com/item/链路/9410314">链路</a>。数据链路层将数据分解成帧，然后按顺序传输帧，每一帧包括数据和必要的控制信息（包括<a href="https://baike.baidu.com/item/同步信息/5925963">同步信息</a>、地址信息、<a href="https://baike.baidu.com/item/差错控制/1614020">差错控制</a>信息和<a href="https://baike.baidu.com/item/流量控制/3441910">流量控制</a>信息等）。</p>
<h1 id="物理层——定义网络设备接口标准，电气标准-电压-，如何在物理链路上传输的更快"><a href="#物理层——定义网络设备接口标准，电气标准-电压-，如何在物理链路上传输的更快" class="headerlink" title="物理层——定义网络设备接口标准，电气标准(电压)，如何在物理链路上传输的更快"></a>物理层——定义网络设备接口标准，电气标准(电压)，如何在物理链路上传输的更快</h1><p>物理层的任务是透明地传送<a href="https://baike.baidu.com/item/比特流/6435599">比特流</a>。现有计算机网络中的物理设备和传输媒体种类繁多，通信手段也有多种，物理层的作用正是要尽可能地屏蔽这些差异，使物理层上面的数据链路层感觉不到这些差异</p>
<h1 id="各层对应的协议"><a href="#各层对应的协议" class="headerlink" title="各层对应的协议"></a>各层对应的协议</h1><p><img src="https://photos.alitaalice.cn/image/20200820103719.png" alt=""></p>
<h1 id="数据帧和数据包"><a href="#数据帧和数据包" class="headerlink" title="数据帧和数据包"></a>数据帧和数据包</h1><p><img src="https://photos.alitaalice.cn/image/20200820103354.png" alt=""></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>OutOfMemeryError异常</title>
    <url>/2020/05/25/OutOfMemeryError%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍OutOfMemeryError异常</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-Java堆溢出"><a href="#1-Java堆溢出" class="headerlink" title="1 Java堆溢出"></a>1 Java堆溢出</h3><p><img src="https://photos.alitaalice.cn/image/20200525171739.png" alt=""></p>
<h3 id="2-虚拟机栈和本地方法栈溢出"><a href="#2-虚拟机栈和本地方法栈溢出" class="headerlink" title="2 虚拟机栈和本地方法栈溢出"></a>2 虚拟机栈和本地方法栈溢出</h3><p><img src="https://photos.alitaalice.cn/image/20200525171954.png" alt=""></p>
<h3 id="3-方法区和运行时常量池溢出"><a href="#3-方法区和运行时常量池溢出" class="headerlink" title="3 方法区和运行时常量池溢出"></a>3 方法区和运行时常量池溢出</h3><h3 id="4-本地直接内存溢出"><a href="#4-本地直接内存溢出" class="headerlink" title="4 本地直接内存溢出"></a>4 本地直接内存溢出</h3>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql用户变量和set语句</title>
    <url>/2020/05/19/Mysql%E7%94%A8%E6%88%B7%E5%8F%98%E9%87%8F%E5%92%8Cset%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍mysql用户变量和set语句</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-用户变量介绍"><a href="#1-用户变量介绍" class="headerlink" title="1 用户变量介绍"></a>1 用户变量介绍</h3><p>用户变量即用户自己定义的变量，我们可以给用户变量分配值，并且可用在任何可以正常使用标量表达式的地方。<br>    引入用户变量之前我们必须使用set语句或select语句来定义它，然后为它赋一个值，否则变量就只有一个空值。<br>    用户变量与连接有关。也就是说，一个客户端定义的变量不能被其它客户端看到或使用。当客户端退出时，该客户端连接的所有变量将自动释放。</p>
<h3 id="2-用户变量定义"><a href="#2-用户变量定义" class="headerlink" title="2 用户变量定义"></a>2 用户变量定义</h3><p>set语句可用于向系统变量或用户变量赋值，针对用户变量的定义如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SET <span class="meta">@var</span>_name = expr [, <span class="meta">@var</span>_name = expr] ...</span><br></pre></td></tr></table></figure>

<p>也可使用select语句来定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SELECT <span class="meta">@var</span>_name := expr [, <span class="meta">@var</span>_name = expr] ...</span><br></pre></td></tr></table></figure>

<p>用户变量：以”@”开始，形式为”@var_name”,以区分用户变量及列名。它可以是任何随机的，复合的标量表达式，只要其中没有列指定。<br>一个变量名可以由当前字符集的数字字母字符和“_”、“$”和“.”组成。缺省字符集是ISO-8859-1 Latin1；这可以用mysqld 的–default-character-set 选项更改字符集。<br>对于SET，可以使用=或:=来赋值，对于SELECT只能使用:=来赋值。<br>我们可以使用一条简单的select语句查询定义的用户变量的值</p>
<h3 id="3-用户变量的使用"><a href="#3-用户变量的使用" class="headerlink" title="3 用户变量的使用"></a>3 用户变量的使用</h3><h4 id="3-1-通过set的实例"><a href="#3-1-通过set的实例" class="headerlink" title="3.1 通过set的实例"></a>3.1 通过set的实例</h4><p>用来把一个值赋给一个变量的标量表达式可以是复合表达式。计算，函数，系统标量以及其他用户变量都是允许的，子查询也是允许的。然后通过select语句可以获取一个用户变量的值，结果是带有一行的一个表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; set <span class="meta">@var</span>1=<span class="number">1</span>, <span class="meta">@var</span>2=<span class="string">'vartest'</span>, <span class="meta">@var</span>3=abs(-<span class="number">2</span>), <span class="meta">@var</span>4=(<span class="function">select <span class="title">count</span><span class="params">(*)</span> from mysql.user)</span>;</span><br><span class="line">mysql&gt; select <span class="meta">@var</span>1, <span class="meta">@var</span>2, <span class="meta">@var</span>3, <span class="meta">@var</span>4;</span><br><span class="line">+-------+---------+-------+-------+</span><br><span class="line">| <span class="meta">@var</span>1 | <span class="meta">@var</span>2   | <span class="meta">@var</span>3 | <span class="meta">@var</span>4 |</span><br><span class="line">+-------+---------+-------+-------+</span><br><span class="line">|     <span class="number">1</span> | vartest |     <span class="number">2</span> |    <span class="number">25</span> |</span><br><span class="line">+-------+---------+-------+-------+</span><br></pre></td></tr></table></figure>

<p> 在用来为一个用户变量赋值的表达式中，也可以指定其它的用户变量，需要注意的是mysql首先确定所有表达式的值，之后才会把值赋给变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; set <span class="meta">@varA</span> = <span class="number">2</span>; </span><br><span class="line"></span><br><span class="line">mysql&gt; set <span class="meta">@varA</span> = <span class="number">3</span>, <span class="meta">@varB</span> = <span class="meta">@varA</span>;</span><br><span class="line">mysql&gt; select <span class="meta">@varB</span>;</span><br><span class="line">+-------+</span><br><span class="line">| <span class="meta">@varB</span> |</span><br><span class="line">+-------+</span><br><span class="line">|     <span class="number">2</span> |</span><br><span class="line">+-------+</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; set <span class="meta">@varA</span> = <span class="number">3</span>; </span><br><span class="line">mysql&gt; set <span class="meta">@varB</span> = <span class="meta">@varA</span>;</span><br><span class="line">mysql&gt; select <span class="meta">@varB</span>;                                             </span><br><span class="line">+-------+</span><br><span class="line">| <span class="meta">@varB</span> |</span><br><span class="line">+-------+</span><br><span class="line">|     <span class="number">3</span> |</span><br><span class="line">+-------+</span><br></pre></td></tr></table></figure>

<h4 id="3-2-通过select-的实例"><a href="#3-2-通过select-的实例" class="headerlink" title="3.2 通过select 的实例"></a>3.2 通过select 的实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; select <span class="meta">@var</span>1:=<span class="number">1</span>, <span class="meta">@var</span>2:=<span class="string">'vartest'</span>, <span class="meta">@var</span>3:=abs(-<span class="number">2</span>), <span class="meta">@var</span>4:=(<span class="function">select <span class="title">count</span><span class="params">(*)</span> from mysql.user)</span>;</span><br><span class="line">+----------+------------------+----------------+------------------------------------------+</span><br><span class="line">| <span class="meta">@var</span>1:=<span class="number">1</span> | <span class="meta">@var</span>2:=<span class="string">'vartest'</span> | <span class="meta">@var</span>3:=abs(-<span class="number">2</span>) | <span class="meta">@var</span>4:=(<span class="function">select <span class="title">count</span><span class="params">(*)</span> from mysql.user) |</span></span><br><span class="line"><span class="function">+----------+------------------+----------------+------------------------------------------+</span></span><br><span class="line"><span class="function">|        1 | vartest          |              2 |                                       25 |</span></span><br><span class="line"><span class="function">+----------+------------------+----------------+------------------------------------------+</span></span><br><span class="line"><span class="function">mysql&gt; select @var1, @var2, @var3, @var4</span>;</span><br><span class="line">+-------+---------+-------+-------+</span><br><span class="line">| <span class="meta">@var</span>1 | <span class="meta">@var</span>2   | <span class="meta">@var</span>3 | <span class="meta">@var</span>4 |</span><br><span class="line">+-------+---------+-------+-------+</span><br><span class="line">|     <span class="number">1</span> | vartest |     <span class="number">2</span> |    <span class="number">25</span> |</span><br><span class="line">+-------+---------+-------+-------+</span><br><span class="line">+-------+---------+-------+-------+</span><br><span class="line">|     <span class="number">1</span> | vartest |     <span class="number">2</span> |    <span class="number">25</span> |</span><br><span class="line">+-------+---------+-------+-------+</span><br></pre></td></tr></table></figure>



<h3 id="用户变量注意事项"><a href="#用户变量注意事项" class="headerlink" title="用户变量注意事项"></a>用户变量注意事项</h3><p>4.1 用户变量用在where或having子句中，他们必须首先用另一条语句来定义,如下面例子，初次查询没有返回结果，先定以后在查询才有输出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; select <span class="meta">@H</span>:=<span class="string">'localhost'</span> from mysql.user where host = <span class="meta">@H</span>;</span><br><span class="line"><span class="function">Empty <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function">mysql&gt; select @H:</span>=<span class="string">'localhost'</span>;</span><br><span class="line">+-----------------+</span><br><span class="line">| <span class="meta">@H</span>:=<span class="string">'localhost'</span> |</span><br><span class="line">+-----------------+</span><br><span class="line">| localhost       |</span><br><span class="line">+-----------------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function">mysql&gt; select @H:</span>=<span class="string">'localhost'</span>, user from mysql.user where host = <span class="meta">@H</span>;</span><br><span class="line">+-----------------+-----------------+</span><br><span class="line">| <span class="meta">@H</span>:=<span class="string">'localhost'</span> | user            |</span><br><span class="line">+-----------------+-----------------+</span><br><span class="line">| localhost       |                 |</span><br><span class="line">| localhost       | jesse           |</span><br><span class="line">| localhost       | local           |</span><br><span class="line">| localhost       | root            |</span><br><span class="line">| localhost       | user_tab_update |</span><br><span class="line">+-----------------+-----------------+</span><br></pre></td></tr></table></figure>

<p> 4.2 用户变量为session级别，当我们关闭客户端或退出登录时用户变量全部消失。如果想用就保存自定义的变量，需要自行创建一个表，将标量insert到表里。<br>  4.3 用户变量名对大小写不敏感。<br>  4.4 未定义的变量初始化是null。</p>
<h4 id="mysql语句do"><a href="#mysql语句do" class="headerlink" title="mysql语句do"></a>mysql语句do</h4><p> 在do语句中，使用了一个或多个标量表达式，mysql会一条一条的处理它们，但并不显示表达式的结果。例如我们可以调用函数执行后台的某些事情，而不需要看到其结果。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Map接口</title>
    <url>/2020/05/08/Map%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍Map接口</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="一-Map的定义"><a href="#一-Map的定义" class="headerlink" title="一.Map的定义"></a>一.Map的定义</h2><p>Map是一种依照键（key）存储元素的容器，键（key）很像下标。在List里下标是整数，而在Map中键（key）可以是任意类型的对象。Map中不能有重复的键（key），每个键都有一个对应的值（value)</p>
<p>一个键（key）和它对应的值（value)构成Map集合中的一个元素。</p>
<p>Map中的元素是俩个对象，一个对象作为键，一个对象作为值，<strong>键不可以重复，但是值可以重复。</strong></p>
<h2 id="二-Map常用方法"><a href="#二-Map常用方法" class="headerlink" title="二.Map常用方法"></a>二.Map常用方法</h2><ul>
<li><p>添加</p>
<table>
<thead>
<tr>
<th>put(key,Value)</th>
<th>调用put方法时，如果已经存在一个相同的key， 则返回的是前一个key对应的value，同时该key的新value覆盖旧value；如果是新的一个key，则返回的是null</th>
</tr>
</thead>
<tbody><tr>
<td>putAll</td>
<td>从指定映射中将所有映射关系复制到此映射中去。</td>
</tr>
</tbody></table>
</li>
<li><p><img src="https://photos.alitaalice.cn/image/20200530105616.png" alt=""></p>
</li>
<li><p>删除</p>
<table>
<thead>
<tr>
<th>remove(key)</th>
<th>删除指定key的键值对，返回被删除的key关联的value，不存在返回null</th>
</tr>
</thead>
<tbody><tr>
<td>remove(key,value)</td>
<td>删除指定键值对，成功返回true</td>
</tr>
<tr>
<td>clear()</td>
<td>删除map中所有的键值对</td>
</tr>
</tbody></table>
</li>
<li><p>获取</p>
<table>
<thead>
<tr>
<th>get(key)</th>
<th>返回指定key所对应的value，不存在则返回null</th>
</tr>
</thead>
<tbody><tr>
<td>Int size()</td>
<td>获取长度</td>
</tr>
</tbody></table>
</li>
<li><p>判断</p>
<table>
<thead>
<tr>
<th>boolean isEmpty()</th>
<th>长度为0返回true，否则false</th>
</tr>
</thead>
<tbody><tr>
<td>boolean containsKey(Object key)</td>
<td>判断集合中是否包含指定的key</td>
</tr>
<tr>
<td>boolean containsValue(Object value)</td>
<td>判断集合中是否包含指定的value</td>
</tr>
</tbody></table>
</li>
</ul>
<p>示例：</p>
<p>添加：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alita Alice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 13:48 2020/5/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map1.put(<span class="string">"jack"</span>, <span class="number">20</span>);</span><br><span class="line">        map1.put(<span class="string">"rose"</span>, <span class="number">18</span>);</span><br><span class="line">        map1.put(<span class="string">"lucy"</span>, <span class="number">17</span>);</span><br><span class="line">        map1.put(<span class="string">"java"</span>, <span class="number">25</span>);</span><br><span class="line">        System.out.println(<span class="string">"map11"</span>+map1);</span><br><span class="line"></span><br><span class="line">        Map&lt;String,Integer&gt; map2=<span class="keyword">new</span> HashMap();</span><br><span class="line">        map2.put(<span class="string">"张三丰"</span>, <span class="number">100</span>);</span><br><span class="line">        map2.put(<span class="string">"虚竹"</span>, <span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">"map2"</span>+map2);</span><br><span class="line">        <span class="comment">//从指定映射种将所有的映射关系复制到此映射种</span></span><br><span class="line">        map1.putAll(map2);</span><br><span class="line">        System.out.println(<span class="string">"map1"</span>+map1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* out</span></span><br><span class="line"><span class="comment">map11&#123;java=25, rose=18, lucy=17, jack=20&#125;</span></span><br><span class="line"><span class="comment">map2&#123;张三丰=100, 虚竹=20&#125;</span></span><br><span class="line"><span class="comment">map1&#123;java=25, 张三丰=100, rose=18, lucy=17, jack=20, 虚竹=20&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>删除：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alita Alice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 13:48 2020/5/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map1.put(<span class="string">"jack"</span>, <span class="number">20</span>);</span><br><span class="line">        map1.put(<span class="string">"rose"</span>, <span class="number">18</span>);</span><br><span class="line">        map1.put(<span class="string">"lucy"</span>, <span class="number">17</span>);</span><br><span class="line">        map1.put(<span class="string">"java"</span>, <span class="number">25</span>);</span><br><span class="line">        System.out.println(map1);</span><br><span class="line">        System.out.println(<span class="string">"delete value:"</span>+map1.remove(<span class="string">"java"</span>));</span><br><span class="line">        map1.clear();</span><br><span class="line">        System.out.println(<span class="string">"map1"</span>+map1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* out</span></span><br><span class="line"><span class="comment">&#123;java=25, rose=18, lucy=17, jack=20&#125;</span></span><br><span class="line"><span class="comment">delete value:25</span></span><br><span class="line"><span class="comment">map1&#123;&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alita Alice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 13:48 2020/5/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map1.put(<span class="string">"jack"</span>, <span class="number">20</span>);</span><br><span class="line">        map1.put(<span class="string">"rose"</span>, <span class="number">18</span>);</span><br><span class="line">        map1.put(<span class="string">"lucy"</span>, <span class="number">17</span>);</span><br><span class="line">        map1.put(<span class="string">"java"</span>, <span class="number">25</span>);</span><br><span class="line">        System.out.println(map1);</span><br><span class="line">        System.out.println(<span class="string">"value:"</span>+map1.get(<span class="string">"jack"</span>));</span><br><span class="line">        System.out.println(<span class="string">"map.size:"</span>+map1.size());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* out</span></span><br><span class="line"><span class="comment">&#123;java=25, rose=18, lucy=17, jack=20&#125;</span></span><br><span class="line"><span class="comment">value:20</span></span><br><span class="line"><span class="comment">map.size:4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>判断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alita Alice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 13:48 2020/5/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map1.put(<span class="string">"jack"</span>, <span class="number">20</span>);</span><br><span class="line">        map1.put(<span class="string">"rose"</span>, <span class="number">18</span>);</span><br><span class="line">        map1.put(<span class="string">"lucy"</span>, <span class="number">17</span>);</span><br><span class="line">        map1.put(<span class="string">"java"</span>, <span class="number">25</span>);</span><br><span class="line">        System.out.println(map1);</span><br><span class="line">        System.out.println(<span class="string">"isEmpty"</span>+map1.isEmpty());</span><br><span class="line">        System.out.println(<span class="string">"containskey"</span>+map1.containsKey(<span class="string">"jack"</span>));</span><br><span class="line">        System.out.println(<span class="string">"containsvaluse"</span>+map1.containsValue(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* out</span></span><br><span class="line"><span class="comment">&#123;java=25, rose=18, lucy=17, jack=20&#125;</span></span><br><span class="line"><span class="comment">isEmptyfalse</span></span><br><span class="line"><span class="comment">containskeytrue</span></span><br><span class="line"><span class="comment">containsvalusefalse</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="三-遍历Map的方式"><a href="#三-遍历Map的方式" class="headerlink" title="三.遍历Map的方式"></a>三.遍历Map的方式</h3><ul>
<li><p><strong>使用KeySet</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alita Alice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 13:48 2020/5/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map1.put(<span class="string">"jack"</span>, <span class="number">20</span>);</span><br><span class="line">        map1.put(<span class="string">"rose"</span>, <span class="number">18</span>);</span><br><span class="line">        map1.put(<span class="string">"lucy"</span>, <span class="number">17</span>);</span><br><span class="line">        map1.put(<span class="string">"java"</span>, <span class="number">25</span>);</span><br><span class="line">        System.out.println(map1);</span><br><span class="line">        Set&lt;String&gt; ks=map1.keySet();</span><br><span class="line">        Iterator&lt;String&gt; it=ks.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            String key=it.next();</span><br><span class="line">            Integer value = map1.get(key);</span><br><span class="line">            System.out.println(<span class="string">"key="</span>+key+<span class="string">" value="</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* out</span></span><br><span class="line"><span class="comment">&#123;java=25, rose=18, lucy=17, jack=20&#125;</span></span><br><span class="line"><span class="comment">key=java value=25</span></span><br><span class="line"><span class="comment">key=rose value=18</span></span><br><span class="line"><span class="comment">key=lucy value=17</span></span><br><span class="line"><span class="comment">key=jack value=20</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>将Map转换成Set集合，通过Set的迭代器取出Set集合中的每一个元素（Iterator)就是Map集合中所有的键，再通过get方法获取键对应的值。</p>
</li>
<li><p>通过values获取所有的值，不能获取到key对象</p>
<p>Collection<V> values()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map1.put(<span class="string">"jack"</span>, <span class="number">20</span>);</span><br><span class="line">        map1.put(<span class="string">"rose"</span>, <span class="number">18</span>);</span><br><span class="line">        map1.put(<span class="string">"lucy"</span>, <span class="number">17</span>);</span><br><span class="line">        map1.put(<span class="string">"java"</span>, <span class="number">25</span>);</span><br><span class="line">        Collection&lt;Integer&gt; vs=map1.values();  <span class="comment">//values方法获取所有的值但是不能获取到KEY对象。</span></span><br><span class="line">        Iterator&lt;Integer&gt; it = vs.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            Integer value=it.next();</span><br><span class="line">            System.out.println(<span class="string">"valuse="</span> +value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Map.Entry</p>
<p>面向对象的思想将Map集合中的键和值映射关系打包成一个对象，就是Map.Entry</p>
<p>将该对象存入Set集合，Map.Entry是一个对象，那么该对象具备的getKey ，getValue获得键和值。（<strong>通过Map中的entrySet()方法获取存放Map.Entry&lt;K,V&gt;对象的Set集合</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,String&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">1</span>,<span class="string">"aaaa"</span>);</span><br><span class="line">        map.put(<span class="number">2</span>,<span class="string">"bbb"</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">"cccc"</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        Set&lt;Map.Entry&lt;Integer,String&gt;&gt; es=map.entrySet();</span><br><span class="line">        Iterator&lt;Map.Entry&lt;Integer,String&gt;&gt; it=es.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            Map.Entry&lt;Integer,String&gt; en =it.next();</span><br><span class="line">            Integer key=en.getKey();</span><br><span class="line">            String value=en.getValue();</span><br><span class="line">            System.out.println(<span class="string">"key="</span>+key+<span class="string">"value="</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* out</span></span><br><span class="line"><span class="comment">&#123;1=aaaa, 2=bbb, 3=cccc&#125;</span></span><br><span class="line"><span class="comment">key=1value=aaaa</span></span><br><span class="line"><span class="comment">key=2value=bbb</span></span><br><span class="line"><span class="comment">key=3value=cccc</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>底层是哈希表数据结构，线程是不同步的，<strong>可以存入null键。</strong></p>
<p>要保证键的唯一性，需要覆盖hashCode方法 和equals方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alita Alice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 22:09 2020/5/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Person,String&gt; hm=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        hm.put(<span class="keyword">new</span> Person(<span class="string">"jack"</span>, <span class="number">20</span>), <span class="string">"1001"</span>);</span><br><span class="line">        hm.put(<span class="keyword">new</span> Person(<span class="string">"rose"</span>, <span class="number">18</span>), <span class="string">"1002"</span>);</span><br><span class="line">        hm.put(<span class="keyword">new</span> Person(<span class="string">"lucy"</span>, <span class="number">19</span>), <span class="string">"1003"</span>);</span><br><span class="line">        hm.put(<span class="keyword">new</span> Person(<span class="string">"hmm"</span>, <span class="number">17</span>), <span class="string">"1004"</span>);</span><br><span class="line">        hm.put(<span class="keyword">new</span> Person(<span class="string">"ll"</span>, <span class="number">17</span>), <span class="string">"1005"</span>);</span><br><span class="line">        System.out.println(hm);</span><br><span class="line">        System.out.println(hm.put(<span class="keyword">new</span> Person(<span class="string">"rose"</span>, <span class="number">18</span>), <span class="string">"1006"</span>));</span><br><span class="line">        Set&lt;Map.Entry&lt;Person,String&gt;&gt; entrySet =hm.entrySet();</span><br><span class="line">        Iterator&lt;Map.Entry&lt;Person,String&gt;&gt; it= entrySet.iterator();</span><br><span class="line">        <span class="keyword">while</span>  (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            Map.Entry&lt;Person,String&gt; next=it.next();</span><br><span class="line">            Person key =next.getKey();</span><br><span class="line">            String value=next.getValue();</span><br><span class="line">            System.out.println(key+ <span class="string">"="</span> +value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  String name;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> age;</span><br><span class="line">    Person()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Person)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> getAge() == person.getAge() &amp;&amp;</span><br><span class="line">                getName().equals(person.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(getName(), getAge());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* out </span></span><br><span class="line"><span class="comment">&#123;Person&#123;name='ll', age=17&#125;=1005, Person&#123;name='jack', age=20&#125;=1001, Person&#123;name='hmm', age=17&#125;=1004, Person&#123;name='lucy', age=19&#125;=1003, Person&#123;name='rose', age=18&#125;=1002&#125;</span></span><br><span class="line"><span class="comment">1002</span></span><br><span class="line"><span class="comment">Person&#123;name='ll', age=17&#125;=1005</span></span><br><span class="line"><span class="comment">Person&#123;name='jack', age=20&#125;=1001</span></span><br><span class="line"><span class="comment">Person&#123;name='hmm', age=17&#125;=1004</span></span><br><span class="line"><span class="comment">Person&#123;name='lucy', age=19&#125;=1003</span></span><br><span class="line"><span class="comment">Person&#123;name='rose', age=18&#125;=1006</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>TreeMap的排序，TreeMap 可以对集合中的键进行排序，如何实现对键的排序？</p>
<h3 id="方式1：-元素自身具备比较性"><a href="#方式1：-元素自身具备比较性" class="headerlink" title="方式1： 元素自身具备比较性"></a>方式1： 元素自身具备比较性</h3><p>和TreeSet一样原理，需要让存储在键位置的对象实现Comparable接口。重写compareTo方法，也就是让元素自身具备比较性，这种方式叫做元素的自然排序也叫默认排序。</p>
<h3 id="方式2：容器具备比较性"><a href="#方式2：容器具备比较性" class="headerlink" title="方式2：容器具备比较性"></a>方式2：容器具备比较性</h3><p>当元素自身不具备比较性，或者自身具备的比较性不是所需要的，那么此时可以让<strong>容器自身具备</strong>，需要定义一个类<strong>实现接口Compatator，重写compare方法，并将该接口的子类实例对象作为参数传递给TreeMap集合的构造方法。</strong></p>
<p>注意：当Comparable比较方式和Comparator比较方式同时存在时，以Comparator的比较方式为主。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alita Alice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 22:09 2020/5/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       TreeMap&lt;String,Integer&gt; tree=<span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        tree.put(<span class="string">"张三"</span>,<span class="number">19</span>);</span><br><span class="line">        tree.put(<span class="string">"李四"</span>,<span class="number">20</span>);</span><br><span class="line">        tree.put(<span class="string">"王五"</span>,<span class="number">21</span>);</span><br><span class="line">        tree.put(<span class="string">"赵留"</span>,<span class="number">21</span>);</span><br><span class="line">        System.out.println(tree);</span><br><span class="line">        System.out.println(<span class="string">"张三"</span>.compareTo(<span class="string">"李四"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义元素排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alita Alice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 22:09 2020/5/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     TreeMap&lt;Person,String&gt; hm=<span class="keyword">new</span> TreeMap&lt;Person, String&gt;(<span class="keyword">new</span> MyComparator());<span class="comment">//该接口的子类实例对象作为参数传递给TreeMap集合的构造方法。</span></span><br><span class="line">        hm.put(<span class="keyword">new</span> Person(<span class="string">"jack"</span>,<span class="number">20</span>),<span class="string">"1001"</span>);</span><br><span class="line">        hm.put(<span class="keyword">new</span> Person(<span class="string">"rose"</span>, <span class="number">18</span>), <span class="string">"1002"</span>);</span><br><span class="line">        hm.put(<span class="keyword">new</span> Person(<span class="string">"lucy"</span>, <span class="number">19</span>), <span class="string">"1003"</span>);</span><br><span class="line">        hm.put(<span class="keyword">new</span> Person(<span class="string">"hmm"</span>, <span class="number">17</span>), <span class="string">"1004"</span>);</span><br><span class="line">        System.out.println(hm);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Set&lt;Map.Entry&lt;Person,String&gt;&gt; entrySet=hm.entrySet();</span><br><span class="line">        Iterator&lt;Map.Entry&lt;Person,String&gt;&gt; it=entrySet.iterator();</span><br><span class="line">        <span class="keyword">while</span>  (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            Map.Entry&lt;Person,String&gt; next=it.next();</span><br><span class="line">            Person key=next.getKey();</span><br><span class="line">            String value=next.getValue();</span><br><span class="line">            System.out.println(key+ <span class="string">"="</span> +value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Person</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person p1,Person p2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1.getAge()&gt;p2.getAge())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p1.getAge()&lt;p2.getAge())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1.getName().compareTo(p2.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">  Person()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Person)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> getAge() == person.getAge() &amp;&amp;</span><br><span class="line">                getName().equals(person.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(getName(), getAge());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.age&gt;p.age) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.age&lt;p.age)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(p.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* out</span></span><br><span class="line"><span class="comment">&#123;Person&#123;name='jack', age=20&#125;=1001, Person&#123;name='lucy', age=19&#125;=1003, Person&#123;name='rose', age=18&#125;=1002, Person&#123;name='hmm', age=17&#125;=1004&#125;</span></span><br><span class="line"><span class="comment">Person&#123;name='jack', age=20&#125;=1001</span></span><br><span class="line"><span class="comment">Person&#123;name='lucy', age=19&#125;=1003</span></span><br><span class="line"><span class="comment">Person&#123;name='rose', age=18&#125;=1002</span></span><br><span class="line"><span class="comment">Person&#123;name='hmm', age=17&#125;=1004</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>注意：Set元素不可重复，Map的键不可重复</p>
<p>​           如果存入重复元素如何处理?</p>
<p>Set元素重复元素不能存入add方法，返回false;</p>
<p>Map的重复键将覆盖旧键，将旧值返回。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JAVA集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis_Set</title>
    <url>/2020/08/19/Redis-Set/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍Redis_Set</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set(集合)"></a>Set(集合)</h2><p>set中的值是不能重复的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd myset hello  <span class="comment">#set 添加元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SADD myset world</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SADD myset zhangxl</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset  <span class="comment">#查看set所有值</span></span><br><span class="line">1) <span class="string">"world"</span></span><br><span class="line">2) <span class="string">"hello"</span></span><br><span class="line">3) <span class="string">"zhangxl"</span></span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset hello  <span class="comment">#判断元素是否在set中</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset ll</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"><span class="comment">###########################</span></span><br><span class="line">127.0.0.1:6379&gt; SCARD myset <span class="comment">#获取集合中的个数</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"><span class="comment">#################</span></span><br><span class="line">127.0.0.1:6379&gt; srem myset hello <span class="comment">#移除set集合中的指定元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) <span class="string">"world"</span></span><br><span class="line">2) <span class="string">"zhangxl"</span></span><br><span class="line"><span class="comment">#################################</span></span><br><span class="line"><span class="built_in">set</span> 无序不重复集合 </span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset  <span class="comment">#随机抽选出一个元素</span></span><br><span class="line"><span class="string">"world"</span></span><br><span class="line"><span class="comment">#######################</span></span><br><span class="line">删除指定的key  删除随机的key</span><br><span class="line">127.0.0.1:6379&gt; spop myset   <span class="comment">#删除随机的key</span></span><br><span class="line"><span class="string">"world"</span></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset</span><br><span class="line"><span class="string">"zhangxl"</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd myset hello</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset world</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset zhangxl</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset iloveu</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset2 set2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SMOVE myset myset2 zhangxl <span class="comment">#移动命令</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset2</span><br><span class="line">1) <span class="string">"zhangxl"</span></span><br><span class="line">2) <span class="string">"set2"</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd key1 a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd key1 b</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd key1 c</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd key1 d</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd key2 d</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd key2 e</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd key2 f</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sdiff key1 key2  <span class="comment">#差集</span></span><br><span class="line">1) <span class="string">"a"</span></span><br><span class="line">2) <span class="string">"b"</span></span><br><span class="line">3) <span class="string">"c"</span></span><br><span class="line">127.0.0.1:6379&gt; SUNION key1 key2   <span class="comment">#并集</span></span><br><span class="line">1) <span class="string">"d"</span></span><br><span class="line">2) <span class="string">"a"</span></span><br><span class="line">3) <span class="string">"f"</span></span><br><span class="line">4) <span class="string">"e"</span></span><br><span class="line">5) <span class="string">"c"</span></span><br><span class="line">6) <span class="string">"b"</span></span><br><span class="line">127.0.0.1:6379&gt; sinter key1 key2  <span class="comment">#交集</span></span><br><span class="line">1) <span class="string">"d"</span></span><br></pre></td></tr></table></figure>

<h2 id="Hash-哈希"><a href="#Hash-哈希" class="headerlink" title="Hash (哈希)"></a>Hash (哈希)</h2><p>Map集合 key-value</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset myhash m1 v1    <span class="comment"># key-value</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hset myhash m2 v2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hset myhash m3 v3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hmset myhash m4 v4 m5 v5    <span class="comment">#批量设置</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hmget myhash m1 m2 m3 m4 m5</span><br><span class="line">1) <span class="string">"v1"</span></span><br><span class="line">2) <span class="string">"v2"</span></span><br><span class="line">3) <span class="string">"v3"</span></span><br><span class="line">4) <span class="string">"v4"</span></span><br><span class="line">5) <span class="string">"v5"</span></span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash   <span class="comment">#获取所有</span></span><br><span class="line"> 1) <span class="string">"m1"</span></span><br><span class="line"> 2) <span class="string">"v1"</span></span><br><span class="line"> 3) <span class="string">"m2"</span></span><br><span class="line"> 4) <span class="string">"v2"</span></span><br><span class="line"> 5) <span class="string">"m3"</span></span><br><span class="line"> 6) <span class="string">"v3"</span></span><br><span class="line"> 7) <span class="string">"m4"</span></span><br><span class="line"> 8) <span class="string">"v4"</span></span><br><span class="line"> 9) <span class="string">"m5"</span></span><br><span class="line">10) <span class="string">"v5"</span></span><br><span class="line">127.0.0.1:6379&gt; hdel myhash m1   <span class="comment">#删除某个key  and value</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line">1) <span class="string">"m2"</span></span><br><span class="line">2) <span class="string">"v2"</span></span><br><span class="line">3) <span class="string">"m3"</span></span><br><span class="line">4) <span class="string">"v3"</span></span><br><span class="line">5) <span class="string">"m4"</span></span><br><span class="line">6) <span class="string">"v4"</span></span><br><span class="line">7) <span class="string">"m5"</span></span><br><span class="line">8) <span class="string">"v5"</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line">1) <span class="string">"m2"</span></span><br><span class="line">2) <span class="string">"v2"</span></span><br><span class="line">3) <span class="string">"m3"</span></span><br><span class="line">4) <span class="string">"v3"</span></span><br><span class="line">5) <span class="string">"m4"</span></span><br><span class="line">6) <span class="string">"v4"</span></span><br><span class="line">7) <span class="string">"m5"</span></span><br><span class="line">8) <span class="string">"v5"</span></span><br><span class="line">127.0.0.1:6379&gt; hlen myhash   <span class="comment">#判断hash长度</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; hexists myhash m2  <span class="comment">#判断某一field是否存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hexists myhash m6</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hkeys myhash    <span class="comment">#获得所有keys</span></span><br><span class="line">1) <span class="string">"m2"</span></span><br><span class="line">2) <span class="string">"m3"</span></span><br><span class="line">3) <span class="string">"m4"</span></span><br><span class="line">4) <span class="string">"m5"</span></span><br><span class="line">127.0.0.1:6379&gt; hvals myhash   <span class="comment">#获得所有vals</span></span><br><span class="line">1) <span class="string">"v2"</span></span><br><span class="line">2) <span class="string">"v3"</span></span><br><span class="line">3) <span class="string">"v4"</span></span><br><span class="line">4) <span class="string">"v5"</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hincrby myhash field1 1   <span class="comment">#指定增量</span></span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; hget myhash field1</span><br><span class="line"><span class="string">"6"</span></span><br><span class="line">127.0.0.1:6379&gt; hincrby myhash field1 1</span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line">127.0.0.1:6379&gt; hget myhash field1</span><br><span class="line"><span class="string">"7"</span></span><br><span class="line">127.0.0.1:6379&gt; hsetnx myhash field1 hello</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; hsetnx myhash field1 h111</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line"> 1) <span class="string">"m2"</span></span><br><span class="line"> 2) <span class="string">"v2"</span></span><br><span class="line"> 3) <span class="string">"m3"</span></span><br><span class="line"> 4) <span class="string">"v3"</span></span><br><span class="line"> 5) <span class="string">"m4"</span></span><br><span class="line"> 6) <span class="string">"v4"</span></span><br><span class="line"> 7) <span class="string">"m5"</span></span><br><span class="line"> 8) <span class="string">"v5"</span></span><br><span class="line"> 9) <span class="string">"field1"</span></span><br><span class="line">10) <span class="string">"7"</span></span><br><span class="line">127.0.0.1:6379&gt; hsetnx myhash ssdsa 111   <span class="comment">#如果不存在则可以设置，如果存在不可以设置</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line"> 1) <span class="string">"m2"</span></span><br><span class="line"> 2) <span class="string">"v2"</span></span><br><span class="line"> 3) <span class="string">"m3"</span></span><br><span class="line"> 4) <span class="string">"v3"</span></span><br><span class="line"> 5) <span class="string">"m4"</span></span><br><span class="line"> 6) <span class="string">"v4"</span></span><br><span class="line"> 7) <span class="string">"m5"</span></span><br><span class="line"> 8) <span class="string">"v5"</span></span><br><span class="line"> 9) <span class="string">"field1"</span></span><br><span class="line">10) <span class="string">"7"</span></span><br><span class="line">11) <span class="string">"ssdsa"</span></span><br><span class="line">12) <span class="string">"111"</span></span><br></pre></td></tr></table></figure>

<h2 id="Zset-有序集合"><a href="#Zset-有序集合" class="headerlink" title="Zset(有序集合)"></a>Zset(有序集合)</h2><p>在set的基础上，增加了一个值</p>
<p>  set k1      v1 </p>
<p>  zset  k1    score v1 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd myset 1 one 2 two 3 three  <span class="comment"># score value</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE myset 0 -1</span><br><span class="line">1) <span class="string">"one"</span></span><br><span class="line">2) <span class="string">"two"</span></span><br><span class="line">3) <span class="string">"three"</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>@RequestBody的用法</title>
    <url>/2020/06/15/RequestBody%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍@RequestBody的用法</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><a href="https://jingyan.baidu.com/article/624e7459069f4034e8ba5a87.html">https://jingyan.baidu.com/article/624e7459069f4034e8ba5a87.html</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">jsonData();</span><br><span class="line"><span class="function">function <span class="title">jsonData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url:<span class="string">"&lt;%=path%&gt;/user/jsonTest.do"</span></span><br><span class="line">        contentType:<span class="string">'application/json;charset=utf8'</span>,</span><br><span class="line">        data:<span class="string">'&#123;"username":"张三","address":"福州"&#125;，</span></span><br><span class="line"><span class="string">        type:'</span>post<span class="string">',</span></span><br><span class="line"><span class="string">        success:function(data)</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            alert(data);</span></span><br><span class="line"><span class="string">        &#125;,error:function(error)</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">           alert(error);&#125;</span></span><br><span class="line"><span class="string">    &#125;)</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">后台接收如下：</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/jsonTest.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jsonTest</span><span class="params">(@RequstBody User user)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sout(user.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">那么输出的user就为 User[id&#x3D;0,username&#x3D;张三,sex&#x3D; ,birthday&#x3D;null,address&#x3D;福州]</span><br></pre></td></tr></table></figure>

<p>可以看到User这个对象中的username和address都已经自动赋值好了，这个就是json格式的数据转java对象了，是不是很方便呢，可以省去我们在后台将json转成java对象。不过在使用的时候，我们要注意两边的名称要相同，前台的username要对应java对象中的username这样才能成功。否则得到如下：</p>
<p><img src="https://photos.alitaalice.cn/image/20200616100452.png" alt=""></p>
]]></content>
      <categories>
        <category>springmvc</category>
      </categories>
      <tags>
        <tag>springmvc</tag>
      </tags>
  </entry>
  <entry>
    <title>@RequestParam注解使用</title>
    <url>/2020/06/29/RequestParam%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍@RequestParam注解使用</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><a href="https://blog.csdn.net/sswqzx/article/details/84195043">https://blog.csdn.net/sswqzx/article/details/84195043</a></p>
]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>@ResponseBody</title>
    <url>/2020/07/28/ResponseBody/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>@ResponseBody是作用在方法上的，@ResponseBody 表示该方法的返回结果直接写入 HTTP response body 中，一般在异步获取数据时使用【也就是AJAX】，在使用 @RequestMapping后，返回值通常解析为跳转路径，但是加上 @ResponseBody 后返回结果不会被解析为跳转路径，而是直接写入 HTTP response body 中。 比如异步获取 json 数据，加上 @ResponseBody 后，会直接返回 json 数据。@RequestBody 将 HTTP 请求正文插入方法中，使用适合的 HttpMessageConverter 将请求体写入某个对象。</p>
<p> 在使用springmvc框架的时候，在处理json的时候需要用到spring框架特有的注解@ResponseBody或者@RestController注解，这两个注解都会处理返回的数据格式，使用了该类型注解后返回的不再是视图，不会进行转跳，而是返回json或xml数据格式，输出在页面上。</p>
<p>  那么，这两个注解在使用上有什么区别呢？</p>
<p>  @ResponseBody，一般是使用在单独的方法上的，需要哪个方法返回json数据格式，就在哪个方法上使用，具有针对性。</p>
<p>  @RestController，一般是使用在类上的，它表示的意思其实就是结合了@Controller和@ResponseBody两个注解，</p>
<p>如果哪个类下的所有方法需要返回json数据格式的，就在哪个类上使用该注解，具有统一性；需要注意的是，使用了@RestController注解之后，其本质相当于在该类的所有方法上都统一使用了@ResponseBody注解，所以该类下的所有方法都会返回json数据格式，输出在页面上，而不会再返回视图。</p>
]]></content>
  </entry>
  <entry>
    <title>SSM基础</title>
    <url>/2020/05/27/SSM%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC流程</title>
    <url>/2020/06/15/SpringMVC%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍SpringMVC流程</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>SpringMVC流程：请求执行到后端控制器（位于Web层）之后，后端控制器会继续调用Service层中的业务代码，而Service层继续向后调用Manager层或者DAO层，进而获得目标数据。Service层将获得到的目标数据返回给后端控制器。后端控制器把目标数据包装成Model之后返回给ViewResolver，ViewResolver把Model渲染成最终用户看到的页面。</p>
<p><img src="https://photos.alitaalice.cn/image/20200615092105.png" alt=""></p>
<p><img src="C:%5CUsers%5C16508%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200615092208397.png" alt="image-20200615092208397"></p>
<p><img src="https://photos.alitaalice.cn/image/20200615092336.png" alt=""></p>
]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring的事务以及循环依赖</title>
    <url>/2020/09/18/Spring%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%BB%A5%E5%8F%8A%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Set相关</title>
    <url>/2020/05/08/Set%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍Set</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p><strong>SET:注重独一无二的性质，该体系集合知道某物是否已经存在于集合中，不会存储重复的元素。</strong></p>
<p>用于存储无序（存入和取出的顺序不一定相同）元素，值不能重复</p>
<p>Set集合继承了Collection接口。</p>
<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>哈希表里面存放的是哈希值。HashSet存储元素的顺序并不是按照存入时的顺序（和List 显然不同）是按照哈希值来存，所以取也是按照哈希值来取得。</p>
<p><strong>元素的哈希值是通过元素的hashcode方法来获取的，HashSet首先判断俩个元素的哈希值，如果哈希值一样，那么接着比较equals方法，如果equals结果为true。HashSet就会视作同一个元素。如果equals为false 就不是同一个元素。</strong></p>
<h3 id="HashSet到底是如何判断俩个元素重复"><a href="#HashSet到底是如何判断俩个元素重复" class="headerlink" title="HashSet到底是如何判断俩个元素重复"></a>HashSet到底是如何判断俩个元素重复</h3><p>通过hashCode方法和equals方法来保证元素的唯一性，add()返回的是boolean类型</p>
<p>判断两个元素是否相同，先要判断元素的hashCode值是否一致，只有在该值一致的情况下，才会判断equals方法，如果存储在HashSet中的两个对象hashCode方法的值相同equals方法返回的结果是true，那么HashSet认为这两个元素是相同元素，只存储一个（重复元素无法存入）。</p>
<p>注意：HashSet集合在判断元素是否相同先判断hashCode方法，如果相同才会判断equals。如果不相同，是不会调用equals方法的。</p>
<h3 id="HashSet-和ArrayList集合都有判断元素是否相同的方法"><a href="#HashSet-和ArrayList集合都有判断元素是否相同的方法" class="headerlink" title="HashSet 和ArrayList集合都有判断元素是否相同的方法"></a>HashSet 和ArrayList集合都有判断元素是否相同的方法</h3><p>boolean contains(Object o)</p>
<p>HashSet使用hashCode和equals方法，ArrayList使用了equals方法</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set hs=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        hs.add(<span class="string">"jack"</span>);</span><br><span class="line">        hs.add(<span class="string">"rose"</span>);</span><br><span class="line">        hs.add(<span class="string">"2020"</span>);</span><br><span class="line">        hs.add(<span class="string">"trip"</span>);</span><br><span class="line">        System.out.println(hs.size());</span><br><span class="line">        <span class="keyword">boolean</span> add=hs.add(<span class="string">"jack"</span>); <span class="comment">/* 如果set尚未包含指定元素，那么 返回true 此时返回false; */</span></span><br><span class="line">        System.out.println(add);</span><br><span class="line">        Iterator it=hs.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alita Alice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 21:13 2020/5/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashSet hs = <span class="keyword">new</span> HashSet();</span><br><span class="line">        hs.add(<span class="keyword">new</span> Person(<span class="string">"jack"</span>, <span class="number">20</span>));</span><br><span class="line">        hs.add(<span class="keyword">new</span> Person(<span class="string">"rose"</span>,<span class="number">20</span>));</span><br><span class="line">        hs.add(<span class="keyword">new</span> Person(<span class="string">"rose"</span>,<span class="number">20</span>));</span><br><span class="line">        Iterator it= hs.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    Person()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Person)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> getAge() == person.getAge() &amp;&amp;</span><br><span class="line">                getName().equals(person.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(getName(), getAge());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其中在HashSet中存储自定义的对象，并尝试添加重复元素，需要override hashCode()和equals()方法。</strong></p>
<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p>现在有一批数据，要求不能重复存储元素，而且要排序。</p>
<p>ArrayList ，LinkList不能去除重复数据，HashSet可以去除重复，但是无序。</p>
<p>示例：使用TreeSet集合存储字符串元素，并且遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeSet treeSet=<span class="keyword">new</span> TreeSet();</span><br><span class="line">        treeSet.add(<span class="string">"aaa"</span>);</span><br><span class="line">        treeSet.add(<span class="string">"bbb"</span>);</span><br><span class="line">        treeSet.add(<span class="string">"ccc"</span>);</span><br><span class="line">        treeSet.add(<span class="string">"ddd"</span>);</span><br><span class="line">        System.out.println(treeSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">[aaa, bbb, ccc, ddd]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="俩种比较器接口"><a href="#俩种比较器接口" class="headerlink" title="俩种比较器接口"></a>俩种比较器接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparable </span><br><span class="line">         compareTo(Object o)  元素自身具备比较性</span><br><span class="line">Comparator</span><br><span class="line">         compare(Object o1,Object o2) 给容器传入比较器</span><br></pre></td></tr></table></figure>

<h3 id="TreeSet集合排序的俩种方式"><a href="#TreeSet集合排序的俩种方式" class="headerlink" title="TreeSet集合排序的俩种方式"></a>TreeSet集合排序的俩种方式</h3><ul>
<li><p>让元素自身具备比较性</p>
<p>元素需要实现Comparable接口，覆盖compareTo(Object o) 方法</p>
<p>这种方式也被称为元素的自然排序，也可以称为默认排序</p>
<p>年龄按照首要条件，年龄相同再比姓名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.reflect.generics.tree.Tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alita Alice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 10:23 2020/5/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeSet ts=<span class="keyword">new</span> TreeSet();</span><br><span class="line">        ts.add(<span class="keyword">new</span> Person(<span class="string">"aa"</span>, <span class="number">20</span>, <span class="string">"男"</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> Person(<span class="string">"bb"</span>, <span class="number">18</span>, <span class="string">"女"</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> Person(<span class="string">"cc"</span>, <span class="number">17</span>, <span class="string">"男"</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> Person(<span class="string">"dd"</span>, <span class="number">17</span>, <span class="string">"女"</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> Person(<span class="string">"dd"</span>, <span class="number">15</span>, <span class="string">"女"</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> Person(<span class="string">"dd"</span>, <span class="number">15</span>, <span class="string">"女"</span>));</span><br><span class="line">        System.out.println(ts);</span><br><span class="line">        System.out.println(ts.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> String name;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">     <span class="keyword">private</span> String gender;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, String gender)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.name = name;</span><br><span class="line">         <span class="keyword">this</span>.age = age;</span><br><span class="line">         <span class="keyword">this</span>.gender = gender;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> name;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.name = name;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> age;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.age = age;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> gender;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(String gender)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.gender = gender;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                 <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                 <span class="string">", age="</span> + age +</span><br><span class="line">                 <span class="string">", gender='"</span> + gender + <span class="string">'\''</span> +</span><br><span class="line">                 <span class="string">'&#125;'</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Person)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         Person person = (Person) o;</span><br><span class="line">         <span class="keyword">return</span> getAge() == person.getAge() &amp;&amp;</span><br><span class="line">                 getName().equals(person.getName()) &amp;&amp;</span><br><span class="line">                 getGender().equals(person.getGender());</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> Objects.hash(getName(), getAge(), getGender());</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">         Person p = (Person) o;</span><br><span class="line">         System.out.println(<span class="keyword">this</span> + <span class="string">"compareTo:"</span> + p);</span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">this</span>.age &gt; p.age) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">this</span>.age &lt; p.age) &#123;</span><br><span class="line">             <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(p.name);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">/* out</span></span><br><span class="line"><span class="comment">Person&#123;name='aa', age=20, gender='男'&#125;compareTo:Person&#123;name='aa', age=20, gender='男'&#125;</span></span><br><span class="line"><span class="comment">Person&#123;name='bb', age=18, gender='女'&#125;compareTo:Person&#123;name='aa', age=20, gender='男'&#125;</span></span><br><span class="line"><span class="comment">Person&#123;name='cc', age=17, gender='男'&#125;compareTo:Person&#123;name='aa', age=20, gender='男'&#125;</span></span><br><span class="line"><span class="comment">Person&#123;name='cc', age=17, gender='男'&#125;compareTo:Person&#123;name='bb', age=18, gender='女'&#125;</span></span><br><span class="line"><span class="comment">Person&#123;name='dd', age=17, gender='女'&#125;compareTo:Person&#123;name='bb', age=18, gender='女'&#125;</span></span><br><span class="line"><span class="comment">Person&#123;name='dd', age=17, gender='女'&#125;compareTo:Person&#123;name='cc', age=17, gender='男'&#125;</span></span><br><span class="line"><span class="comment">Person&#123;name='dd', age=15, gender='女'&#125;compareTo:Person&#123;name='bb', age=18, gender='女'&#125;</span></span><br><span class="line"><span class="comment">Person&#123;name='dd', age=15, gender='女'&#125;compareTo:Person&#123;name='cc', age=17, gender='男'&#125;</span></span><br><span class="line"><span class="comment">Person&#123;name='dd', age=15, gender='女'&#125;compareTo:Person&#123;name='bb', age=18, gender='女'&#125;</span></span><br><span class="line"><span class="comment">Person&#123;name='dd', age=15, gender='女'&#125;compareTo:Person&#123;name='cc', age=17, gender='男'&#125;</span></span><br><span class="line"><span class="comment">Person&#123;name='dd', age=15, gender='女'&#125;compareTo:Person&#123;name='dd', age=15, gender='女'&#125;</span></span><br><span class="line"><span class="comment">[Person&#123;name='dd', age=15, gender='女'&#125;, Person&#123;name='cc', age=17, gender='男'&#125;, Person&#123;name='dd', age=17, gender='女'&#125;, Person&#123;name='bb', age=18, gender='女'&#125;, Person&#123;name='aa', age=20, gender='男'&#125;]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="二-让容器自身具备比较性，自定义比较器"><a href="#二-让容器自身具备比较性，自定义比较器" class="headerlink" title="二 让容器自身具备比较性，自定义比较器"></a>二 让容器自身具备比较性，自定义比较器</h3><p>需求：当元素自身不具备比较性，或者元素自身具备的比较性不是所需。</p>
<p><strong>那么这时只能让容器自身具备定义一个类实现Comparetor接口，覆盖compare方法</strong></p>
<p><strong>并将该接口的子类对象作为参数传递给TreeSet集合的构造函数。</strong></p>
<p>当Comparable 比较方式及Comparator比较方式同时存在， 以Comparator比较方式为主。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Set;</span><br><span class="line">  <span class="keyword">import</span> java.util.Comparator;</span><br><span class="line">  <span class="keyword">import</span> java.util.Objects;</span><br><span class="line">  <span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * This program demonstrates</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@author</span> Alita Alice</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Date</span>: Created in 10:54 2020/5/9</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo6</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          TreeSet ts=<span class="keyword">new</span> TreeSet(<span class="keyword">new</span> MyComparator());</span><br><span class="line">          ts.add(<span class="keyword">new</span> Book(<span class="string">"think in java"</span>, <span class="number">100</span>));</span><br><span class="line">          ts.add(<span class="keyword">new</span> Book(<span class="string">"java 核心技术"</span>, <span class="number">75</span>));</span><br><span class="line">          ts.add(<span class="keyword">new</span> Book(<span class="string">"现代操作系统"</span>, <span class="number">50</span>));</span><br><span class="line">          ts.add(<span class="keyword">new</span> Book(<span class="string">"java就业教程"</span>, <span class="number">35</span>));</span><br><span class="line">          ts.add(<span class="keyword">new</span> Book(<span class="string">"think in java"</span>, <span class="number">100</span>));</span><br><span class="line">          ts.add(<span class="keyword">new</span> Book(<span class="string">"ccc in java"</span>, <span class="number">100</span>));</span><br><span class="line">  </span><br><span class="line">          System.out.println(ts);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span></span></span><br><span class="line"><span class="class">  </span>&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">                      Book b1=(Book) o1;</span><br><span class="line">                      Book b2=(Book) o2;</span><br><span class="line">          System.out.println(b1+<span class="string">"comparator"</span>+b2);</span><br><span class="line">          <span class="keyword">if</span>(b1.getPrice()&gt;b2.getPrice())</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(b1.getPrice()&lt;b2.getPrice())</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> b1.getName().compareTo(b2.getName());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Book</span></span></span><br><span class="line"><span class="class">  </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> String name;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> name;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(String name, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.name = name;</span><br><span class="line">          <span class="keyword">this</span>.price = price;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.name = name;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> price;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.price = price;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Book)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          Book book = (Book) o;</span><br><span class="line">          <span class="keyword">return</span> Double.compare(book.getPrice(), getPrice()) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                  getName().equals(book.getName());</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> Objects.hash(getName(), getPrice());</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">"Book&#123;"</span> +</span><br><span class="line">                  <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                  <span class="string">", price="</span> + price +</span><br><span class="line">                  <span class="string">'&#125;'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* out</span></span><br><span class="line"><span class="comment">  Book&#123;name='think in java', price=100.0&#125;comparatorBook&#123;name='think in java', price=100.0&#125;</span></span><br><span class="line"><span class="comment">  Book&#123;name='java 核心技术', price=75.0&#125;comparatorBook&#123;name='think in java', price=100.0&#125;</span></span><br><span class="line"><span class="comment">  Book&#123;name='现代操作系统', price=50.0&#125;comparatorBook&#123;name='think in java', price=100.0&#125;</span></span><br><span class="line"><span class="comment">  Book&#123;name='现代操作系统', price=50.0&#125;comparatorBook&#123;name='java 核心技术', price=75.0&#125;</span></span><br><span class="line"><span class="comment">  Book&#123;name='java就业教程', price=35.0&#125;comparatorBook&#123;name='java 核心技术', price=75.0&#125;</span></span><br><span class="line"><span class="comment">  Book&#123;name='java就业教程', price=35.0&#125;comparatorBook&#123;name='现代操作系统', price=50.0&#125;</span></span><br><span class="line"><span class="comment">  Book&#123;name='think in java', price=100.0&#125;comparatorBook&#123;name='java 核心技术', price=75.0&#125;</span></span><br><span class="line"><span class="comment">  Book&#123;name='think in java', price=100.0&#125;comparatorBook&#123;name='think in java', price=100.0&#125;</span></span><br><span class="line"><span class="comment">  Book&#123;name='ccc in java', price=100.0&#125;comparatorBook&#123;name='java 核心技术', price=75.0&#125;</span></span><br><span class="line"><span class="comment">  Book&#123;name='ccc in java', price=100.0&#125;comparatorBook&#123;name='think in java', price=100.0&#125;</span></span><br><span class="line"><span class="comment">  [Book&#123;name='java就业教程', price=35.0&#125;, Book&#123;name='现代操作系统', price=50.0&#125;, Book&#123;name='java 核心技术', price=75.0&#125;, Book&#123;name='ccc in java', price=100.0&#125;, Book&#123;name='think in java', price=100.0&#125;]</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>

<h3 id="4-LinkedHashSet"><a href="#4-LinkedHashSet" class="headerlink" title="4.LinkedHashSet"></a>4.LinkedHashSet</h3></li>
</ul>
<p>LinkedHashSet会保存插入的顺序</p>
<p>看到array，就要想到角标</p>
<p>看到link ，就要想到first,last</p>
<p>看到hash,就要想到hashCode，equals</p>
<p>看到tree，就要想到俩个接口。Comparable,Comparator </p>
<h3 id="5-set为什么是不允许重复的"><a href="#5-set为什么是不允许重复的" class="headerlink" title="5.set为什么是不允许重复的"></a>5.set为什么是不允许重复的</h3><p>现在我们就从 Set 说起。</p>
<p>Set 接口为我们提供了一个 add() 方法，以让我们添加元素。所以我们看一下在其实现类 HashSet 中是如何实现的呢？</p>
<p>我们看 HashSet 中的 add() 方法实现；</p>
<p>  public boolean add( E o ) {</p>
<p>​       return <strong><em>\</em>map.put(o, PRESENT)==null;**</strong></p>
<p>}</p>
<p>你可能回问怎么回出来 map 了呢？</p>
<p>Map 又是一个什么变量呢？</p>
<p>我们来看 map 是在在哪定义的。原来，在 HashSet 中定义了这样的两个变量：</p>
<p>  private transient HashMap&lt;E,Object&gt; map;</p>
<p>  private static final Object PRESENT = new Object();</p>
<p>我们再看一下上面的 add() 方法。</p>
<p>map.put(o, PRESENT)==null</p>
<p>实际执行的是 map 的方法，并且我们添加的对象是 map 中的 key,value 是执行的同一个对象PRESENT.</p>
<p><strong><em>\</em>因为map中的key是不允许重复的，所以set中的元素不能重复。**</strong></p>
]]></content>
      <categories>
        <category>JAVA集合</category>
      </categories>
      <tags>
        <tag>JAVA集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring起步</title>
    <url>/2020/05/10/Spring%E8%B5%B7%E6%AD%A5/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍什么是Spring</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="什么是Spring"><a href="#什么是Spring" class="headerlink" title="什么是Spring"></a>什么是Spring</h2><ul>
<li><p>Spring 的核心是提供一个容器(container) </p>
<p>通常称为Spring 应用上下文（Spring application context) 应用前后关系，它们会创建和管理应用组件。</p>
<p>这些组件也被称为是bean ，会在Spring应用上下文中装配在一起，从而形成一个完整的应用程序。</p>
<p>这就像砖块，砂浆，木材 ，管道等组合在一起</p>
</li>
</ul>
<ul>
<li><p>将bean装配在一起是通过一种基于依赖注入（dependency injection DI)</p>
<p>举例来说：假设在众多的组件中，有俩个是我们需要处理的：库存服务，和商品服务。</p>
<p>商品服务需要依赖于库存服务。</p>
<p>如图所示阐述了bean和Spring 应用上下文之间的关系。</p>
<p><img src="TIM%E5%9B%BE%E7%89%8720200510124205.png" alt=""></p>
<p>依赖注入到需要它们的bean中，另外使用依赖注入的应用依赖于单独的实体（容器）来创建和维护所有的组件。</p>
<p> Spring Initializr 是一个基于浏览器的web应用，能够生成Spring 项目结构的骨架。</p>
</li>
</ul>
<h3 id="pom文件"><a href="#pom文件" class="headerlink" title="pom文件"></a>pom文件</h3><h2 id="Springboot的引导类"><a href="#Springboot的引导类" class="headerlink" title="Springboot的引导类"></a>Springboot的引导类</h2><p>@SpringBootApplication  ：是一个组合注解，包括：</p>
<ul>
<li>@SpringBootConfiguration</li>
</ul>
<p>将该类声明为配置类</p>
<ul>
<li>@EnableAutoConfiguration</li>
</ul>
<p>启动Spring BOOT 的自动配置 </p>
<ul>
<li>@ComponentScan </li>
</ul>
<p>启动组件扫描</p>
<p>@Component @Controller @Service 注解声明其他类，Spring会自动发现它们并将它们注册为Spring应用上下文的组件。</p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>String为什么设置成不可变类</title>
    <url>/2020/05/29/String%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AE%BE%E7%BD%AE%E6%88%90%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍String为什么设置成不可变类</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>转自<a href="https://blog.csdn.net/renfufei/article/details/16808775">https://blog.csdn.net/renfufei/article/details/16808775</a></p>
<h2 id="不可变对象的好处"><a href="#不可变对象的好处" class="headerlink" title="不可变对象的好处"></a>不可变对象的好处</h2><p>不可变类（Immutable Class）：所谓的不可变类是指这个类的实例一旦创建完成后，就不能改变其成员变量值。如JDK内部自带的很多不可变类：Interger、Long和String等。</p>
<p>可变类（Mutable Class）：相对于不可变类，可变类创建实例后可以改变其成员变量值，开发中创建的大部分类都属于可变类。</p>
<p>不可变类的特性对JAVA来说带来怎样的好处？</p>
<p>1）线程安全：不可变对象是线程安全的，在线程之间可以相互共享，不需要利用特殊机制来保证同步问题，因为对象的值无法改变。可以降低并发错误的可能性，因为不需要用一些锁机制等保证内存一致性问题也减少了同步开销。</p>
<p>2）易于构造、使用和测试。</p>
]]></content>
      <categories>
        <category>JAVASE</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>String,StringBuffer,StringBuilder的区别</title>
    <url>/2020/05/29/String-StringBuffer-StringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍String,StringBuffer,StringBuilder的区别</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>转<a href="https://blog.csdn.net/rmn190/article/details/1492013">https://blog.csdn.net/rmn190/article/details/1492013</a></p>
]]></content>
      <categories>
        <category>JAVASE</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>XPath的使用</title>
    <url>/2020/06/21/XPath%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍XPath</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="XPath的使用"><a href="#XPath的使用" class="headerlink" title="XPath的使用"></a>XPath的使用</h2><p>XPath，全称 XML Path Language，即 XML 路径语言，它是一门在XML文档中查找信息的语言。XPath 最初设计是用来搜寻XML文档的，但是它同样适用于 HTML 文档的搜索。</p>
<p>所以在做爬虫时，我们完全可以使用 XPath 来做相应的信息抽取，本节我们来介绍一下 XPath 的基本用法。</p>
<h2 id="1-XPath概览"><a href="#1-XPath概览" class="headerlink" title="1. XPath概览"></a>1. XPath概览</h2><p>XPath 的选择功能十分强大，它提供了非常简洁明了的路径选择表达式，另外它还提供了超过 100 个内建函数用于字符串、数值、时间的匹配以及节点、序列的处理等等，几乎所有我们想要定位的节点都可以用XPath来选择。</p>
<p>XPath 于 1999 年 11 月 16 日 成为 W3C 标准，它被设计为供 XSLT、XPointer 以及其他 XML 解析软件使用，更多的文档可以访问其官方网站：<a href="https://link.zhihu.com/?target=https%3A//www.w3.org/TR/xpath/">https://www.w3.org/TR/xpath/</a>。</p>
<h2 id="2-XPath常用规则"><a href="#2-XPath常用规则" class="headerlink" title="2. XPath常用规则"></a>2. XPath常用规则</h2><p>我们现用表格列举一下几个常用规则：</p>
<p>表达式描述<br>nodename选取此节点的所有子节点<br>/从当前节点选取直接子节点<br>//从当前节点选取子孙节点<br>.选取当前节点<br>..选取当前节点的父节点<br>@选取属性</p>
<p>在这里列出了XPath的常用匹配规则，例如 / 代表选取直接子节点，// 代表选择所有子孙节点，. 代表选取当前节点，.. 代表选取当前节点的父节点，@ 则是加了属性的限定，选取匹配属性的特定节点。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;title[@lang&#x3D;’eng’]</span><br></pre></td></tr></table></figure>

<p>这就是一个 XPath 规则，它就代表选择所有名称为 title，同时属性 lang 的值为 eng 的节点。</p>
<p>在后文我们会介绍 XPath 的详细用法，通过 Python 的 LXML 库利用 XPath 进行 HTML 的解</p>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>Volatile</title>
    <url>/2020/09/04/Volatile/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍Volatile</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="先补充一下概念：Java-内存模型中的可见性、原子性和有序性。"><a href="#先补充一下概念：Java-内存模型中的可见性、原子性和有序性。" class="headerlink" title="先补充一下概念：Java 内存模型中的可见性、原子性和有序性。"></a><strong>先补充一下概念：Java 内存模型中的可见性、原子性和有序性。</strong></h3><p><strong>可见性：</strong></p>
<p>　　可见性是一种复杂的属性，因为可见性中的错误总是会违背我们的直觉。通常，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。</p>
<p>　　<strong>可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。</strong>也就是一个线程修改的结果。另一个线程马上就能看到。比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。但是这里需要注意一个问题，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。比如 volatile int a = 0；之后有一个操作 a++；这个变量a具有可见性，但是a++ 依然是一个非原子操作，也就是这个操作同样存在线程安全问题。</p>
<p>　　在 Java 中 volatile、synchronized 和 final 实现可见性。</p>
<p><strong>原子性：</strong></p>
<p>　　<strong>原子是世界上的最小单位，具有不可分割性。</strong>比如 a=0；（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作时原子操作。再比如：a++； 这个操作实际是a = a + 1；是可分割的，所以他不是一个原子操作。非原子操作都会存在线程安全问题，需要我们使用同步技术（sychronized）来让它变成一个原子操作。一个操作是原子操作，那么我们称它具有原子性。java的concurrent包下提供了一些原子类，我们可以通过阅读API来了解这些原子类的用法。比如：AtomicInteger、AtomicLong、AtomicReference等。</p>
<p>　　在 Java 中 synchronized 和在 lock、unlock 中操作保证原子性。</p>
<p><strong>有序性：</strong></p>
<p>　　Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，volatile 是因为其本身包含“禁止指令重排序”的语义，synchronized 是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得的，此规则决定了持有同一个对象锁的两个同步块只能串行执行。</p>
<p><strong>下面内容摘录自《Java Concurrency in Practice》：</strong></p>
<p>　　下面一段代码在多线程环境下，将存在问题。</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a><a href="javascript:;">+ View code</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 &#x2F;**</span><br><span class="line"> 2  * @author zhengbinMac</span><br><span class="line"> 3  *&#x2F;</span><br><span class="line"> 4 public class NoVisibility &#123;</span><br><span class="line"> 5     private static boolean ready;</span><br><span class="line"> 6     private static int number;</span><br><span class="line"> 7     private static class ReaderThread extends Thread &#123;</span><br><span class="line"> 8         @Override</span><br><span class="line"> 9         public void run() &#123;</span><br><span class="line">10             while(!ready) &#123;</span><br><span class="line">11                 Thread.yield();</span><br><span class="line">12             &#125;</span><br><span class="line">13             System.out.println(number);</span><br><span class="line">14         &#125;</span><br><span class="line">15     &#125;</span><br><span class="line">16     public static void main(String[] args) &#123;</span><br><span class="line">17         new ReaderThread().start();</span><br><span class="line">18         number &#x3D; 42;</span><br><span class="line">19         ready &#x3D; true;</span><br><span class="line">20     &#125;</span><br><span class="line">21 &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　NoVisibility可能会持续循环下去，因为读线程可能永远都看不到ready的值。甚至NoVisibility可能会输出0，因为读线程可能看到了写入ready的值，但却没有看到之后写入number的值，这种现象被称为“重排序”。只要在某个线程中无法检测到重排序情况（即使在其他线程中可以明显地看到该线程中的重排序），那么就无法确保线程中的操作将按照程序中指定的顺序来执行。当主线程首先写入number，然后在没有同步的情况下写入ready，那么读线程看到的顺序可能与写入的顺序完全相反。</p>
<p>　　在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，要想对内存操作的执行春旭进行判断，无法得到正确的结论。</p>
<p>　　这个看上去像是一个失败的设计，但却能使JVM充分地利用现代多核处理器的强大性能。例如，在缺少同步的情况下，Java内存模型允许编译器对操作顺序进行重排序，并将数值缓存在寄存器中。此外，它还允许CPU对操作顺序进行重排序，并将数值缓存在处理器特定的缓存中。</p>
<h2 id="二、Volatile原理"><a href="#二、Volatile原理" class="headerlink" title="二、Volatile原理"></a>二、Volatile原理</h2><hr>
<p>　　Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。</p>
<p>　　在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。</p>
<p><img src="https://images2015.cnblogs.com/blog/731716/201607/731716-20160708224602686-2141387366.png" alt="img"></p>
<p>　　当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。</p>
<p>　　而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步。</p>
<h3 id="当一个变量定义为-volatile-之后，将具备两种特性："><a href="#当一个变量定义为-volatile-之后，将具备两种特性：" class="headerlink" title="当一个变量定义为 volatile 之后，将具备两种特性："></a>当一个变量定义为 volatile 之后，将具备两种特性：</h3><p>　　1.保证此变量对所有的线程的可见性，这里的“可见性”，如本文开头所述，当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存（详见：<a href="http://www.cnblogs.com/zhengbin/p/6407137.html">Java内存模型</a>）来完成。</p>
<p>　　2.禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个<strong>内存屏障</strong>（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；（什么是指令重排序：是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）。</p>
<h3 id="volatile-性能："><a href="#volatile-性能：" class="headerlink" title="volatile 性能："></a>volatile 性能：</h3><p>　　volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。</p>
<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p><img src="https://photos.alitaalice.cn/image/20200904105657.png" alt=""></p>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>ajax</title>
    <url>/2020/07/06/ajax/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍ajax</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><a href="https://www.cnblogs.com/Lighting-Sui/p/11494298.html">https://www.cnblogs.com/Lighting-Sui/p/11494298.html</a></p>
<p>JSON.stringify() 方法用于将 JavaScript 值转换为 JSON 字符串。</p>
<p>bootstraptable</p>
<p><a href="https://www.jianshu.com/p/b9d0f0935263">https://www.jianshu.com/p/b9d0f0935263</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>char可以存储汉字吗？</title>
    <url>/2020/05/06/char%E5%8F%AF%E4%BB%A5%E5%AD%98%E5%82%A8%E6%B1%89%E5%AD%97%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="char存储汉字"><a href="#char存储汉字" class="headerlink" title="char存储汉字"></a>char存储汉字</h2><ul>
<li><p>char是按照字符存储的，不管是英文还是中文，JAVA中固定占用2个字符，用来存储Unicode字符，范围在0-65535.</p>
</li>
<li><p>Unicode编码字符集中包含了汉字，所以char类型变量当然可以存储汉字拉。</p>
<a id="more"></a>

<h2 id="char和String的区别"><a href="#char和String的区别" class="headerlink" title="char和String的区别"></a>char和String的区别</h2><ul>
<li>char表示字符，定义时用单引号，只能存储一个字符。如char c=‘x’ ;</li>
<li>String表示的是字符串，可以存储一个或多个字符 如String name=”tom”;</li>
<li></li>
</ul>
</li>
</ul>
<p>如name.length();</p>
]]></content>
      <categories>
        <category>JAVASE</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>continue</title>
    <url>/2020/07/27/continue/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/qq_32452623/article/details/51488658">https://blog.csdn.net/qq_32452623/article/details/51488658</a></p>
]]></content>
  </entry>
  <entry>
    <title>equals和==的区别</title>
    <url>/2020/05/29/equals%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍equals和==的区别</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><a href="https://juejin.im/post/5c7ddcd06fb9a04a06059bea">https://juejin.im/post/5c7ddcd06fb9a04a06059bea</a></p>
]]></content>
      <categories>
        <category>JAVASE</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>delete、drop、truncate区别</title>
    <url>/2020/06/03/delete%E3%80%81drop%E3%80%81truncate%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍delete、drop、truncate区别</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>SQL关于删除的三个语句：<strong>DROP</strong>、<strong>TRUNCATE</strong>、 <strong>DELETE</strong> 的区别。</p>
<p><strong>DROP:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP test;</span><br></pre></td></tr></table></figure>

<p>删除表test，并释放空间，将test删除的一干二净。</p>
<p><strong>TRUNCATE:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TRUNCATE test;</span><br></pre></td></tr></table></figure>

<p>删除表test里的内容，并释放空间，但不删除表的定义，表的结构还在。</p>
<p><strong>DELETE:</strong></p>
<p>1、删除指定数据</p>
<p>删除表test中年龄等于30的且国家为US的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE FROM test WHERE age&#x3D;30 AND country&#x3D;&#39;US&#39;;</span><br></pre></td></tr></table></figure>

<p>2、删除整个表</p>
<p>仅删除表test内的所有内容，保留表的定义，不释放空间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE FROM test 或者 DELETE FROM test;</span><br><span class="line">DELETE * FROM test 或者 DELETE * FROM test;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>dom节点</title>
    <url>/2020/06/18/dom%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>1 </p>
<p><img src="https://photos.alitaalice.cn/image/20200618090133.png" alt=""></p>
<p>2 <img src="https://photos.alitaalice.cn/image/20200618090722.png" alt=""></p>
<p>3 article 和 aside 是 html5 的新标签。前段时间我刚学 html5 ，也是看的视频，刚开始不太明白，后来也想通了。html5 是什么呢？是 html 的升级版，在标签和功能上增强了，说到底还是 html 。html 又是什么呢？html 只是标签，a 就是锚点，p 就是段落，img 就是图片，我们按照这些规定来组织页面，他们本身只是标签，除此之外，没有任何意义，标签的背景颜色是什么，那是 css 的事，标签点击后出现什么效果，那时 js 的事。html 标签有几种分类，其中有一种就是网页布局性质的标签，如最常用的 div。抛开以前的传统网页布局（table布局）不谈，就说现在的网页布局——div+css。你比如说，你要做一个最简单的一行两列的网页，外层是一个 div 容器，里面两个 div，左边是导航菜单，右边是内容，为了实现网页布局，你肯定得用 css 定位，为了方便定位，你肯定得为 div 设置 id 或者 class，我们暂且用 id。外层容器 div ：id=”wrap”，内层左边 div：id=”aside”，内层右边 div：id=”article”。为什么左边导航 id 要给它设置为 aside（旁边），而不用 div1、div2 呢？因为 aside 赋予了 div 意义，给当前开发者和后期维护者带来方便，一看到 <div id="aside"> 我就知道它的作用，看到 <div id="div1"> 谁知道这是什么东西，就像 div 标签本身一样，毫无意义。而 article 和 aside 就像 div 一样，只是布局标签，除了标签名字不一样，其他功能意义基本是一样的，article、aside 里面的字体、背景、边框等没有任何特殊的样式，也不是鼠标点击了 aside 标签之后会出现什么特殊的效果，因为它们只是简简单单的标签。既然功能和 div 一模一样，html5 为何多此一举，又生产出几个多余的 “div” 出来呢？有句话叫做：存在的就是合理的。因为很多网站布局是重复的，全世界网站有很多都是左边是导航，右边是正文内容，然后给div设置id来用css布局，因为有这个需求，html5 就人性化的添加了几个标签，从而简化了开发人员的开发，毕竟，<aside> 与 <div id="aside">，那个更好？html 角度：前者比后者少写几行代码，一定程度简化了网页文件大小。css 角度：前者直接使用 aside 就能获取到标签，后者需要通过 id 。js 角度：同上。之前也听说过这么一个消息，说一些移动设备（如 ipad），在解析 html5 标签时，遇到 aside 标签可能会有个性化的展示，可能效果更美观。总结：<article> 你就看做是 <div id="article">，<aside> 你就看做是 <div id="aside">，仅仅是人为的给div 换了一个说话，换汤不换药，还是 div 。</p>
<p>4 ul  无序列表</p>
<p><a> 标签中的target=_blank</p>
<p>_self相同框架<br>_top整页<br>_blank新建一个窗口<br>_parent父窗口<br>其它的就是自定义了，可以指向已有的窗口名称</p>
<p><img src="https://photos.alitaalice.cn/image/20200619085109.png" alt=""></p>
]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>for_each循环</title>
    <url>/2020/05/29/for-each%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍for_each循环</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>for(variable :collection)  statement</p>
<p>它定义一个变量用于暂存集合中的每一个元素。</p>
<p>但是collection必须是一个数组或者一个实现了Iterable接口的类对象（例如ArrayList)</p>
<p>eg:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> element :a)</span><br><span class="line">    System.out.println(element);</span><br></pre></td></tr></table></figure>

<p>这个循环应该读作 循环a中的每一个元素。</p>
<p>在for_each 循环语句中的循环变量将会遍历循环数组中的每个元素，而不是下标值。</p>
]]></content>
      <categories>
        <category>JAVASE</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>final关键字</title>
    <url>/2020/05/30/final%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍final关键字</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>根据程序上下文环境，Java关键字final有“这是无法改变的”或者“终态的”含义，它可以修饰非抽象类、非抽象类成员方法和变量。你可能出于两种理解而需要阻止改变：设计或效率。<br>final类不能被继承，没有子类，final类中的方法默认是final的。<br>final方法不能被子类的方法覆盖，但可以被继承。<br>final成员变量表示常量，只能被赋值一次，赋值后值不再改变。<br>final不能用于修饰构造方法。</p>
]]></content>
      <categories>
        <category>JAVASE</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>get和post的区别</title>
    <url>/2020/06/13/get%E5%92%8Cpost%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍get和post的区别</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>说到底，我觉得是要正确理解“GET的页面”和“POST的页面”的区别。</p>
<p>要说清楚这两个区别，首先要说清楚一个概念——你输入内容的页面和没输入内容的页面是两种东西。</p>
<p>当你进入一个有表单的页面时，假如其URL是”<a href="https://link.zhihu.com/?target=http%3A//www.haha.com">http://www.haha.com</a>“，你把这个URL分享给朋友，朋友进入这个页面看到的所有内容将和你看到的一摸一样；</p>
<p>此时你在表单里输入你的名字，没有提交，URL还是“<a href="http://www.haha.com”，此时有两种情况：">www.haha.com”，此时有两种情况：</a></p>
<p>此时你并没有提交：</p>
<p>1.这个表单的method值是POST。你把这个URL分享给朋友，朋友看到的是和你不一样的页面（页面表单里没有你的名字，除此之外一摸一样）。</p>
<p>2.这个表单的method值是GET。你把这个URL分享给朋友，朋友看到的页面和你的还是不一样（GET能本地缓存（应该没有“联网缓存”）——在某些应用里，关闭网页后再次进入，你会看到一个有你名字的表单。QQ空间网页版就是这样，你在说说处输入内容但不发布，重新打开时你还能看到那个没发布的内容。当然，你清除浏览器的Cookie和网站记录后再次进入这个页面就看不到未发布的内容了）。</p>
<p>现在，你把表单提交了（注意，有时候你可能都不知道自己提交了这个表单，比如百度搜索里，回车就是提交~），有两种情况：</p>
<p>1.表单的method是POST，URL变成了“<a href="https://link.zhihu.com/?target=http%3A//www.haha.com/nimei.php">http://www.haha.com/nimei.php</a>”。此时页面被刷新，你的数据被提交服务器脚本返回给你一个新页面。此时就算你“后退”到“<a href="http://www.haha.com”也看不到你原来输入了内容的那个表单了；你把这个网页分享给朋友，朋友是看不到你的页面的（你这个页面必须是提交相同的数据后才能看到），这也是为什么你登陆微博后，直接复制地址栏的URL发给别人，别人看不到这个网页的原因。">www.haha.com”也看不到你原来输入了内容的那个表单了；你把这个网页分享给朋友，朋友是看不到你的页面的（你这个页面必须是提交相同的数据后才能看到），这也是为什么你登陆微博后，直接复制地址栏的URL发给别人，别人看不到这个网页的原因。</a></p>
<p>2.表单的method是GET，URL变成了“<a href="https://link.zhihu.com/?target=http%3A//www.haha.com/nimei.php%3Fname%3D">http://www.haha.com/nimei.php?name=</a>“haha”&amp;…..”。此时页面被刷新，同样得到一个新页面。如果你“后退”，你能看到原来输入了内容的表单；你可以保存为书签，关闭后再次打开能看到保存书签时的网页（<strong>因为URL里有你发给服务器脚本的所有数据，就相当于再次发送给服务器脚本相同的数据，返回的页面自然也就一样——服务器脚本处理这些数据得到的结果还是一样的话</strong>）；你可以把这个页面分享给朋友，朋友打开后能看到一摸一样的页面（理由和书签里说的一样）</p>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>http_https</title>
    <url>/2020/08/20/http-https/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍http_https</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="sdasd-asd"><a href="#sdasd-asd" class="headerlink" title="sdasd asd"></a>sdasd asd</h3><h3 id="3asd"><a href="#3asd" class="headerlink" title="3asd"></a>3asd</h3>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery入门</title>
    <url>/2020/06/13/jQuery%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍jQuery入门</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-什么是-jQuery-？"><a href="#1-什么是-jQuery-？" class="headerlink" title="1 什么是 jQuery ？"></a>1 什么是 jQuery ？</h3><p>jQuery是一个JavaScript函数库。</p>
<p>jQuery是一个轻量级的”写的少，做的多”的JavaScript库。</p>
<p>jQuery库包含以下功能：</p>
<ul>
<li>HTML 元素选取</li>
<li>HTML 元素操作</li>
<li>CSS 操作</li>
<li>HTML 事件函数</li>
<li>JavaScript 特效和动画</li>
<li>HTML DOM 遍历和修改</li>
<li>AJAX</li>
<li>Utilities</li>
</ul>
<p><strong>提示：</strong> 除此之外，Jquery还提供了大量的插件。</p>
<p>2 jQuery语法</p>
<p>基础语法：$(selector)查询和查找HTML元素</p>
<p>jQuery的action()执行对元素的操作</p>
<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(this).hide() &#x2F;&#x2F;隐藏当前元素</span><br><span class="line">$(&quot;p&quot;).hide() &#x2F;&#x2F;隐藏所有&lt;p&gt;元素</span><br><span class="line">$(&quot;p.test&quot;).hide()  &#x2F;&#x2F;隐藏所有class&#x3D;&quot;test&quot;的p元素</span><br><span class="line">$(&quot;#test&quot;).hide() &#x2F;&#x2F;隐藏id&#x3D;&quot;test&quot;的元素</span><br></pre></td></tr></table></figure>

<h3 id="2文档就绪事件"><a href="#2文档就绪事件" class="headerlink" title="2文档就绪事件"></a>2文档就绪事件</h3><p>这是为了防止文档在完全加载（就绪）之前运行 jQuery 代码，即在 DOM 加载完成后才可以对 DOM 进行操作。</p>
<p>如果在文档没有完全加载之前就运行函数，操作可能失败。下面是两个具体的例子：</p>
<ul>
<li>试图隐藏一个不存在的元素</li>
<li>获得未完全加载的图像的大小</li>
</ul>
<p>jQuery函数位于一个document ready函数中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//开始写jQuery代码</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>简洁写法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>))</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//开始写jQuery代码...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="3-元素选择器"><a href="#3-元素选择器" class="headerlink" title="3 元素选择器"></a>3 元素选择器</h3><p> jQuery元素选择器基于元素名选取元素</p>
<p>在页面中选取所有的<p>元素</p>
<p>$(“p”)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(document).ready(function()</span><br><span class="line">&#123;</span><br><span class="line">$(&quot;button&quot;).click(function())</span><br><span class="line">&#123;</span><br><span class="line">$(&quot;p&quot;).hide();</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-id-选择器"><a href="#4-id-选择器" class="headerlink" title="4 id 选择器"></a>4 id 选择器</h3><p>选择器通过HTML元素的id属性选取指定的元素</p>
<p>语法为</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"#test"</span>)</span><br></pre></td></tr></table></figure>

<p>实例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">$(<span class="string">"button"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">$(<span class="string">"#test"</span>).hide();</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;这是一个标题&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">&lt;p&gt;这是一个段落&lt;/</span>p&gt;</span><br><span class="line">&lt;p id=<span class="string">"test"</span>&gt;这是另外一个段落&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;button&gt;点我&lt;/</span>button&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-class选择器"><a href="#5-class选择器" class="headerlink" title="5 .class选择器"></a>5 .class选择器</h3><p>语法为</p>
<p>$(“.test”)</p>
<p>实例 用户点击按钮后所有带有class=“test”属性元素都隐藏：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">$(<span class="string">"button"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">$(<span class="string">".test"</span>).hide();</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&lt;h2 <span class="class"><span class="keyword">class</span></span>=<span class="string">"test"</span>&gt;这是一个标题&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">&lt;p class="test"&gt;这是一个段落。&lt;/</span>p&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://photos.alitaalice.cn/image/20200613124742.png" alt=""></p>
<p>click()方法是当按钮点击事件被触发时调用的一个函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"p"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">$(<span class="keyword">this</span>).hide();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>focus()</p>
<p>当元素获得焦点时，发生 focus 事件。</p>
<p>当通过鼠标点击选中元素或通过 tab 键定位到元素时，该元素就会获得焦点。</p>
<p>focus() 方法触发 focus 事件，或规定当发生 focus 事件时运行的函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"input"</span>).focus(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">$(<span class="keyword">this</span>).css(<span class="string">"background-color"</span>,<span class="string">"#ccccc"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>blur()</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"input"</span>).blur(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">$(<span class="keyword">this</span>).css(<span class="string">"background-color"</span>,<span class="string">"#ffffff"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">$(document).ready(function()&#123;</span></span><br><span class="line"><span class="regexp">  $("input").focus(function()&#123;</span></span><br><span class="line"><span class="regexp">    $(this).css("background-color","#cccccc");</span></span><br><span class="line"><span class="regexp">  &#125;);</span></span><br><span class="line"><span class="regexp">  $("input").blur(function()&#123;</span></span><br><span class="line"><span class="regexp">    $(this).css("background-color","#ffffff");</span></span><br><span class="line"><span class="regexp">  &#125;);</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">Name: &lt;input type="text" name="fullname"&gt;&lt;br&gt;</span></span><br><span class="line"><span class="regexp">Email: &lt;input type="text" name="email"&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure>

<p>p</p>
<p><img src="https://photos.alitaalice.cn/image/20200709093404.png" alt=""></p>
<p>67.</p>
]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>javai/o</title>
    <url>/2020/08/14/javai-o/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍java i-o</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><img src="https://photos.alitaalice.cn/image/20200814165347.png" alt=""></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java序列化</title>
    <url>/2020/08/31/java%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍java序列化</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="Java序列化与反序列化三连问：是什么？为什么要？如何做？"><a href="#Java序列化与反序列化三连问：是什么？为什么要？如何做？" class="headerlink" title="[Java序列化与反序列化三连问：是什么？为什么要？如何做？"></a>[Java序列化与反序列化三连问：是什么？为什么要？如何做？</h2><h2 id="Java序列化与反序列化是什么？"><a href="#Java序列化与反序列化是什么？" class="headerlink" title="Java序列化与反序列化是什么？"></a>Java序列化与反序列化是什么？</h2><p>Java序列化是指把Java对象转换为字节序列的过程，而Java反序列化是指把字节序列恢复为Java对象的过程：</p>
<ul>
<li><strong>序列化：</strong>对象序列化的最主要的用处就是在传递和保存对象的时候，保证对象的完整性和可传递性。序列化是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件中。核心作用是对象状态的保存与重建。</li>
<li><strong>反序列化：</strong>客户端从文件中或网络上获得序列化后的对象字节流，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象。</li>
</ul>
<h2 id="为什么需要序列化与反序列化？"><a href="#为什么需要序列化与反序列化？" class="headerlink" title="为什么需要序列化与反序列化？"></a>为什么需要序列化与反序列化？</h2><p>为什么要序列化，那就是说一下序列化的好处喽，序列化有什么什么优点，所以我们要序列化。</p>
<p><strong>一：对象序列化可以实现分布式对象。</strong></p>
<p>主要应用例如：RMI(即远程调用Remote Method Invocation)要利用对象序列化运行远程主机上的服务，就像在本地机上运行对象时一样。</p>
<p><strong>二：java对象序列化不仅保留一个对象的数据，而且递归保存对象引用的每个对象的数据。</strong></p>
<p>可以将整个对象层次写入字节流中，可以保存在文件中或在网络连接上传递。利用对象序列化可以进行对象的”深复制”，即复制对象本身及引用的对象本身。序列化一个对象可能得到整个对象序列。</p>
<p><strong>三：序列化可以将内存中的类写入文件或数据库中。</strong></p>
<p>比如：将某个类序列化后存为文件，下次读取时只需将文件中的数据反序列化就可以将原先的类还原到内存中。也可以将类序列化为流数据进行传输。</p>
<p>总的来说就是将一个已经实例化的类转成文件存储，下次需要实例化的时候只要反序列化即可将类实例化到内存中并保留序列化时类中的所有变量和状态。</p>
<p><strong>四：对象、文件、数据，有许多不同的格式，很难统一传输和保存。</strong></p>
<p>序列化以后就都是字节流了，无论原来是什么东西，都能变成一样的东西，就可以进行通用的格式传输或保存，传输结束以后，要再次使用，就进行反序列化还原，这样对象还是对象，文件还是文件。</p>
<h2 id="如何实现Java序列化与反序列化"><a href="#如何实现Java序列化与反序列化" class="headerlink" title="如何实现Java序列化与反序列化"></a>如何实现Java序列化与反序列化</h2><p>首先我们要把准备要序列化类，实现 Serializabel接口</p>
<p>例如：我们要Person类里的name和age都序列化</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; <span class="comment">//本类可以序列化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"姓名："</span> + <span class="keyword">this</span>.name + <span class="string">"，年龄"</span> + <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>然后：我们将name和age序列化（也就是把这2个对象转为二进制，理解为“打碎”）</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lxh.SerDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectOutputStreamDemo</span> </span>&#123; <span class="comment">//序列化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//序列化后生成指定文件路径</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"D:"</span> + File.separator + <span class="string">"person.ser"</span>);</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//装饰流（流）</span></span><br><span class="line">        oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(file));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实例化类</span></span><br><span class="line">        Person per = <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">30</span>);</span><br><span class="line">        oos.writeObject(per); <span class="comment">//把类对象序列化</span></span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>javase</category>
      </categories>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>js作用域</title>
    <url>/2020/06/13/js%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍js作用域</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1局部作用域"><a href="#1局部作用域" class="headerlink" title="1局部作用域"></a>1局部作用域</h3><p><img src="https://photos.alitaalice.cn/image/20200613090919.png" alt=""></p>
<h3 id="2-全局变量"><a href="#2-全局变量" class="headerlink" title="2 全局变量"></a>2 全局变量</h3><p><img src="https://photos.alitaalice.cn/image/20200613090959.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200613091057.png" alt=""></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>java中的引用</title>
    <url>/2020/08/31/java%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍java中的引用</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>1前言：先理解变量</p>
<p>在我们弄清楚引用之前，我们还得从变量讲起：</p>
<h3 id="变量有两类关键"><a href="#变量有两类关键" class="headerlink" title="变量有两类关键"></a>变量有两类关键</h3><p>（1）变量类型</p>
<ul>
<li>基本类型</li>
<li>引用类型</li>
</ul>
<p>（2）变量形态</p>
<ul>
<li>局部变量</li>
<li>形参</li>
<li>属性</li>
<li>静态变量</li>
</ul>
<p>一个变量是由它的类型和形态决定的，也就是上边两类的笛卡尔积。</p>
<h3 id="变量的存储位置"><a href="#变量的存储位置" class="headerlink" title="变量的存储位置"></a>变量的存储位置</h3><p><strong>变量在内存中的哪个区域存储，是由它的形态决定的，不是类型决定的！！！</strong><br>在我们判断一个变量在那里存储时，先看它属于什么（属于对象，属于类等等）然后再判断它应该在什么位置上放着（属于对象就在堆上，属于类就在方法区等等）。<br><img src="https://img-blog.csdnimg.cn/20200421165622947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0ODQwMTQ4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h2><h3 id="基本数据类型与引用类型的区别"><a href="#基本数据类型与引用类型的区别" class="headerlink" title="基本数据类型与引用类型的区别"></a>基本数据类型与引用类型的区别</h3><p><img src="https://img-blog.csdnimg.cn/20200421170403278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0ODQwMTQ4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="对引用的比喻"><a href="#对引用的比喻" class="headerlink" title="对引用的比喻"></a>对引用的比喻</h3><p>基本数据类型说是一个文件的话.，引用数据类型就是那个文件的快捷方式，通过引用我们就可以找到那个对象。</p>
<h1 id="和-equals-的区别"><a href="#和-equals-的区别" class="headerlink" title="== 和 equals 的区别"></a>== 和 equals 的区别</h1><h2 id="1、-解读"><a href="#1、-解读" class="headerlink" title="1、== 解读"></a>1、== 解读</h2><p>对于基本类型和引用类型 == 的作用效果是不同的，如下所示：</p>
<ul>
<li>基本类型：比较的是值是否相同；</li>
<li>引用类型：比较的是引用是否相同；</li>
</ul>
<p>代码示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String x &#x3D; &quot;string&quot;;</span><br><span class="line">String y &#x3D; &quot;string&quot;;</span><br><span class="line">String z &#x3D; new String(&quot;string&quot;);</span><br><span class="line">System.out.println(x&#x3D;&#x3D;y); &#x2F;&#x2F; true</span><br><span class="line">System.out.println(x&#x3D;&#x3D;z); &#x2F;&#x2F; false</span><br><span class="line">System.out.println(x.equals(y)); &#x2F;&#x2F; true</span><br><span class="line">System.out.println(x.equals(z)); &#x2F;&#x2F; true</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>代码解读：因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。</p>
<h2 id="2、equals-解读"><a href="#2、equals-解读" class="headerlink" title="2、equals 解读"></a>2、equals 解读</h2><p>equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。</p>
<p>首先来看默认情况下 equals 比较一个有相同值的对象，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Cat &#123;</span><br><span class="line">    public Cat(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cat c1 &#x3D; new Cat(&quot;王磊&quot;);</span><br><span class="line">Cat c2 &#x3D; new Cat(&quot;王磊&quot;);</span><br><span class="line">System.out.println(c1.equals(c2)); &#x2F;&#x2F; false</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">		return (this &#x3D;&#x3D; obj);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>原来 equals 本质上就是 ==。</p>
<p>那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String s1 &#x3D; new String(&quot;老王&quot;);</span><br><span class="line">String s2 &#x3D; new String(&quot;老王&quot;);</span><br><span class="line">System.out.println(s1.equals(s2)); &#x2F;&#x2F; true</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean equals(Object anObject) &#123;</span><br><span class="line">    if (this &#x3D;&#x3D; anObject) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (anObject instanceof String) &#123;</span><br><span class="line">        String anotherString &#x3D; (String)anObject;</span><br><span class="line">        int n &#x3D; value.length;</span><br><span class="line">        if (n &#x3D;&#x3D; anotherString.value.length) &#123;</span><br><span class="line">            char v1[] &#x3D; value;</span><br><span class="line">            char v2[] &#x3D; anotherString.value;</span><br><span class="line">            int i &#x3D; 0;</span><br><span class="line">            while (n-- !&#x3D; 0) &#123;</span><br><span class="line">                if (v1[i] !&#x3D; v2[i])</span><br><span class="line">                    return false;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。</p>
<h2 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h2><p><strong>总体来说，== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重写了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</strong></p>
]]></content>
      <categories>
        <category>javase</category>
      </categories>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>js入门</title>
    <url>/2020/06/13/js%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍javascript</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-为什么学习js"><a href="#1-为什么学习js" class="headerlink" title="1.为什么学习js"></a>1.为什么学习js</h3><ol>
<li><strong>HTML</strong> 定义了网页的内容</li>
<li><strong>CSS</strong> 描述了网页的布局</li>
<li><strong>JavaScript</strong> 网页的行为</li>
</ol>
<h3 id="2-JavaScript：对事件的反应"><a href="#2-JavaScript：对事件的反应" class="headerlink" title="2.JavaScript：对事件的反应"></a>2.JavaScript：对事件的反应</h3><p><button type="button" onclick="alert('欢迎')"> 点我</button></p>
<p>这是一个按钮，提醒按钮</p>
<h3 id="3-JAVAScript：改变HTML内容"><a href="#3-JAVAScript：改变HTML内容" class="headerlink" title="3.JAVAScript：改变HTML内容"></a>3.JAVAScript：改变HTML内容</h3><p>使用JAVAScript来处理HTML内容</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;我的第一段JAVAScript&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">&lt;p id="demo"&gt;</span></span><br><span class="line"><span class="regexp">JAVAScript能改变HTML元素的内容</span></span><br><span class="line"><span class="regexp">&lt;/</span>p&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x.document.getElementById(<span class="string">"demo"</span>);<span class="comment">//找到元素</span></span><br><span class="line">x.innerHTML=<span class="string">"hello javascript!"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;button type="button" onclick="myFunction()"&gt;点击这里&lt;/</span>button&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-验证输入"><a href="#3-验证输入" class="headerlink" title="3.验证输入"></a>3.验证输入</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;我的第一段javaScrit&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">&lt;p&gt;请输入数字，如果不是数字那么，浏览器会弹出提示框&lt;/</span>p&gt;</span><br><span class="line">&lt;input id=<span class="string">"demo"</span> type=<span class="string">"text"</span>&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">var</span> x=<span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).value;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="string">""</span>||<span class="built_in">isNaN</span>(x))</span><br><span class="line">&#123;</span><br><span class="line">alert(<span class="string">"不是数字"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;button type="button" onclick="myFunction()"&gt;点击这里&lt;/</span>button&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="4-在本例中，JavaScript-会在页面加载时向-HTML-的-写文本："><a href="#4-在本例中，JavaScript-会在页面加载时向-HTML-的-写文本：" class="headerlink" title="4 在本例中，JavaScript 会在页面加载时向 HTML 的  写文本："></a>4 在本例中，JavaScript 会在页面加载时向 HTML 的 <body> 写文本：<img src="https://photos.alitaalice.cn/image/20200613075951.png" alt=""></h3><h3 id="5-中的-JavaScript-函数"><a href="#5-中的-JavaScript-函数" class="headerlink" title="5 中的 JavaScript 函数"></a>5<head> 中的 JavaScript 函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML=<span class="string">"我的第一个 JavaScript 函数"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;我的 Web 页面&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">&lt;p id="demo"&gt;一个段落&lt;/</span>p&gt;</span><br><span class="line">&lt;button type=<span class="string">"button"</span> onclick=<span class="string">"myFunction()"</span>&gt;尝试一下&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure>

<p>6.<body> 中的 JavaScript 函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;我的 Web 页面&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">&lt;p id="demo"&gt;一个段落&lt;/</span>p&gt;</span><br><span class="line">&lt;button type=<span class="string">"button"</span> onclick=<span class="string">"myFunction()"</span>&gt;尝试一下&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">function myFunction()</span></span><br><span class="line"><span class="regexp">&#123;</span></span><br><span class="line"><span class="regexp">    document.getElementById("demo").innerHTML="我的第一个 JavaScript 函数";</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure>

<p>7.外部的 JavaScript</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script src=<span class="string">"myScript.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure>

<p>myScript.js 文件代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;    <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML=<span class="string">"我的第一个 JavaScript 函数"</span>; &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JavaScript 显示数据</span><br><span class="line">JavaScript 可以通过不同的方式来输出数据：</span><br><span class="line"></span><br><span class="line">使用 window.alert() 弹出警告框。</span><br><span class="line">使用 document.write() 方法将内容写到 HTML 文档中。</span><br><span class="line">使用 innerHTML 写入到 HTML 元素。</span><br><span class="line">使用 console.log() 写入到浏览器的控制台。</span><br></pre></td></tr></table></figure>

<p>8.JavaScript 显示数据</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">JavaScript 可以通过不同的方式来输出数据：</span><br><span class="line"></span><br><span class="line">使用 <span class="built_in">window</span>.alert() 弹出警告框。</span><br><span class="line">使用 <span class="built_in">document</span>.write() 方法将内容写到 HTML 文档中。</span><br><span class="line">使用 innerHTML 写入到 HTML 元素。</span><br><span class="line">使用 <span class="built_in">console</span>.log() 写入到浏览器的控制台。</span><br></pre></td></tr></table></figure>

<p><img src="https://photos.alitaalice.cn/image/20200613082104.png" alt=""></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>java_I/O</title>
    <url>/2020/06/05/java-I-O/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
      <categories>
        <category>JAVASE</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode2</title>
    <url>/2020/09/04/leetcode2/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h4 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><a href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加</a></h4><p>给出两个 <strong>非空</strong> 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 <strong>逆序</strong> 的方式存储的，并且它们的每个节点只能存储 <strong>一位</strong> 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 &#x3D; 807</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>linkedlist</title>
    <url>/2020/08/20/linkedlist/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>Java的Linked列表类提供了一个允许名为poll（）的“ <strong>基于队列</strong> ”工作的功能。该函数不仅返回删除第一个元素，而且在删除时<strong>显示</strong>它们，因此在日常生活中的问题和竞争性编程中也有很多用途。有<strong>3</strong>个poll（）变体，本文将讨论所有这三个变体。<br><strong>1. poll（）</strong>：此方法<strong>检索</strong>并<strong>删除</strong>此列表的<strong>头（第一个元素）</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">宣言 ： </span><br><span class="line">   公共E poll（）</span><br><span class="line">返回值： </span><br><span class="line">      此方法返回此列表的第一个元素；如果此列表为空，则返回null。</span><br></pre></td></tr></table></figure>

<p><strong>2. pollFirst（）：</strong>此方法<strong>检索</strong>并<strong>删除</strong>此列表的<strong>第一个元素</strong>，如果此列表为空，则返回null。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">宣言 ： </span><br><span class="line">  公共E pollFirst（）</span><br><span class="line">返回值： </span><br><span class="line">   此方法返回此列表的第一个元素；如果此列表为空，则返回null</span><br></pre></td></tr></table></figure>

<p><strong>3. pollLast（）：</strong>此方法<strong>检索</strong>并<strong>删除</strong>此列表的<strong>最后一个元素</strong>，如果此列表为空，则返回null。</p>
<p><strong>boolean offer(E e);</strong></p>
<p>将对象e插入队列尾部，成功返回true，失败（没有空间）返回false；</p>
]]></content>
      <categories>
        <category>linkedlist</category>
      </categories>
      <tags>
        <tag>linkedlist</tag>
      </tags>
  </entry>
  <entry>
    <title>linux解压命令</title>
    <url>/2020/08/15/linux%E8%A7%A3%E5%8E%8B%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍linux解压命令</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>tar cvf etcbak.tar etc/ 打包一个tar</p>
<p>tar xvf etcbak.tar 解开一个tar</p>
<hr>
<p>tar zcvf etcbak.tar.gz etc/ 打包压缩一个 tar.gz</p>
<p>tar zxvf etcbak.tar.gz 解压一个tar.gz</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux_grep_ps命令</title>
    <url>/2020/08/15/linux-grep-ps%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><img src="https://photos.alitaalice.cn/image/20200815184145.png" alt=""></p>
]]></content>
  </entry>
  <entry>
    <title>mysql使用触发器</title>
    <url>/2020/05/15/mysql%E4%BD%BF%E7%94%A8%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍触发器</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>触发器是MySQL响应以下任意语句而自动执行的一条MySQL语句（或位于BEGIN和END语句之间的一组语句 。</p>
<ul>
<li><p>DELETE </p>
</li>
<li><p>INSERT </p>
</li>
<li><p>UPDATE</p>
<p>在创建触发器时，需要给出4条信息 :</p>
<p><img src="https://photos.alitaalice.cn/image/20200515154008.png" alt=""></p>
</li>
</ul>
<p>Eg：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CREATE TRIGGER newproduct AFTER INSERT ON products</span><br><span class="line">FOR EACH ROW SELECT <span class="string">'Product added'</span></span><br></pre></td></tr></table></figure>

<p>CREATE TRIGGER用来创建名为newproduct的新触发器。触发器<br>可在一个操作发生之前或之后执行，这里给出了AFTER INSERT，<br>所以此触发器将在INSERT语句成功执行后执行。这个触发器还指定FOR EACH ROW，因此代码对每个插入行执行。在这个例子中，文本Product added将对每个插入的行显示一次.</p>
<p>  每个表最多支持6个触发器（每条INSERT、 UPDATE和DELETE的之前和之后）。单一触发器不能与多个事件或多个表关联，所以，如果你需要一个对INSERT和UPDATE操作执行的触发器，则应该定义两个触发器  .</p>
<h2 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TRIGGER newproduct;</span><br></pre></td></tr></table></figure>

<p>触发器不能更新或覆盖。为了修改一个触发器，必须先删除它，然后再重新创建。  </p>
<h2 id="使用-触发器"><a href="#使用-触发器" class="headerlink" title="使用 触发器"></a>使用 触发器</h2><h3 id="1-INSERT-触发器"><a href="#1-INSERT-触发器" class="headerlink" title="1 INSERT 触发器"></a>1 INSERT 触发器</h3><p>INSERT触发器在INSERT语句执行之前或之后执行。  </p>
<ul>
<li>在INSERT触发器代码内，可引用一个名为NEW的虚拟表，访问被插入的行；</li>
<li>在BEFORE INSERT触发器中， NEW中的值也可以被更新（允许更改被插入的值）；</li>
<li>对于AUTO_INCREMENT列， NEW在INSERT执行之前包含0，在INSERT 执行之后包含新的自动生成值  </li>
</ul>
<p>eg：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CREATE TRIGGER neworder AFTER INSERT ON orders</span><br><span class="line">FOR EACH ROW SELECT NEW.order_num;</span><br></pre></td></tr></table></figure>

<p>此代码创建一个名为neworder的触发器，它按照AFTER INSERT<br>ON orders执行。在插入一个新订单到orders表时， MySQL生<br>成一个新订单号并保存到order_num中。触发器从NEW. order_num取得这个值并返回它。此触发器必须按照AFTER INSERT执行，因为在BEFORE INSERT语句执行之前，新order_num还没有生成。对于orders的每次插入使用这个触发器将总是返回新的订单号。  </p>
<p>试着插入一下新行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO orders(order_date,cust_id) VALUES(NOW(),10001);</span><br></pre></td></tr></table></figure>

<p><img src="https://photos.alitaalice.cn/image/20200515155708.png" alt=""></p>
<h3 id="DELETE-触发器"><a href="#DELETE-触发器" class="headerlink" title="DELETE 触发器"></a>DELETE 触发器</h3><ul>
<li>在DELETE触发器代码内，你可以引用一个名为OLD的虚拟表，访问被删除的行；</li>
<li>OLD中的值全都是只读的，不能更新。  </li>
</ul>
<p>下面例子用OLD保存将要被删除的行到一个存档表中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CREATE TRIGGER deleteorder BEFORE DELETE ON orders</span><br><span class="line">FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">    <span class="function">INSERT INTO <span class="title">archive_orders</span><span class="params">(order_num, order_date,cust_id)</span> <span class="title">VALUES</span><span class="params">(OLD.order_num,OLD.order_date,OLD.cust_id)</span></span>;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<p>在任意订单被删除前将执行此触发器。它使用一条INSERT语句将OLD中的值（要被删除的订单）保存到一个名为archive_orders的存档表中（为实际使用这个例子，你需要用与orders相同的列创建一个名为archive_orders的表）  </p>
<h2 id="UPDATE-触发器"><a href="#UPDATE-触发器" class="headerlink" title="UPDATE 触发器"></a>UPDATE 触发器</h2><ul>
<li><p>在UPDATE触发器代码中，你可以引用一个名为OLD的虚拟表访问以前（UPDATE语句前）的值，引用一个名为NEW的虚拟表访问新更新的值；</p>
</li>
<li><p>在BEFORE UPDATE触发器中， NEW中的值可能也被更新（允许更改将要用于UPDATE语句中的值）；</p>
</li>
<li><p>OLD中的值全都是只读的，不能更新  </p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CREATE TRIGGER updatevendor BERORE UPDATE ON vendors</span><br><span class="line">FOR EACH ROW SET NEW.vend_state=Upper(NEW.vend_state);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql全文本搜索</title>
    <url>/2020/05/07/mysql%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>Mysql 全文本搜索用法实例及详解。</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h1 id="启用全文本搜索支持"><a href="#启用全文本搜索支持" class="headerlink" title="启用全文本搜索支持"></a>启用全文本搜索支持</h1><p>CREATE  TABLE 接受FULLTEXT子句</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CREATE TABLE productsnotes</span><br><span class="line">(</span><br><span class="line"> note_id <span class="keyword">int</span> NOT <span class="literal">NULL</span> AUTO_INCREMENT,  <span class="comment">/* auto increment 自动递增主键字段 */</span></span><br><span class="line"> prod_id <span class="keyword">char</span>(<span class="number">10</span>)  NOT <span class="literal">NULL</span>,</span><br><span class="line"> note_date datetime NOT <span class="literal">NULL</span>,</span><br><span class="line"> note_text  <span class="built_in">text</span>  <span class="literal">NULL</span>,</span><br><span class="line"> PRIMARY KEY(note_id),</span><br><span class="line"> FULLTEXT(note_text)</span><br><span class="line"> ) ENGINE=MyISAM;</span><br></pre></td></tr></table></figure>

<p>这条CREATE TABLE 语句定义表productnotes 并列出它所包含的列即可。这些列中有一个名为note_text 的列，为了进行全文本搜素，MySQL根据子句FULLTEXT(note_text)的指示对它进行索引。<br>FULLTEXT索引单个列，如果需要也可以指定多个列。</p>
<h2 id="在索引之后，使用俩个函数Match-和Against-执行全文本搜素"><a href="#在索引之后，使用俩个函数Match-和Against-执行全文本搜素" class="headerlink" title="在索引之后，使用俩个函数Match() 和Against()执行全文本搜素"></a>在索引之后，使用俩个函数Match() 和Against()执行全文本搜素</h2><p>其中Match()指定被搜索的列，Against()指定要使用的搜索表达式</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">SELECT note_text FROM productnotes WHERE Match(not_text) Against('rabbit');</span><br></pre></td></tr></table></figure>

<p>Match(note_text )指示MySQL针对指定的列进行搜索，Against(‘rabbit’) 指定词rabbit作为搜索文本。</p>
<p>使用完整的Match()说明，传递给Match()的值必须与FULLTEXT()定义中的相同。除非使用BINARY 方式，否则全文本搜索不区分大小写。</p>
<ul>
<li>搜索页可以简单地用LIKE子句完成</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">SELECT note_text FROM productnotes WHERE note_text LIKE '%rabbit%';</span><br></pre></td></tr></table></figure>

<ul>
<li>但是却与全文本搜索，各有优劣</li>
</ul>
<ol>
<li></li>
<li>在使用全文本搜索时就会对此结果排序，但是like却不会。</li>
</ol>
<h1 id="全文本布尔操作符"><a href="#全文本布尔操作符" class="headerlink" title="全文本布尔操作符"></a>全文本布尔操作符</h1><ul>
<li>+包含，词必须存在</li>
</ul>
<ul>
<li>-排除，词必须不出现</li>
<li>大于号 包含，而且增加等级值</li>
<li>&lt;包含，且减少等级值</li>
<li>() 把词组成子表达式(允许这些子表达式作为一个组被包含，排除，排列等）</li>
<li>~取消一个词的排序值</li>
</ul>
<ul>
<li>*词尾的通配符</li>
<li>“” 定义一个短语</li>
</ul>
<h2 id="布尔文本搜索"><a href="#布尔文本搜索" class="headerlink" title="布尔文本搜索"></a>布尔文本搜索</h2><p>布尔方式搜索，添加布尔操作符</p>
<p>IN BOOLEAN MODE</p>
<ul>
<li><p>举几个例子：</p>
</li>
<li><pre><code class="c">1 SELECT note_text FROM productnotes WHERE Match(note_text) Against('+rabbit +bait' IN BOOLEAN MODE);
<span class="comment">/*这个搜索匹配包含词rabbit和bait的行 */</span>
2 SELECT note_text FROM productnotes WHERE Match(note_text) Against('rabbit bait' IN BOOLEAN MODE);
<span class="comment">/*没有指定操作符，这个搜索匹配包含rabbit 和bait中的至少一个词的行。*/</span>
3 SELECT note_text FROM productnotes WHERE Match(note_text) Against('"rabbit bait"' IN BOOLEAN MODE);
4 SELECT note_text FROM productnotes WHERE Match(note_text) Against ('&gt;rabbit &lt;carrot' IN BOOLEAN MODE);</code></pre>
</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql执行外部sql</title>
    <url>/2020/06/07/mysql%E6%89%A7%E8%A1%8C%E5%A4%96%E9%83%A8sql/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍mysql执行外部sql</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>进入mysql的控制台后，使用source命令执行<br>Mysql&gt;source 【sql脚本文件的路径全名】 或 Mysql&gt;. 【sql脚本文件的路径全名】，示例：<br>source d:\test\ss.sql 或者 . d:\test\ss.sql</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql插入数据</title>
    <url>/2020/05/07/mysql%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍如何利用SQL的INSERT语句将数据插入到表中</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="插入到完整的行"><a href="#插入到完整的行" class="headerlink" title="插入到完整的行"></a>插入到完整的行</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">INSERT INTO Customers</span><br><span class="line">VALUES(<span class="literal">NULL</span>,</span><br><span class="line">       'PEP E.LAPEW',</span><br><span class="line">       '100 MAIN STREET',</span><br><span class="line">        'Los Angeles',</span><br><span class="line">         'CA',</span><br><span class="line">        '90046',</span><br><span class="line">         'USA',</span><br><span class="line">          <span class="literal">NULL</span>,</span><br><span class="line">          <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>编写INSERT语句的更加安全（不过更加繁琐）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO customers(cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country,cust_contact,cust_email)</span><br><span class="line">VALUSES(&#39;PEP E.LAPEW&#39;,</span><br><span class="line">       &#39;100 MAIN STREET&#39;,</span><br><span class="line">        &#39;Los Angeles&#39;,</span><br><span class="line">         &#39;CA&#39;,</span><br><span class="line">        &#39;90046&#39;,</span><br><span class="line">         &#39;USA&#39;,</span><br><span class="line">          NULL,</span><br><span class="line">          NULL&#39;);</span><br></pre></td></tr></table></figure>

<h3 id="省略列"><a href="#省略列" class="headerlink" title="省略列"></a>省略列</h3><ul>
<li>该列定义为允许null值</li>
<li>在表定义中给出默认值</li>
</ul>
<h3 id="提高整体性能"><a href="#提高整体性能" class="headerlink" title="提高整体性能"></a>提高整体性能</h3><p>如果数据检索是最重要的，那你可以通过在INSERT INTO 之间添加关键字</p>
<p>LOW_PRIORITY 指示Mysql降低INSERT语句的优先级</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT LOW_PRIORITY INTO</span><br></pre></td></tr></table></figure>

<h2 id="插入多个行"><a href="#插入多个行" class="headerlink" title="插入多个行"></a>插入多个行</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function">INSERT INTO <span class="title">customers</span><span class="params">(cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country,cust_contact,cust_email)</span></span></span><br><span class="line">VALUSES('PEP E.LAPEW',</span><br><span class="line">       '100 MAIN STREET',</span><br><span class="line">        'Los Angeles',</span><br><span class="line">         'CA',</span><br><span class="line">        '90046',</span><br><span class="line">         'USA',</span><br><span class="line">          <span class="literal">NULL</span>,</span><br><span class="line">          NULL'),</span><br><span class="line">       ('PEP E.LAPEW',</span><br><span class="line">       '100 MAIN STREET',</span><br><span class="line">        'Los Angeles',</span><br><span class="line">         'CA',</span><br><span class="line">        '90046',</span><br><span class="line">         'USA',</span><br><span class="line">          <span class="literal">NULL</span>,</span><br><span class="line">          NULL');</span><br></pre></td></tr></table></figure>

<p>其中单条INSERT语句有多组值，每组值用一对圆括号括起来，用逗号分隔。</p>
<h3 id="插入检索出的数据"><a href="#插入检索出的数据" class="headerlink" title="插入检索出的数据"></a>插入检索出的数据</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function">INSERT INTO <span class="title">customers</span><span class="params">(cust_id,cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country,cust_contact,cust_email)</span></span></span><br><span class="line">SELECT cust_id,cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country,cust_contact,cust_email FROM custnew;</span><br></pre></td></tr></table></figure>

<p>这个例子中INSERT SELECT 从custnew中将所有数据导入到customer中。</p>
<p><strong>其实MYSQL不关心SELECT返回的列名，它使用的是列的位置，因此SELECT中的第一列用来填充表列中指定的第一列</strong>。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql必知必会</title>
    <url>/2020/05/03/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</url>
    <content><![CDATA[<h2 id="1-基础操作"><a href="#1-基础操作" class="headerlink" title="1 基础操作"></a>1 基础操作</h2><p> 登录mysql -u root -p<br> Show databases;<br> Use databasename;<br>Show tables;  //显示行</p>
<a id="more"></a>
<p> Show columns from xxx;   //显示列 </p>
<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>SELECT DISTINCT  published FROM t_blog ;  DISTINCT此关键字指示只返回不同的值。<br> SELECT id FROM t_blog LIMIT 5;<br> SELECT id FROM t_blog LIMIT 3,3; //从第三行开始的后三行<br> SELECT t_blog.id FROM blog.t_blog;   完全限定的列名和表名 和之前的用法一样。<br> SELECT id,type_id,user_id FROM t_blog ORDER BY type_id,id;  先对type_id排序 再对id进行排序。<br> DESC 降序 ASC 升序  默认升序<br> SELECT id FROM t_blog ORDER BY type_id LIMIT 1; 此种方式找到了数值最大的一行。<br> <strong>在使用where 过滤时 ，order by 排序要在where的后面</strong><br> SELECT id FROM t_blog  where id &lt;&gt;10;   &lt;&gt; 不匹配检查<br> 范围值检查<br>  SELECT ID FROM T_BLOG WHERE ID BETWEEN 10 AND 20 :<br> Select id from t_blog where id is null;  空值检查<br> Select id,user_id from t_blog where id &lt;=10 and user_id &lt;=1;<br> Select prod_name,prod_price from products where vend_id=1002 or vend_id =1003 and<br>  Prod_price&gt;=10; SQL处理OR操作符和AND操作符时，优先处理AND操作符。<br> 故先处理 vend_id =1003 and prod_price&gt;=10  或者  vend_id=1002  ；<br>解决方法是<br>Select prod_name,prod_price from products where (vend_id =1002 or vend_id =1003) and prod_price &gt;=10    用( )来明确分组操作符。DBMS 首先过滤圆括号内的OR条件。<br>NOT 在MYSQL中的NOT中 MYSQL支持使用NOT 对IN,BETWEEN 和EXISTS子句取反。这与多数其他DBMS允许使用NOT对各种条件取反有很大区别。<br>######<br>通配符<br>用来匹配值的一部分的特殊字符<br>LIKE 指示MYSQL 后跟的搜索模式利用通配符匹配而不是直接相等匹配比较<br>SELECT prod_name FROM products WHERE prod_name REGEXP ‘[123] Ton’<br>ORDER BY prod_name;<br>正则表达式 [123]Ton 其中[123]定义一组字符<br>它的意思是匹配1或2或3  因此 1ton 和2ton 都匹配且返回了<br>[] 其实是另一种形式的OR语句<br>[1|2|3]Ton 的缩写 为 [123]Ton<br>1|2|3 Ton 的意思是检索出1或2或3 ton<br>[^123] 匹配除这些字符除外的任何东西<br> ^ 是REGEXP的否定符号<br>在匹配范围中<br>0到9  将由[0123456789] 等同于 [0-9]<br>.表示匹配一个字符<br>输入 SELECT vend_name FROM vendors WHERE vend_name REGEXP ‘.’ ORDER BY vend_name<br>.匹配任意字符  这时每一行都被检索出来 为了匹配特殊字符 必须用\ 作为前导<br>如<br>SELECT vend_name FROM vendors WHERE vend_name REGEXP ‘\.’ ORDER BY vend_name<br>这才是期望的输出 \.匹配. 这种处理就是所谓的转义。<br>？ 字符 ？匹配它前面的任何字符的0次或者1次出现。<br> 如 SELECT prod_name FROM products WHERE prod_name REGEXP ‘\([0-9] sticks?\)’<br> ORDER BY prod_name ;<br>Sticks 匹配 stick 和sticks s后的?使s可选<br>另外例如<br>SELECT prod_name FROM products WHERE prod_name REGEXP ‘[[:digit:]]{4}<br>ORDER BY prod_name；<br>[:digit:]匹配任意数字<br>因而它作为数字的一个集合<br>{4} 确切的要求它前面的字符 出现4次<br>匹配特定位置的文本，需要使用表9-4列出的定位符<br>^ 文本的开始<br>$ 文本的结尾<br>[[:&lt;:]] 词的开始<br>[[:&gt;;]] 词的结尾<br>‘^[0-9\.]’ 找出一个数 包括以小数点开始的数开始的所有产品。<br>SELECT prod_name FROM products WHERE prod_name REGEXP ‘^[0-9\.]’<br>ORDER BY prod_name;</p>
<h2 id="第10章-创建计算字段"><a href="#第10章-创建计算字段" class="headerlink" title="第10章  创建计算字段"></a>第10章  创建计算字段</h2><p>MySQL 使用Concat() 函数来实现<br>SELECT Concat(vend_name,’（‘，vend_country,’）’)<br>FROM vendors ORDER BY vend_name;<br>拼接  将值联结到一起构成单个值<br>比如以上的输出为<br>ACME (USA)<br>删除数据右侧多余的空格来整理数据<br>MySQL 的RTrim()可以去掉值右边的所有的空格<br>SELECT Concat(RTrim(vend_name),’(‘,RTrim(vend_country),’)’)<br>FROM vendors<br>ORDER BY vend_name;<br>LTrim() 去掉串左边的空格<br>Trim()去掉左右俩边的空格<br>SELECT Concat (RTrim(vend_name),’(‘,RTrim(vend_country),’)’)AS vend_title FROM vendors ORDER BY vend_name;<br>一个未命名的列不能用于客户机的应用中，因为客户机没有办法去引用它。<br>所以才出现了别名。AS 关键字来赋予别名 任何客户机应用都可以按名来引用这个列，就像它是一个实际的表列一样。</p>
<p>执行算数运算<br>SELECT pro_id,quantity,item_price FROM oderitems WHERE order order_num =20005;<br>在算数运算中 检索200005中的所有物品<br>如果要计算汇总物品的价格<br>SELECT prod_id ,quantity,item_price, quantity*item_price  AS expanded_price FROM oderitems WHERE order_num =20005;<br>此时客户机可以使用这个新计算的列，就像其他列一样。<br>MYSQL 支持基本算术运算符</p>
<h2 id="第十一章-使用数据来处理函数"><a href="#第十一章-使用数据来处理函数" class="headerlink" title="第十一章 使用数据来处理函数"></a>第十一章 使用数据来处理函数</h2><p>SELECT vend_name,Upper(vend_name) AS  vend_name_upcase FROM vendors ORDER BY vend_name;<br>Upper()将文本转换为大写<br>常用的文本处理函数：<br>Left() 返回串左边的字符<br>Length() 返回串的长度<br>Locate()返回串的一个子串<br>Lower()将串转换为小写<br>LTrim() 去掉左边的空格<br>Right()返回串右边的字符<br>RTrim() 去掉串右边的空格<br>Soundex()返回串的Soundex值<br>SubString() 返回子串的字符<br>Upper() 大写<br>Soundex（） 将任何文本串转换为描述其语音表示的字母数字模式的算法<br>如<br>SELECT cust_name ,cust_contact FROM customers WHERE cust_contact =’Y.Lie’;<br>其联系名是为Y.Lee 此时没办法搜索到<br>但是通过<br>SELECT cust_name,cust_contact FROM customers WHERE Soundex(cust_contact)=Soundex(‘Y.lie);<br>此时可以搜索到Y.Lee<br>日期和时间的处理函数<br>Date() 返回日期部分的日期部分<br>Year() 返回日期部分的年份部分<br>Day()<br>Month()</p>
<p>如：<br>SELECT cust_id,oder_num FROM oders WHERE Date(order_date)=’2005-09-01’;<br>SELECT cust_id,order_num FROM orders WHERE Date(order_date) BETWEEN ‘2005-09-01’AND’2005-03-30’;<br>数值处理函数<br>Abs() 返回数的绝对值</p>
<p>Cos() 角度的余弦<br>Exp() 返回一个数的指数值<br>Mod() 操作数的余数<br>……</p>
<h2 id="第12章-汇总数据"><a href="#第12章-汇总数据" class="headerlink" title="第12章 汇总数据"></a>第12章 汇总数据</h2><p>12.1 聚集函数  运行在行组上，计算和返回单个值得函数<br>AVG() 返回某列的平均值<br>COUNT()  返回某列的行数<br>MAX() 返回某列的最大值<br>MIN() 返回某列的最小值<br>SUM() 返回某列值之和<br>SELECT AVG(prod_price) AS avg_price FROM products;<br>AVG() 也可以用来确定列或行当平均值<br>SELECT AVG(prod_price) AS avg_price FROM products WHERE vend_id =1003;<br>COUNT () 函数<br>COUNT(<em>)对表中的行的数目进行技术<br>COUNT(column) 对特定列中具有值的行进行计数<br>例如SELECT COUNT(</em>) AS num_cust FROM customers;<br>利用COUNT(*)对所有行计数<br>SELECT COUNT(cust_email) AS num_cust FROM customers;<br>对于cust_email中所有有值的行进行计数<br>MAX() 指定列中的最大值 MAX()要求指定列名。<br>MIN()<br>SUM() 也可以用来合计计算值 用来得出总的订单金额<br>SELECT SUM(item_price  *quantity) AS total_price FROM oderitems WHERE order_num=20005;<br>SUM(item_price *quantity) 返回订单中所有物品价钱之和</p>
<h2 id="第13章-分组数据"><a href="#第13章-分组数据" class="headerlink" title="第13章 分组数据"></a>第13章 分组数据</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT vend_id ,COUNT(*) AS num_prods FROM products GROUP BY vend_id;</span><br></pre></td></tr></table></figure>

<p>Vend_id num_prods<br>1001        3<br>1002        2<br>1003        7<br>1005        2<br>上述语句将vend_id进行分组，GROUP BY 对于分组的整个结果集进行聚集<br>使用ROLLUP 使用WITH ROLLUP 关键字，将得到每个分组以及分组汇总级别的值<br>2如何过滤分组?<br>HAVING<br>如： SELECT cust_id ,COUNT(<em>)AS orders FROM orders GROUP BY cust_id<br>HAVING COUNT(</em>) &gt;=2<br>它过滤COUNT(<em>)&gt;=2 的那些分组<br>输入： SELECT vend_id,COUNT(</em>) AS num_prods FROM products WHERE prod_price &gt;=10<br>GROUP BY vend_id HAVING COUNT(*)&gt;=2;<br>13.4 分组和排序<br>GROUP BY 和ORDER BY<br>GROUP BY  是在ORDER BY 之前，在where 之后</p>
<h1 id="group-by-和-order-by-的区别-理解过程"><a href="#group-by-和-order-by-的区别-理解过程" class="headerlink" title="group by 和 order by 的区别 + 理解过程"></a>group by 和 order by 的区别 + 理解过程</h1><p><a href="https://blog.csdn.net/sinat_40692412/article/details/81200133">https://blog.csdn.net/sinat_40692412/article/details/81200133</a></p>
<h2 id="第14章-子查询"><a href="#第14章-子查询" class="headerlink" title="第14章 子查询"></a>第14章 子查询</h2><p>子查询：嵌套在其他查询中的查询<br>1 检索包含物品TNT2 的所有订单的编号<br> SELECT order_num FROM orderitems WHERE prod_id =’TNT2’；<br>2 检索具有前一步骤列出的订单编号的所有客户的ID<br> SELECT cust_id FROM orders WHERE order_num IN (20005,20007);<br>3 现在把第一个查询变为子查询 组合成俩个查询：<br> SELECT cust_id FROM oders WHERE order_num IN (SELECT order_num FROM orderitems WHERE prod_id =’TNT2’);<br>在SELECT 语句中，子查询总是从内向外查询处理。<br>检索这些客户的ID的客户信息，检索俩列的SQL语句为：<br>SELECT cust_name, cust_contact FROM customers WHERE cust_id IN (10001,10004);<br>则可以转换为：<br>SELECT cust_name ,cust_contact FROM customers WHERE cust_id IN (SELECT cust_id FROM orders WHERE order_num IN (SELECT order_num FROM orderitems WHERE prod_Id =’TNT2’))；<br>计算结果子查询：<br>SELECT cust_name,cust_state,(SELECT COUNT(*) FROM oders WHERE orders.cust_id=customers.cust_id)AS orders FROM customers ORDER BY cust_name;</p>
<h2 id="第15-章-联结表-join-表"><a href="#第15-章-联结表-join-表" class="headerlink" title="第15 章  联结表  join 表"></a>第15 章  联结表  join 表</h2><p>外键位某个表中的一列 它包含另一个表的主键值定义了俩个表之间的关系。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT vent_name,prod_name,prod_price </span><br><span class="line">FROM vendors ,products </span><br><span class="line">WHERE vendors.vend_id&#x3D;products.vend_id;</span><br><span class="line">ORDER BY vend_name,prod_name ;</span><br></pre></td></tr></table></figure>

<p>此种方法通过WHERE子句来限定了列名 ，如果要给出 vend_id 那么mysql_id 并不知道是哪个<br>存在一种状况是<br>笛卡尔积：<br>在不指定where子句时</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT vend_name ,prod_name,prod_price </span><br><span class="line">FROM vendors,products ORDER BY vend_name,prod_name;</span><br></pre></td></tr></table></figure>

<h3 id="15-2-2-内部联结"><a href="#15-2-2-内部联结" class="headerlink" title="15.2.2 内部联结"></a>15.2.2 内部联结</h3><p>目前为止所使用的联结称为 等值联结  它基于俩个表之间的相等测试 这种联结也叫内部联结。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT vend_name , prod_name , prod_price FROM vendors INNER JOIN products ON vendors.vend_id &#x3D;products.vend_id ;</span><br></pre></td></tr></table></figure>

<p>此时使用的是INNER JOIN  联结条件用的是ON</p>
<h3 id="联结多个表："><a href="#联结多个表：" class="headerlink" title="联结多个表："></a>联结多个表：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT prod_name,vend_name,prod_price,quantity FROM orderitems,products,vendors WHERE products.vend_id &#x3D;vendors.vend_id AND orderitems.prod_id &#x3D;products.prod_id AND order_num &#x3D;20005;</span><br></pre></td></tr></table></figure>



<h2 id="第16章-创建高级联结"><a href="#第16章-创建高级联结" class="headerlink" title="第16章 创建高级联结"></a>第16章 创建高级联结</h2><h3 id="使用表别名"><a href="#使用表别名" class="headerlink" title="使用表别名"></a>使用表别名</h3><p>SELECT Concat(RTrim(vend_name)，‘（’，RTrim（vend_country）,’）’) AS vend_title FROM vendors ORDER BY vend_name;</p>
<h3 id="内部联结："><a href="#内部联结：" class="headerlink" title="内部联结："></a>内部联结：</h3><p>它基于俩个表之间的相等测试<br>SELECT vend_name .prod_name,prod_price FROM vendors INNER JOIN products ON vendors.vend_id =produces.vend_id;</p>
<h3 id="自联结：-引用别名，自己联结自己"><a href="#自联结：-引用别名，自己联结自己" class="headerlink" title="自联结： 引用别名，自己联结自己"></a>自联结： 引用别名，自己联结自己</h3><p>SELECT p1.prod_id,p1.prod_name FROM products AS p1,products AS p2<br>WHERE p1.vend_id =p2.vend_id AND p2.prod_id =’DTNTR’;<br>此查询种需要的俩个表实际上是相同的表。<br>因此products 表在from 子句中出现了俩次。虽然这是合法的，但是对products 的引用具有二义性。因此使用了别名。（用自联结而不用子查询。有时候处理联结要比处理查询要快的多）</p>
<h3 id="自然联结："><a href="#自然联结：" class="headerlink" title="自然联结："></a>自然联结：</h3><p>其中你只能选择那些唯一的列。<br>通过对表使用通配符（SELECT <em>）对所有其他表的列使用明确的子集来完成的。</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT c.*,o.ordr_num,o.order_date,oi.prod_id,oi.quantity,OI.item_price FROM customers AS c,orders AS o,orderitems AS oi WHERE c.cust_id &#x3D;o.cust_id AND oi.order_num &#x3D;o.order_num</span><br><span class="line">AND prod_id &#x3D;’FB’;</span><br></pre></td></tr></table></figure>


<p>通配符只对第一个表使用，所有其他列明确列出，所以没有重复的列被检索出来。</p>
<h3 id="外部联结："><a href="#外部联结：" class="headerlink" title="外部联结："></a>外部联结：</h3><p>许多联结将一个表中的行与另外一个表中的行相关联，但有时候会需要包含没有关联行的那些行，例如  可能需要使用联结来完成以下的工作：<br>1对每个客户下了多少订单进行计数，包括那些至今未下订单的客户。<br>2列出所有产品以及订购数量，包括没有人订购的产品<br>3计算平均销售规模，包括那些至今未下订单的客户<br>联结包含了那些在相关表中没有关联行的行，这种叫做外部联结<br>内部联结检索所有客户及其订单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT customers.cust_id,order.orders.order_num FROM customers INNER JOIN orders ON</span><br><span class="line">Customers.cust_id &#x3D;orders.cust_id;</span><br></pre></td></tr></table></figure>

<h3 id="外部联结：-1"><a href="#外部联结：-1" class="headerlink" title="外部联结："></a>外部联结：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT customers.cust_id ,orders.order_num FROM customers LEFT OUTER JOIN oders </span><br><span class="line">ON customers.cust_id &#x3D;orders.cust_id;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cust_id   order_num</span><br><span class="line"> 10001      20005</span><br><span class="line"> 10001      20009</span><br><span class="line"> 10002       null</span><br><span class="line">10003       null</span><br></pre></td></tr></table></figure>

<p>此时必须要用RIGHT 或LEFT 关键字指定包括其所有行的表<br>其实就是左外部联结和右外部联结</p>
<p>此时必须要用RIGHT 或LEFT 关键字指定包括其所有行的表<br>其实就是左外部联结和右外部联结</p>
<h3 id="16-3-使用带聚集函数的联结"><a href="#16-3-使用带聚集函数的联结" class="headerlink" title="16.3 使用带聚集函数的联结"></a>16.3 使用带聚集函数的联结</h3><p>使用了COUNT（）函数的联结<br>SELECT customers.cust_name, customers.cust_id,COUNT(orders.order_num) AS num_ord FROM customers INNER JOIN orders ON customers.cust_id =orders.cust_id GROUP BY customers.cust_id;<br>SELECT 语句使用INNER JOIN 将customers和orders 表互相关联。 GROUP BY 子句按客户分组数据。<br>聚集函数也可以方便地与其他联结一起使用，<br>如 SELECT customers,cust_name,cusomers,cust_id,COUNT(orders,order_num)AS num_ord FROM customers LEFT OUTER JOIN orders ON customers.cust_id =orders.cust_id  GROUP BY customers.cust_id;</p>
<h2 id="17-章-组合查询"><a href="#17-章-组合查询" class="headerlink" title="17 章 组合查询"></a>17 章 组合查询</h2><p>利用UNION 操作符将多条SELECT 语句组合成一个结果集<br>执行多个查询，多个SELECT 语句 并将结果作为单个查询结果集返回。<br>这种称为并（union）或复合查询<br>使用UNION<br>输入<br>SELECT vend_id ,prod_id ,prod_price FROM products WHERE prod_price &lt;=5<br>UNION<br>SELECT vend_id,prod_id,prod_price FROM products WHERE vend_id IN(1001,1002);<br>也可以使用多个where<br>SELECT vend_id ,prod_id,prod_price FROM products WHERE prod_price &lt;=5 OR vend_id IN<br>(1001,1002);<br>从多个表中检索数据的情形，使用UNION 可能会处理更简单。<br>17.2.2 UNION 规则<br> 1   UNION 的每个查询必须包含相同的列，表达式，或聚集函数</p>
<p> 2   UNION 的默认行为，如果想返回所有匹配行 可以使用UNION ALL 而不是UNION<br> 17.2.4 对组合查询结果排序<br>SELECT vend_id ,prod_id,prod_price FROM products WHERE prod_price &lt;=5<br>UNION<br>SELECT vend_id,prod_id,prod_price FROM products WHERE vend_id IN (1001,1002)<br>ORDER BY vend_id ,prod_price ;</p>
<h2 id="18章-全文本搜素"><a href="#18章-全文本搜素" class="headerlink" title="18章 全文本搜素"></a>18章 全文本搜素</h2><p>18.1 理解全文本搜素</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql索引相关</title>
    <url>/2020/06/02/mysql%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍mysql索引相关。</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-在什么情况下建立索引"><a href="#1-在什么情况下建立索引" class="headerlink" title="1 在什么情况下建立索引"></a>1 在什么情况下建立索引</h3><p>1 在经常需要搜索的列上，可以加快搜索的速度；<br>2 在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；<br>3 在经常用于连接两张表的列上，这些列主要是一些外键，可以加快连接的速度；<br>4 在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；<br>5 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；<br>6  在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</p>
<h3 id="2-数据库索引的优缺点，以及什么时候数据库索引失效"><a href="#2-数据库索引的优缺点，以及什么时候数据库索引失效" class="headerlink" title="2 数据库索引的优缺点，以及什么时候数据库索引失效"></a>2 数据库索引的优缺点，以及什么时候数据库索引失效</h3><p>索引的优点：</p>
<p>1 索引大大减少了服务器需要扫描的数据量</p>
<p>2 索引可以帮助服务器避免排序和临时表</p>
<p>3 索引可以将随机I/O变为顺序I/O</p>
<p>索引的缺点</p>
<p>1.创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加</p>
<p>2.索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大</p>
<p>3.当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度</p>
<h3 id="3-索引的类型（普通、唯一、主键、组合、全文）"><a href="#3-索引的类型（普通、唯一、主键、组合、全文）" class="headerlink" title="3 索引的类型（普通、唯一、主键、组合、全文）"></a>3 索引的类型（普通、唯一、主键、组合、全文）</h3><h3 id="4-索引优化（最左前缀原则）"><a href="#4-索引优化（最左前缀原则）" class="headerlink" title="4 索引优化（最左前缀原则）"></a>4 索引优化（最左前缀原则）</h3><h3 id="5-数据库中的索引结构"><a href="#5-数据库中的索引结构" class="headerlink" title="5 数据库中的索引结构"></a>5 数据库中的索引结构</h3><ol>
<li><p>InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</p>
</li>
<li><p>InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；  </p>
</li>
<li><p>InnoDB 是聚集索引，MyISAM 是非聚集索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。 </p>
</li>
<li><p>InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；    </p>
</li>
</ol>
<p>\5. InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql更新和删除数据</title>
    <url>/2020/05/07/mysql%E6%9B%B4%E6%96%B0%E5%92%8C%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍如何利用UPDATA和DELETE语句进一步操控表数据</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><ul>
<li>更新特定行</li>
<li>更新所有行 <strong>特别注意不要省略WHERE子句 稍不注意就会更新表中的所有行</strong></li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">UPDATA customers SET cust_email ='elmer@gmail.com' WHERE cust_id =10005;</span><br></pre></td></tr></table></figure>

<p>更新多个列： 用逗号分隔</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UPDATE customers SET cust_name='The Fudds',</span><br><span class="line">cust_email='elmer@gmail.com'</span><br><span class="line">WHERE cust_id =<span class="number">10005</span>;</span><br></pre></td></tr></table></figure>

<h3 id="IGNORE关键字"><a href="#IGNORE关键字" class="headerlink" title="IGNORE关键字"></a>IGNORE关键字</h3><p>如果用UPDATE 语句更新多行，并且在更新这些行中的一行或多行时出现一个现错误，则整个UPDATE操作被取消。</p>
<p>为即使是发生错误，也继续进行更新可以使用<strong>IGNORE</strong>关键字</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UPDATE IGNORE customers...</span><br></pre></td></tr></table></figure>

<h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><ul>
<li>从表中删除特定的行</li>
<li>从表中删除所有行  <strong>不要省略WHERE子句</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DELETE FROM customers WHERE cust_id =<span class="number">10006</span>;</span><br></pre></td></tr></table></figure>

<h3 id="更快的删除"><a href="#更快的删除" class="headerlink" title="更快的删除"></a>更快的删除</h3><p>如果想删除所有行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TRUNCATE TABLE</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql联结表</title>
    <url>/2020/05/08/mysql%E8%81%94%E7%BB%93%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍联结以及高级联结。</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="创建联结"><a href="#创建联结" class="headerlink" title="创建联结"></a>创建联结</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SELECT vent_name,prod_name,prod_price </span><br><span class="line">FROM vendors ,products </span><br><span class="line">WHERE vendors.vend_id=products.vend_id;</span><br><span class="line">ORDER BY vend_name,prod_name ;</span><br></pre></td></tr></table></figure>

<h2 id="内部联结"><a href="#内部联结" class="headerlink" title="内部联结"></a>内部联结</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SELECT vend_name , prod_name , prod_price FROM vendors INNER JOIN products ON vendors.vend_id =products.vend_id ;</span><br></pre></td></tr></table></figure>

<p>此时使用的是INNER JOIN 联结条件用的是ON</p>
<p>联结多个表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SELECT prod_name,vend_name,prod_price,quantity FROM orderitems,products,vendors WHERE products.vend_id =vendors.vend_id AND orderitems.prod_id =products.prod_id AND order_num =<span class="number">20005</span>;</span><br></pre></td></tr></table></figure>

<h2 id="创建高级联结"><a href="#创建高级联结" class="headerlink" title="创建高级联结"></a>创建高级联结</h2><h3 id="使用表别名"><a href="#使用表别名" class="headerlink" title="使用表别名"></a>使用表别名</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SELECT <span class="title">Concat</span><span class="params">(RTrim(vend_name)，‘（’，RTrim（vend_country）,’）’)</span> AS vend_title FROM vendors ORDER BY vend_name</span>;</span><br></pre></td></tr></table></figure>

<h3 id="内部联结："><a href="#内部联结：" class="headerlink" title="内部联结："></a>内部联结：</h3><p>它基于俩个表之间的相等测试</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SELECT vend_name .prod_name,prod_price FROM vendors INNER JOIN products ON vendors.vend_id =produces.vend_id;</span><br></pre></td></tr></table></figure>

<h3 id="自联结：-引用别名，自己联结自己"><a href="#自联结：-引用别名，自己联结自己" class="headerlink" title="自联结： 引用别名，自己联结自己"></a>自联结： 引用别名，自己联结自己</h3><p>假如你发现某物品（其ID为DTNRT)存在问题，因此想知道生产该物品的供应商生产的其他物品是否也存在这些问题。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SELECT p1.prod_id,p1.prod_name FROM products AS p1,products AS p2</span><br><span class="line">WHERE p1.vend_id =p2.vend_id AND p2.prod_id =’DTNTR’;</span><br></pre></td></tr></table></figure>

<p>因此products 表在from 子句中出现了俩次。虽然这是合法的，但是对products 的引用具有二义性。因此使用了别名。（用自联结而不用子查询。有时候处理联结要比处理查询要快的多）</p>
<h3 id="自然联结"><a href="#自然联结" class="headerlink" title="自然联结"></a>自然联结</h3><p><strong>自然联结的意思是排除多次出现，使每个列只返回一次。</strong></p>
<p><strong>我们建立的每个内部联结都是自然联结。</strong></p>
<p>示例通过对表使用通配符（SELECT *）对所有其他表的列使用明确的子集来完成的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SELECT c.*,o.ordr_num,o.order_date,oi.prod_id,oi.quantity,OI.item_price FROM customers AS c,orders AS o,orderitems AS oi WHERE c.cust_id =o.cust_id AND oi.order_num =o.order_num</span><br><span class="line">AND prod_id =’FB’;</span><br></pre></td></tr></table></figure>

<p>通配符只对第一个表使用，所有其他列明确列出，但没有重复的列被检索出来。</p>
<h3 id="外部联结："><a href="#外部联结：" class="headerlink" title="外部联结："></a>外部联结：</h3><p><strong>许多联结将一个表中的行与另外一个表中的行相关联，但有时候会需要包含没有关联行的那些行，</strong>例如 可能需要使用联结来完成以下的工作：</p>
<ul>
<li>对每个客户下了多少订单进行计数，包括那些至今未下订单的客户。</li>
<li>列出所有产品以及订购数量，包括没有人订购的产品</li>
<li>计算平均销售规模，包括那些至今未下订单的客户</li>
</ul>
<p><strong>联结包含了那些在相关表中没有关联行的行，这种叫做外部联结</strong>     </p>
<p>内部联结检索所有客户及其订单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT customers.cust_id,order.orders.order_num FROM customers INNER JOIN orders ON</span><br><span class="line">Customers.cust_id &#x3D;orders.cust_id;</span><br></pre></td></tr></table></figure>

<p>外部联结：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SELECT customers.cust_id ,orders.order_num FROM customers LEFT OUTER JOIN oders </span><br><span class="line">ON customers.cust_id =orders.cust_id;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cust_id   order_num</span><br><span class="line"> 10001      20005</span><br><span class="line"> 10001      20009</span><br><span class="line"> 10002       null</span><br><span class="line"> 10003       null</span><br></pre></td></tr></table></figure>

<p>此时必须要用RIGHT 或LEFT 关键字指定包括其所有行的表，如果是<strong>LEFT</strong>，就<strong>指出包括OUTER JOIN左边表的所有行</strong>。示例是包括（customers)表种所有行。</p>
<p>其实就是左外部联结和右外部联结</p>
<h3 id="使用带聚集函数的联结"><a href="#使用带聚集函数的联结" class="headerlink" title="使用带聚集函数的联结"></a>使用带聚集函数的联结</h3><p>使用了COUNT（）函数的联结</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT customers.cust_name, customers.cust_id,COUNT(orders.order_num) AS num_ord FROM customers INNER JOIN orders ON customers.cust_id &#x3D;orders.cust_id GROUP BY customers.cust_id;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT customers,cust_name,cusomers,cust_id,COUNT(orders,order_num)AS num_ord FROM customers LEFT OUTER JOIN orders ON customers.cust_id &#x3D;orders.cust_id  GROUP BY customers.cust_id;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql范式</title>
    <url>/2020/06/02/mysql%E8%8C%83%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍mysql范式。</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><img src="https://photos.alitaalice.cn/image/20200602155102.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200602155137.png" alt=""></p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql视图</title>
    <url>/2020/05/09/mysql%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍视图究竟是什么，它们怎么样工作，何时使用它们。</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>视图是 虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT cust_name ,cust_contact FROM customers ,orders ,orderitems WHERE customers.cust_id&#x3D;orders.cust_id  AND orderitems.order_num &#x3D;orders.order_num</span><br><span class="line">AND prod_id &#x3D;&#39;TNT2&#39;;</span><br></pre></td></tr></table></figure>

<p>假设把整个查询包装成一个名叫productcustomers的虚拟表，则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT cust_name,cust_contact FROM productcustomers WHERE prod_id&#x3D;&#39;TNT2&#39;;</span><br></pre></td></tr></table></figure>

<h3 id="为什么使用视图"><a href="#为什么使用视图" class="headerlink" title="为什么使用视图"></a>为什么使用视图</h3><ul>
<li>重用SQL 语句</li>
<li>简化复杂的SQL语句，在编写查询后，可以方便地重用它而不必知道它的基本查询细节。</li>
<li>使用表的组成部分而不是整个表</li>
<li>保护数据，可以给用户授予表的特定部分的访问权限，而不是整个表的访问权限。</li>
<li>更改数据格式和表示。</li>
</ul>
<h3 id="视图的规则和限制"><a href="#视图的规则和限制" class="headerlink" title="视图的规则和限制"></a>视图的规则和限制</h3><ul>
<li>视图必须唯一命名</li>
<li>对于创建的视图数目没有限制</li>
<li>视图可以嵌套</li>
<li>视图不能索引，不能有关联的触发器或者默认值</li>
</ul>
<h3 id="使用视图"><a href="#使用视图" class="headerlink" title="使用视图"></a>使用视图</h3><ul>
<li>视图用CREATE VIEW 来创建 </li>
<li>使用SHOW CREATE VIEW viewname; 来查看创建视图的语句</li>
<li>用DROP 来删除视图。语法为DROP VIEW viewname;</li>
<li>更新视图时，可以 先用DROP 再用CREATE  也可以直接使用CREATE OR REPLACE VIEW</li>
<li>可以先用DROP 再用 CREATE  也可以直接用CREATE OR REPLACE VIEW</li>
</ul>
<h3 id="利用视图简化复杂的联结"><a href="#利用视图简化复杂的联结" class="headerlink" title="利用视图简化复杂的联结"></a>利用视图简化复杂的联结</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CREATE VIEW productcustomers AS SELECT cust_name,cust_contact,prod_id</span><br><span class="line">FROM customers,orders,orderitems WHERE customers.cust_id=orders.cust_id</span><br><span class="line">AND orderitems.order_num =orders.order_name;</span><br></pre></td></tr></table></figure>

<p>那么为了检索订购产品的TNT2客户</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">SELECT cust_name,cust_contact FROM productcustomers WHERE prod_id ='TNT2';</span><br></pre></td></tr></table></figure>

<h3 id="使用视图重新格式化检索出的数据"><a href="#使用视图重新格式化检索出的数据" class="headerlink" title="使用视图重新格式化检索出的数据"></a>使用视图重新格式化检索出的数据</h3><p>下面的SELECT  语句在单个组合计算列中返回供应商名和位置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SELECT <span class="title">Concat</span><span class="params">(RTrim(vend_name),<span class="string">'('</span>,RTrim(vend_country),<span class="string">')'</span>)</span> AS vend_title</span></span><br><span class="line"><span class="function">FROM vendors</span></span><br><span class="line"><span class="function">ORDER BY vend_name</span>;</span><br><span class="line"><span class="comment">/*out </span></span><br><span class="line"><span class="comment">    vend_title</span></span><br><span class="line"><span class="comment">    ACME  (USA)</span></span><br><span class="line"><span class="comment">    Jet Set (England)</span></span><br><span class="line"><span class="comment">    LT Supplies (USA)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>现在，假如经常需要这个格式的结果，不必在每次需要时执行联结，创建一个视图</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">CREATE VIEW vendorlocations AS SELECT <span class="title">Concat</span><span class="params">(RTrim(vend_name),<span class="string">'('</span>,RTrim(vend_country),<span class="string">')'</span>)</span> AS vend_title</span></span><br><span class="line"><span class="function">FROM vendors</span></span><br><span class="line"><span class="function">ORDER BY vend_name</span>;</span><br></pre></td></tr></table></figure>

<p>now </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM vendorlocations;</span><br></pre></td></tr></table></figure>

<h3 id="使用视图过滤不想要的数据"><a href="#使用视图过滤不想要的数据" class="headerlink" title="使用视图过滤不想要的数据"></a>使用视图过滤不想要的数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE VIEW customeremaillist AS SELECT cust_id,cust_name,cust_email FROM customers WHERE cust_email IS NOT NULL;</span><br></pre></td></tr></table></figure>

<p>在发送电子邮件到邮件列表时，需要排除没有电子邮件地址的用户</p>
<p>现在，可以像使用其他表一样使用视图customeremaillist </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM customeremaillist;</span><br></pre></td></tr></table></figure>

<h3 id="使用视图与计算字段"><a href="#使用视图与计算字段" class="headerlink" title="使用视图与计算字段"></a>使用视图与计算字段</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SELECT prod_id,</span><br><span class="line">       quantity,</span><br><span class="line">       item_price,</span><br><span class="line">       quantity*item_price AS expanded_price</span><br><span class="line">FROM orderitems</span><br><span class="line">WHERE order_num =<span class="number">20005</span>;</span><br></pre></td></tr></table></figure>

<p>现在转换为视图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE VIEW orderitemsexpanded AS </span><br><span class="line">SELECT order_num,</span><br><span class="line">       prod_id,</span><br><span class="line">       quantity,</span><br><span class="line">       item_price,</span><br><span class="line">       quantity*item_price AS expanded_price</span><br><span class="line">FROM orderitems;</span><br></pre></td></tr></table></figure>

<p>检索订单20005的详细内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM orderitemsexpanded WHERE order_num &#x3D;20005;</span><br></pre></td></tr></table></figure>

<h3 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h3><p>视图是可更新的，更新一个视图将更新其基表。如果你对视图增加或者删除行，实际上是对其基表增加或者删除行。</p>
<p>但是并非所有的视图都是可更新的</p>
<ul>
<li>分组 （使用GROUP BY 和 HAVING )</li>
<li>联结</li>
<li>子查询</li>
<li>并</li>
<li>聚集函数 （Min() ,Count(),Sum() 等）；</li>
<li>DISTINCT;  （用于返回不重复的值 ，select distinct name,id from A</li>
<li>导出（计算）列</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>redis_list类型详解</title>
    <url>/2020/08/18/redis-list%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍redis_list类型详解</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; LPUSH list one   <span class="comment">#将一个值或者多个值，插入到列表头部</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; LPUSH list two</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; lpush list three</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">"three"</span></span><br><span class="line">2) <span class="string">"two"</span></span><br><span class="line">3) <span class="string">"one"</span></span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 1</span><br><span class="line">1) <span class="string">"three"</span></span><br><span class="line">2) <span class="string">"two"</span></span><br><span class="line">127.0.0.1:6379&gt; rpush list right   <span class="comment">#从右侧插入list</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">"three"</span></span><br><span class="line">2) <span class="string">"two"</span></span><br><span class="line">3) <span class="string">"one"</span></span><br><span class="line">4) <span class="string">"right"</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">"three"</span></span><br><span class="line">2) <span class="string">"two"</span></span><br><span class="line">3) <span class="string">"one"</span></span><br><span class="line">4) <span class="string">"right"</span></span><br><span class="line">127.0.0.1:6379&gt; lpop list </span><br><span class="line"><span class="string">"three"</span></span><br><span class="line">127.0.0.1:6379&gt; rpop list</span><br><span class="line"><span class="string">"right"</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">"two"</span></span><br><span class="line">2) <span class="string">"one"</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lindex list 1    <span class="comment">#通过下标来获取list中的某一个值</span></span><br><span class="line"><span class="string">"one"</span></span><br><span class="line">127.0.0.1:6379&gt; lindex list 0   </span><br><span class="line"><span class="string">"two"</span></span><br><span class="line">127.0.0.1:6379&gt; llen list   <span class="comment">#返回列表的长度</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">"two"</span></span><br><span class="line">2) <span class="string">"one"</span></span><br><span class="line">3) <span class="string">"two"</span></span><br><span class="line">4) <span class="string">"one"</span></span><br><span class="line">127.0.0.1:6379&gt; lrem list 1 two   <span class="comment">#移除指定元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; lrem list 2 one </span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">"two"</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; Rpush mylist <span class="string">"hello"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; Rpush mylist <span class="string">"hello1"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; Rpush mylist <span class="string">"hello2"</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; Rpush mylist <span class="string">"hello3"</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; Rpush mylist <span class="string">"hello4"</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; LTRIM mylist 1 2  <span class="comment">#通过下标截取指定长度</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">"hello1"</span></span><br><span class="line">2) <span class="string">"hello2"</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpoplpush mylist mylist2  <span class="comment">#rpop 后lpush</span></span><br><span class="line"><span class="string">"hello2"</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">"hello1"</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist2 0 -1</span><br><span class="line">1) <span class="string">"hello2"</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">"hello1"</span></span><br><span class="line">127.0.0.1:6379&gt; lset list 0 item     <span class="comment">#lset命令 将指定index替换</span></span><br><span class="line">(error) ERR no such key</span><br><span class="line">127.0.0.1:6379&gt; lset mylist 0 item</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">"item"</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">"item"</span></span><br><span class="line">127.0.0.1:6379&gt; lpush mylist hello</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">"hello"</span></span><br><span class="line">2) <span class="string">"item"</span></span><br><span class="line">127.0.0.1:6379&gt; LINSERT mylist  after <span class="string">"hello"</span> world  <span class="comment">#linsert 在指定字符串前/后 插入</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">"hello"</span></span><br><span class="line">2) <span class="string">"world"</span></span><br><span class="line">3) <span class="string">"item"</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis</title>
    <url>/2020/08/15/redis/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍redis</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="测试性能"><a href="#测试性能" class="headerlink" title="测试性能"></a>测试性能</h2><p>redis-benchmark</p>
<p><img src="https://photos.alitaalice.cn/image/20200815195127.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>默认16个数据库</p>
<p><img src="https://photos.alitaalice.cn/image/20200815200339.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看所有的key</span><br><span class="line">keys *</span><br><span class="line">清除当前数据库</span><br><span class="line">flushdb</span><br><span class="line">清除所有数据库</span><br><span class="line">flushall</span><br></pre></td></tr></table></figure>

<blockquote>
<p>redis 是单线程的！</p>
</blockquote>
<p>redis是很快的，Redis是基于内存操作，cpu不少redis性能瓶颈</p>
<p>redis的瓶颈是根据机器的内存和网络带宽</p>
<p>既然可以使用单线程 就使用单线程 </p>
<blockquote>
<p>Redis 为什么单线程还那么快</p>
</blockquote>
<blockquote>
<p><img src="https://photos.alitaalice.cn/image/20200815210502.png" alt=""></p>
</blockquote>
<p>对于内存系统来说，如果没有上下文切换效率是最高的，多次读写都是在一个CPU上的，在内存情况上，这个是最佳的方案。</p>
<p><img src="https://photos.alitaalice.cn/image/20200816094836.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200816095704.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200816100042.png" alt=""></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key1 <span class="string">"hello,zhangxl"</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line"><span class="string">"hello,zhangxl"</span></span><br><span class="line">127.0.0.1:6379&gt; GETRANGE key1 0 3  截取字符串</span><br><span class="line"><span class="string">"hell"</span></span><br><span class="line">127.0.0.1:6379&gt; GETRANGE key1 0 -1</span><br><span class="line"><span class="string">"hello,zhangxl"</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://photos.alitaalice.cn/image/20200816100459.png" alt=""></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SETEX key3 30 hello  <span class="comment">#设置过期时间</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl key3</span><br><span class="line">(<span class="built_in">integer</span>) 27</span><br><span class="line">127.0.0.1:6379&gt; ttl key3</span><br><span class="line">(<span class="built_in">integer</span>) 21</span><br><span class="line">127.0.0.1:6379&gt; SETNX mykey redis    <span class="comment">#如果mykey不存在 创建mykey</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">"keys"</span></span><br><span class="line">2) <span class="string">"key2"</span></span><br><span class="line">3) <span class="string">"key1"</span></span><br><span class="line">4) <span class="string">"mykey"</span></span><br><span class="line">127.0.0.1:6379&gt; SETNX mykey xx    <span class="comment">#如果mykey存在 创建失败</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; get mykey</span><br><span class="line"><span class="string">"redis"</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MSET k1 v1 k2 v2 k3 v3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get keys *</span><br><span class="line">(error) ERR wrong number of arguments <span class="keyword">for</span> <span class="string">'get'</span> <span class="built_in">command</span></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">"k1"</span></span><br><span class="line">2) <span class="string">"k3"</span></span><br><span class="line">3) <span class="string">"k2"</span></span><br><span class="line">127.0.0.1:6379&gt; mget k1 k2 k3  <span class="comment">#同时获取多个值</span></span><br><span class="line">1) <span class="string">"v1"</span></span><br><span class="line">2) <span class="string">"v2"</span></span><br><span class="line">3) <span class="string">"v3"</span></span><br><span class="line">127.0.0.1:6379&gt; msetnx k1 v1 k4 v4 <span class="comment">#msetnx 是一个原子性的操作</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; get k4</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getset db redis   <span class="comment">#get and set操作</span></span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get db</span><br><span class="line"><span class="string">"redis"</span></span><br><span class="line">127.0.0.1:6379&gt; getset db mongodb</span><br><span class="line"><span class="string">"redis"</span></span><br><span class="line">127.0.0.1:6379&gt; get db</span><br><span class="line"><span class="string">"mongodb"</span></span><br></pre></td></tr></table></figure>

<p>String 类似的使用场景 </p>
<ul>
<li>value </li>
<li>统计多单位的数量  </li>
<li>粉丝数</li>
<li>对象缓存存储</li>
</ul>
]]></content>
      <categories>
        <category>nosql</category>
      </categories>
      <tags>
        <tag>nosql</tag>
      </tags>
  </entry>
  <entry>
    <title>springmvc的原理</title>
    <url>/2020/06/13/springmvc%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍springmvc的原理</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>1、客户端发出一个http请求给web服务器，web服务器对http请求进行解析，如果匹配DispatcherServlet的请求映射路径（在web.xml中指定），web容器将请求转交给DispatcherServlet.</p>
<p>2、DipatcherServlet接收到这个请求之后将根据请求的信息（包括URL、Http方法、请求报文头和请求参数Cookie等）以及HandlerMapping的配置找到处理请求的处理器（Handler）。</p>
<p>3-4、DispatcherServlet根据HandlerMapping找到对应的Handler,将处理权交给Handler（Handler将具体的处理进行封装），再由具体的HandlerAdapter对Handler进行具体的调用。</p>
<p>5、Handler对数据处理完成以后将返回一个ModelAndView()对象给DispatcherServlet。</p>
<p>6、Handler返回的ModelAndView()只是一个逻辑视图并不是一个正式的视图，DispatcherSevlet通过ViewResolver将逻辑视图转化为真正的视图View。</p>
<p>7、Dispatcher通过model解析出ModelAndView()中的参数进行解析最终展现出完整的view并返回给客户端。</p>
]]></content>
      <categories>
        <category>springmvc</category>
      </categories>
      <tags>
        <tag>springmvc</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot中controller的使用</title>
    <url>/2020/06/12/springboot%E4%B8%ADcontroller%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍springboot中controller的使用</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>1 </p>
<p><img src="https://photos.alitaalice.cn/image/20200613091901.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200613092010.png" alt=""></p>
<p><img src="C:%5CUsers%5C16508%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200613092031562.png" alt="image-20200613092031562"></p>
<p><img src="https://photos.alitaalice.cn/image/20200613092049.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200613092100.png" alt="">-</p>
<h1 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h1><p>@RequestBody主要用来json转换为java对象。 前台向后台传数据</p>
<p>@ResponseBody的作用其实是将java对象转为json格式的数据。后台传前台。</p>
<h1 id="model-attribute-的作用"><a href="#model-attribute-的作用" class="headerlink" title="model.attribute()的作用"></a>model.attribute()的作用</h1><p>1.往前台传数据，可以传对象，可以传List，通过el表达式 ${}可以获取到，</p>
<p>类似于request.setAttribute(“sts”,sts)效果一样。</p>
<p>2.@ModelAttribute(“model”)  注解</p>
]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>stream</title>
    <url>/2020/07/09/stream/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
  </entry>
  <entry>
    <title>spring常用注解</title>
    <url>/2020/06/04/spring%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍spring常用注解。</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>Spring部分<br>1、声明bean的注解</p>
<p>@Component 组件，没有明确的角色<br>@Service 在业务逻辑层使用（service层）<br>@Repository 在数据访问层使用（dao层）<br>@Controller 在展现层使用，控制器的声明（C）</p>
<p>2、注入bean的注解<br>@Autowired：由Spring提供<br>@Inject：由JSR-330提供<br>@Resource：由JSR-250提供<br>都可以注解在set方法和属性上，推荐注解在属性上（一目了然，少写代码）。</p>
<p>3、java配置类相关注解<br>@Configuration 声明当前类为配置类，相当于xml形式的Spring配置（类上）<br>@Bean 注解在方法上，声明当前方法的返回值为一个bean，替代xml中的方式（方法上）<br>@Configuration 声明当前类为配置类，其中内部组合了@Component注解，表明这个类是一个bean（类上）<br>@ComponentScan 用于对Component进行扫描，相当于xml中的（类上）<br>@WishlyConfiguration 为@Configuration与@ComponentScan的组合注解，可以替代这两个注解</p>
<p>4、切面（AOP）相关注解<br>Spring支持AspectJ的注解式切面编程。<br>@Aspect 声明一个切面（类上）<br>使用@After、@Before、@Around定义建言（advice），可直接将拦截规则（切点）作为参数。<br>@After 在方法执行之后执行（方法上）<br>@Before 在方法执行之前执行（方法上）<br>@Around 在方法执行之前与之后执行（方法上）<br>@PointCut 声明切点<br>在java配置类中使用@EnableAspectJAutoProxy注解开启Spring对AspectJ代理的支持（类上）</p>
<p>5、@Bean的属性支持<br>@Scope 设置Spring容器如何新建Bean实例（方法上，得有@Bean）<br>其设置类型包括：<br>Singleton （单例,一个Spring容器中只有一个bean实例，默认模式）,<br>Protetype （每次调用新建一个bean）,<br>Request （web项目中，给每个http request新建一个bean）,<br>Session （web项目中，给每个http session新建一个bean）,<br>GlobalSession（给每一个 global http session新建一个Bean实例）<br>@StepScope 在Spring Batch中还有涉及<br>@PostConstruct 由JSR-250提供，在构造函数执行完之后执行，等价于xml配置文件中bean的initMethod<br>@PreDestory 由JSR-250提供，在Bean销毁之前执行，等价于xml配置文件中bean的destroyMethod</p>
<p>6、@Value注解<br>@Value 为属性注入值（属性上）<br>支持如下方式的注入：<br>》注入普通字符</p>
<p>》注入操作系统属性</p>
<p>》注入表达式结果</p>
<p>》注入其它bean属性</p>
<p>》注入文件资源</p>
<p>》注入网站资源</p>
<p>》注入配置文件</p>
<p>注入配置使用方法：<br>① 编写配置文件（test.properties）<br>book.name=《三体》<br>② @PropertySource 加载配置文件(类上)</p>
<p>③ 还需配置一个PropertySourcesPlaceholderConfigurer的bean。</p>
<p>7、环境切换<br>@Profile 通过设定Environment的ActiveProfiles来设定当前context需要使用的配置环境。（类或方法上）<br>@Conditional Spring4中可以使用此注解定义条件话的bean，通过实现Condition接口，并重写matches方法，从而决定该bean是否被实例化。（方法上）</p>
<p>8、异步相关<br>@EnableAsync 配置类中，通过此注解开启对异步任务的支持，叙事性AsyncConfigurer接口（类上）<br>@Async 在实际执行的bean方法使用该注解来申明其是一个异步任务（方法上或类上所有的方法都将异步，需要@EnableAsync开启异步任务）</p>
<p>9、定时任务相关<br>@EnableScheduling 在配置类上使用，开启计划任务的支持（类上）<br>@Scheduled 来申明这是一个任务，包括cron,fixDelay,fixRate等类型（方法上，需先开启计划任务的支持）</p>
<p>10、@Enable*注解说明<br>这些注解主要用来开启对xxx的支持。<br>@EnableAspectJAutoProxy 开启对AspectJ自动代理的支持<br>@EnableAsync 开启异步方法的支持<br>@EnableScheduling 开启计划任务的支持<br>@EnableWebMvc 开启Web MVC的配置支持<br>@EnableConfigurationProperties 开启对@ConfigurationProperties注解配置Bean的支持<br>@EnableJpaRepositories 开启对SpringData JPA Repository的支持<br>@EnableTransactionManagement 开启注解式事务的支持<br>@EnableTransactionManagement 开启注解式事务的支持<br>@EnableCaching 开启注解式的缓存支持</p>
<p>11、测试相关注解<br>@RunWith 运行器，Spring中通常用于对JUnit的支持</p>
<p>@ContextConfiguration 用来加载配置ApplicationContext，其中classes属性用来加载配置类</p>
<p>SpringMVC部分<br>@EnableWebMvc 在配置类中开启Web MVC的配置支持，如一些ViewResolver或者MessageConverter等，若无此句，重写WebMvcConfigurerAdapter方法（用于对SpringMVC的配置）。<br>@Controller 声明该类为SpringMVC中的Controller<br>@RequestMapping 用于映射Web请求，包括访问路径和参数（类或方法上）<br>@ResponseBody 支持将返回值放在response内，而不是一个页面，通常用户返回json数据（返回值旁或方法上）<br>@RequestBody 允许request的参数在request体中，而不是在直接连接在地址后面。（放在参数前）<br>@PathVariable 用于接收路径参数，比如@RequestMapping(“/hello/{name}”)申明的路径，将注解放在参数中前，即可获取该值，通常作为Restful的接口实现方法。<br>@RestController 该注解为一个组合注解，相当于@Controller和@ResponseBody的组合，注解在类上，意味着，该Controller的所有方法都默认加上了@ResponseBody。<br>@ControllerAdvice 通过该注解，我们可以将对于控制器的全局配置放置在同一个位置，注解了@Controller的类的方法可使用@ExceptionHandler、@InitBinder、@ModelAttribute注解到方法上，<br>这对所有注解了 @RequestMapping的控制器内的方法有效。<br>@ExceptionHandler 用于全局处理控制器里的异常<br>@InitBinder 用来设置WebDataBinder，WebDataBinder用来自动绑定前台请求参数到Model中。<br>@ModelAttribute 本来的作用是绑定键值对到Model里，在@ControllerAdvice中是让全局的@RequestMapping都能获得在此处设置的键值对。</p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized关键字</title>
    <url>/2020/05/25/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍synchronized关键字</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>转自<a href="https://juejin.im/post/5adf14dcf265da0b7b358d58#heading-10">https://juejin.im/post/5adf14dcf265da0b7b358d58#heading-10</a></p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>substring</title>
    <url>/2020/08/16/substring/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍substring</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>substring(x)是从字符串的的第x个字符截取,到最后；</p>
<p>substring(x,y）是从x到y前的位置停止，含头不含尾</p>
]]></content>
      <categories>
        <category>javase</category>
      </categories>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>tcp/ip</title>
    <url>/2020/07/29/tcp-ip/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍tcp/ip</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>先说一下这些协议，在互联网还没普及时，这些协议就已经出来，随着后来数据日渐丰富，协议种类也在累加。</p>
<p>对于我们来说网络世界丰富多彩，对于互联网来说也就是数据<strong>根据相应的规则</strong>在跑来跑去。（这些规则就是协议）。就像早上你开车到公司，路上遵守交通规则。然后安全抵达公司。就相当于完成了一次信息发送。废话多啦，开始正题！</p>
<p>楼上说的OSI模型是一种接近完美的理论，注意这种模型只出现在教课书里，这种模型是在TCP/IP协议已经成熟之后提出的，可以理解为升级版。但是并没有流行出来，主要有以下几个原因！</p>
<p>1、出现时间较晚。</p>
<p>2、参杂了太多政策的考量，并没有单单从技术角度出发。</p>
<p>3、…………还有几点给忘啦，反正就是没流行起来。</p>
<p>所以网络数据传输是TCP/IP的天下。</p>
<p>TCP/IP协议是一大堆协议的集合，TCP/IP协议分为四层（也就是数据传输一次主要经历以下4个步骤），分别是从上到下为：应用层，传输层，Internet，物理层。</p>
<p>假如你给你的基友发一个消息，数据开始传输，这时数据就要遵循TCP/IP协议啦，你的电脑会做出以下动作，这些动作你是看不到的。</p>
<p><strong>1、应用层先把你的消息进行格式转换,你的消息是文字还是图片，还是成人视频并进行加密等操作交给传输层。（这时的数据单元（单位）是信息）</strong></p>
<p><strong>2、传输层将数据切割成一段一段的，便与传输并往里加上一些标记，比如当前应用的端口号等，交给Internet。（这时的数据单元（单位）是数据流）</strong></p>
<p><strong>3、Internet开始在将数据进行分组，分组头部包含目标地址的IP及一些相关信息交给物理层。（这时的数据单元（单位）是分组）</strong></p>
<p><strong>4、物理层将数据转换为比特流开始查找主机真实物理地址进行校验等操作，校验通过，开始嗖<del>嗖</del>嗖~的住目的地跑。（这时的数据单元（单位）是比特）</strong></p>
<p><strong>到达目的地后，对方设备会将上面的顺序反向的操作一遍，最后呈现出来。</strong></p>
<p><img src="https://photos.alitaalice.cn/image/20200729213124.png" alt=""></p>
<p>1 什么是数据包？</p>
<p>2 什么是数据帧？</p>
<p>TCP:</p>
<p>1 保持会话，服务器端和客户端一直要维持会话，直到通话结束。</p>
<p>2 需要将传输的文件分段，传输时，需要建立会话，进行可靠传输。</p>
<p>3 并且有流量控制功能，如果传输速度过快。控制速度。</p>
<p>UDP：</p>
<p>1 一个数据包就能完成数据通信，不需要建立会话。 不需要分段，不需要流量控制，进行不可靠传输，你没收到，我再传输一遍。比如解析DNS服务器时，如果失败了，再发一次。</p>
<p>​     qq聊天用的也是udp协议  qq传文件用的是tcp协议</p>
<p>2 </p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>tcp三次握手</title>
    <url>/2020/09/09/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>SYN表示建立连接，</p>
<p>FIN表示关闭连接，</p>
<p>ACK表示响应</p>
<p>第一次握手：主机A发送位码为syn＝1，随机回产生seq number=1234567的数据包到服务答器，主机B由SYN=1知道，A要求建立联机；</p>
<p>第二次握手：主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1)，syn=1，ack=1，随机产生seq=7654321的包；<br>第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1，以及位码ack是否为1，若正确，主机A会再发送ack number=(主机B的seq+1)，ack=1，主机B收到后确认seq值与ack=1则连接建立成功。 完成三次握手，主机A与主机B开始传送数据。</p>
]]></content>
  </entry>
  <entry>
    <title>try_catch_finally_return的情况</title>
    <url>/2020/05/28/try-catch-finally-return%E7%9A%84%E6%83%85%E5%86%B5/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍try_catch_finally_return的情况</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">  code</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(ExceptionType e)</span><br><span class="line">&#123;</span><br><span class="line">handler <span class="keyword">for</span> <span class="keyword">this</span> type</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果try 语句块中的任何代码抛出了catch 子句中指定的一个异常类</p>
<p>那么</p>
<p>1程序将跳过try  语句块</p>
<p>2程序将执行catch语句块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String filename)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法的首部添加一个throws说明符，提醒调用者这个方法可能会抛出异常</p>
<h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2><p>代码抛出一个异常时，就会停止处理这个方法中的剩余代码，并且退出这个方法，如果这个方法已经获得了只有它自己知道的一些本地资源，而且这些资源必须清理，finally子句可以解决这个问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">code</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(IOException e)</span><br><span class="line">&#123;</span><br><span class="line">show error message</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">in.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="try-with-resource"><a href="#try-with-resource" class="headerlink" title="try-with-resource"></a>try-with-resource</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">work with the resource</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">close the resource</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*可以用try-with-resource代替 */</span></span><br><span class="line"><span class="keyword">try</span>(Resource res=...)</span><br><span class="line">&#123;</span><br><span class="line">    work with res</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span>块退出时，会自动调用res.close()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JAVASE</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>try_catch</title>
    <url>/2020/08/05/try-catch/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍try_catch</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><a href="https://blog.csdn.net/weixin_42617262/article/details/86554182">https://blog.csdn.net/weixin_42617262/article/details/86554182</a></p>
<p><img src="https://photos.alitaalice.cn/image/20200805163115.png" alt=""></p>
<p>1 throw手动抛出异常，抛出到上层，本层只是抛出，但并不处理</p>
<p>2 throws 声明方法可能要抛出的异常，但是也是抛出到上层。</p>
<p><a href="https://blog.csdn.net/Alexwym/article/details/81239692?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight">https://blog.csdn.net/Alexwym/article/details/81239692?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>try_with_resource</title>
    <url>/2020/08/05/try-with-resource/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
  </entry>
  <entry>
    <title>volatile关键字</title>
    <url>/2020/06/16/volatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>1 </p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>wangqy规划</title>
    <url>/2020/08/14/wangqy%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍wangqy规划</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>1 开学之前问父母异地找工作，要么大四上或者大四下实习</p>
<p>2 考教师资格证和磨练画技</p>
<p>3 明年看一下公务员的情况，或者考编的情况</p>
]]></content>
      <categories>
        <category>人生规划</category>
      </categories>
      <tags>
        <tag>人生规划</tag>
      </tags>
  </entry>
  <entry>
    <title>uml类图</title>
    <url>/2020/08/18/uml%E7%B1%BB%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h1 id="UML类图中箭头和线条的含义和用法"><a href="#UML类图中箭头和线条的含义和用法" class="headerlink" title="UML类图中箭头和线条的含义和用法"></a>UML类图中箭头和线条的含义和用法</h1><p>在学习UML过程中，你经常会遇到UML类图关系，这里就向大家介绍一下UML箭头、线条代表的意义，相信通过本文的介绍你对UML中箭头、线条的意义有更明确的认识。</p>
<p>AD：</p>
<p>本节向大家学习一下UML箭头、线条代表的意义，UML中关系主要有依赖，聚合，合成，泛化和实现等，下面就让我们来看一下这些关系如何用UML箭头和线条来实现。</p>
<p>UML箭头、线条程序</p>
<p><strong>关系</strong></p>
<p>后面的例子将针对某个具体目的来独立地展示各种关系。虽然语法无误，但这些例子可进一步精炼，在它们的有效范围内包括更多的语义。</p>
<p><strong>依赖（Dependency）</strong></p>
<p>实体之间一个“使用”关系暗示一个实体的规范发生变化后，可能影响依赖于它的其他实例（图D）。更具体地说，它可转换为对不在实例作用域内的一个类或对象的任何类型的引用。其中包括一个局部变量，对通过方法调用而获得的一个对象的引用（如下例所示），或者对一个类的静态方法的引用（同时不存在那个类的一个实例）。也可利用“依赖”来表示包和包之间的关系。由于包中含有类，所以你可根据那些包中的各个类之间的关系，表示出包和包的关系。</p>
<p>图D</p>
<p><a href="http://images.51cto.com/files/uploadimg/20100617/1423350.jpg"><img src="http://images.51cto.com/files/uploadimg/20100617/1423350.jpg" alt="img"></a></p>
<p><strong>关联（Association）</strong></p>
<p>实体之间的一个结构化关系表明对象是相互连接的。UML箭头是可选的，它用于指定导航能力。如果没有箭头，暗示是一种双向的导航能力。在Java中，关联（图E）转换为一个实例作用域的变量，就像图E的“Java”区域所展示的代码那样。可为一个关联附加其他修饰符。多重性（Multiplicity）修饰符暗示着实例之间的关系。在示范代码中，Employee可以有0个或更多的TimeCard对象。但是，每个TimeCard只从属于单独一个Employee。</p>
<p>图E</p>
<p><a href="http://images.51cto.com/files/uploadimg/20100617/1423351.jpg"><img src="http://images.51cto.com/files/uploadimg/20100617/1423351.jpg" alt="img"></a></p>
<p><strong>聚合（Aggregation）</strong></p>
<p>聚合（图F）是关联的一种形式，UML箭头代表两个类之间的整体/局部关系。聚合暗示着整体在概念上处于比局部更高的一个级别，而关联暗示两个类在概念上位于相同的级别。聚合也转换成Java中的一个实例作用域变量。7MIrrhk<br>yC7lR#N8j0<br>关联和聚合的区别纯粹是概念上的，而且严格反映在语义上。聚合还暗示着实例图中不存在回路。换言之，只能是一种单向关系。</p>
<p>图F</p>
<p><a href="http://images.51cto.com/files/uploadimg/20100617/1423352.jpg"><img src="http://images.51cto.com/files/uploadimg/20100617/1423352.jpg" alt="img"></a></p>
<p><strong>合成（Composition）</strong></p>
<p>合成（图G）是聚合的一种特殊形式，UML箭头暗示“局部”在“整体”内部的生存期职责。合成也是非共享的。所以，虽然局部不一定要随整体的销毁而被销毁，但整体要么负责保持局部的存活状态，要么负责将其销毁。局部不可与其他整体共享。但是，整体可将所有权转交给另一个对象，后者随即将承担生存期职责。</p>
<p>Employee和TimeCard的关系或许更适合表示成“合成”，而不是表示成“关联”。</p>
<p>图G</p>
<p><a href="http://images.51cto.com/files/uploadimg/20100617/1423353.jpg"><img src="http://images.51cto.com/files/uploadimg/20100617/1423353.jpg" alt="img"></a></p>
<p><strong>泛化（Generalization）</strong></p>
<p>泛化（图H）表示一个更泛化的元素和一个更具体的元素之间的关系。泛化是用于对继承进行建模的UML元素。在Java中，用extends关键字来直接表示这种关系。</p>
<p>图H</p>
<p><a href="http://images.51cto.com/files/uploadimg/20100617/1423354.jpg"><img src="http://images.51cto.com/files/uploadimg/20100617/1423354.jpg" alt="img"></a></p>
<p><strong>实现（Realization）</strong></p>
<p>实例（图I）关系UML箭头指定两个实体之间的一个合同。换言之，一个实体定义一个合同，而另一个实体保证履行该合同。对Java应用程序进行建模时，实现关系可直接用implements关键字来表示。</p>
<p>图I</p>
<p><a href="http://images.51cto.com/files/uploadimg/20100617/1423355.jpg"><img src="http://images.51cto.com/files/uploadimg/20100617/1423355.jpg" alt="img"></a></p>
]]></content>
  </entry>
  <entry>
    <title>zxl规划</title>
    <url>/2020/10/08/zxl%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍zxl规划</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><ul>
<li><p>10月-11月</p>
</li>
<li><p>下午看国考   下午行测刷1套 晚上申论看完视频刷刷题</p>
</li>
<li><p>上午看技术  面试题</p>
</li>
<li><p>面试状态不能丢</p>
</li>
<li><p>国庆结束，我从boss上找些小厂面试看看情况，问问能不能12月份入职，保持自己一直在面试的状态。</p>
</li>
</ul>
<p>我先给国考考了，过俩天面一些50-100人的小厂试试，12月份去上海或者杭州找个活干着，看最后能给我开多少，边工作边找着，国考成绩出来了再说</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>两数之和</title>
    <url>/2020/05/25/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h4 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a></h4><p>难度简单8282</p>
<p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<p><strong>示例:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">给定 nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line"></span><br><span class="line">因为 nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span></span><br><span class="line">所以返回 [<span class="number">0</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>Solution:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">Solution</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> [] twoSum(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)</span><br><span class="line">    &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target-nums[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(target-nums[i]),i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉查找树</title>
    <url>/2020/05/14/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>定义：一棵二叉查找树 （BST）是一棵二叉树，其中每个结点都含有一个 Comparable 的键（以及相关联的值）且每个结点的键都大于其左子树中的任意结点的键而小于右子树的任意结点的键。  </p>
<p><img src="https://photos.alitaalice.cn/image/20200514134241.png" alt=""></p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>一般来说，在符号表中查找一个键可能得到两种结果。如果含有该键的结点存在于表中，我们的查找就命<br>中 了，然后返回相应的值。否则查找未命中 （并返回 null ）。根据数据表示的递归结构我们马上就能得到，在二叉查找树中查找一个键的递归算法：如果树是空的，则查找未命中；如果被查找的键和根结点的键相等，查找命中，否则我们就（递归地）在适当的子树中继续查找。如果被查找的键较小就选择左子树，较大则选择右子树。算法 3.3（续 1）中递归的 get() 方法完全实现了这段算法。它的第一个参 数是一个结点（子树的根结点），第二个参数是被查找的键。  </p>
]]></content>
  </entry>
  <entry>
    <title>二叉树的遍历</title>
    <url>/2020/05/11/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍二叉树的遍历</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="前序遍历算法"><a href="#前序遍历算法" class="headerlink" title="前序遍历算法"></a>前序遍历算法</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>,T-&gt;data);</span><br><span class="line">    PreOrderTraverse(T-&gt;lchild);</span><br><span class="line">    PreOrderTraverse(T-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归调用PreOrderTaverse()函数</p>
<h2 id="中序遍历算法"><a href="#中序遍历算法" class="headerlink" title="中序遍历算法"></a>中序遍历算法</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(T=<span class="literal">NULL</span>)</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">  InOrderTraverse(T-&gt;lchild);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%c"</span>,T-&gt;data);</span><br><span class="line">  InOrderTraverse(T-rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归调用InOrderTraverse()</p>
<h2 id="后序遍历算法"><a href="#后序遍历算法" class="headerlink" title="后序遍历算法"></a>后序遍历算法</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">  PostOrderTraverse(T-&gt;lchild);</span><br><span class="line">  PostOrderTraverse(T-&gt;rchild);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%c"</span>,T-&gt;data);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



































































































































































































































































]]></content>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2020/05/07/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本文。</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="二叉树的特点"><a href="#二叉树的特点" class="headerlink" title="二叉树的特点"></a>二叉树的特点</h2><ul>
<li><p>每个结点最多有俩颗子树。所以二叉树中不存在大于2的结点。</p>
</li>
<li><p>左子树和右子树是有顺序的，次序不能随意颠倒。</p>
</li>
<li><p>即使树中某结点只有一颗子树，也要区分它是左子树还是右子树</p>
<h3 id="二叉树的5种形态"><a href="#二叉树的5种形态" class="headerlink" title="二叉树的5种形态"></a>二叉树的5种形态</h3><ul>
<li>空二叉树</li>
<li>只有一个根结点</li>
<li>根节点只有左子树</li>
<li>根节点只有右子树</li>
<li>根节点既有左子树又有右子树</li>
</ul>
</li>
</ul>
<h2 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h2><ol>
<li><p>斜树</p>
<p>所有结点都只有左子树的二叉树叫做左斜树</p>
<p>所有结点都只有右子树的二叉树叫做右斜树</p>
<p>俩者统称为斜树</p>
</li>
<li><p>满二叉树</p>
<p>在一颗二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树叫做满二叉树</p>
</li>
<li><p>完全二叉树</p>
<p>对一颗具有n个结点的二叉树按照层序编号，如果编号为i（1&lt;=i&lt;=n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这颗二叉树称为完全二叉树。</p>
</li>
</ol>
<h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><h3 id="二叉树性质1"><a href="#二叉树性质1" class="headerlink" title="二叉树性质1"></a>二叉树性质1</h3><p>性质1：在二叉树的第i层上至多有2^(i-1) 个结点。（i&gt;=1)</p>
<h3 id="二叉树性质2"><a href="#二叉树性质2" class="headerlink" title="二叉树性质2"></a>二叉树性质2</h3><p>性质2：深度为k的二叉树至多有2^(k) -1个结点 （k&gt;=1)   (<strong>结点的总量</strong>)</p>
<h3 id="二叉树性质3"><a href="#二叉树性质3" class="headerlink" title="二叉树性质3"></a>二叉树性质3</h3><p>性质3：对于任何一颗二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1</p>
<h3 id="二叉树性质4"><a href="#二叉树性质4" class="headerlink" title="二叉树性质4"></a>二叉树性质4</h3><p>性质4： 具有n个结点的完全二叉树的深度为[log2 n]+1 ([x]表示不大于x的最大整数)</p>
<h3 id="二叉树性质5"><a href="#二叉树性质5" class="headerlink" title="二叉树性质5"></a>二叉树性质5</h3><p><strong>性质5： 如果对一颗有n个结点的完全二叉树（其深度为[log2 n]+1)的结点按层序编号，对任一结点i（1&lt;=i&lt;=n)</strong></p>
<p><strong>有</strong></p>
<ol>
<li><strong>如果i=1,则结点i是二叉树的根，无双亲;如果i&gt;1,则其双亲是结点[i/2]</strong></li>
<li><strong>如果2i&gt;n,则结点i无左孩子（结点i为叶子结点）；否则其左孩子是结点2i</strong></li>
<li><strong>如果2i+1&gt;n,则结点i无右孩子；否则其右孩子是结点2i+1</strong></li>
</ol>
<h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><h4 id="二叉树的顺序存储结构"><a href="#二叉树的顺序存储结构" class="headerlink" title="二叉树的顺序存储结构"></a>二叉树的顺序存储结构</h4><p>用一维数组存储二叉树的结点，并且结点的位置，也就是数组的下标要能体现结点之间的逻辑关系。</p>
<p>一般来说顺序存储用于完全二叉树</p>
<h4 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h4><p>二叉树的每个结点最多有俩个孩子。所以为它设计一个数据域，和俩个指针域是比较自然的想法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lchid -- data --rchild</span><br></pre></td></tr></table></figure>

<p>lchild 和 rchild 都是指针域</p>
<p><strong>二叉树的二叉链表结点结构定义</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct BiTNode</span><br><span class="line">&#123;</span><br><span class="line">   TElemType data; &#x2F;&#x2F;结点数据</span><br><span class="line">   struct BiTNode *lchild ,*rchild;</span><br><span class="line">&#125; BiTNode, *BiTree;</span><br></pre></td></tr></table></figure>

<p>图示：</p>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>二叉树的定义：</p>
<p><strong>二叉树的遍历是指从根节点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问且仅被访问一次。</strong></p>
<h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>规则：若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。</p>
<p>如图：</p>
<p><img src="TIM%E5%9B%BE%E7%89%8720200510112558.png" alt=""></p>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>规则： 若树为空，则空操作返回，否则从根节点开始（注意并不是先访问根节点），中序遍历根节点的左子树，然后是访问根节点，最后中序遍历右子树。</p>
<p><img src="TIM%E5%9B%BE%E7%89%8720200510113141.png" alt=""></p>
<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>规则： 若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点。</p>
<p>图示：</p>
<p><img src="TIM%E5%9B%BE%E7%89%8720200510113343.png" alt=""></p>
<h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>规则：若树为空，则空操作返回。</p>
<p>否则从树的第一层，也就是根节点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。</p>
<p><img src="TIM%E5%9B%BE%E7%89%8720200510113800.png" alt=""></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/2020/09/18/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-1/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
  </entry>
  <entry>
    <title>互联网概述</title>
    <url>/2020/07/11/%E4%BA%92%E8%81%94%E7%BD%91%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><img src="https://photos.alitaalice.cn/image/20200711212626.png" alt=""></p>
]]></content>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/2020/05/28/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
  </entry>
  <entry>
    <title>使用事务处理</title>
    <url>/2020/05/15/%E4%BD%BF%E7%94%A8%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍什么是事务处理以及如何利用COMMIT和ROLLBACK语句来管理事务处理  .</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>MyISAM和<strong>InnoDB</strong>是两种最常使用的引擎。前者不支持明确的事务处理管理，而后者支持。  </p>
<p><strong>事务处理（transaction processing）可以用来维护数据库的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行。</strong>  </p>
<p><strong>事务处理是一种机制，用来管理必须成批执行的MySQL操作，以保证数据库不包含不完整的操作结果。利用事务处理，可以保证一组操作不会中途停止，它们或者作为整体执行，或者完全不执行（除非明确指示）。如果没有错误发生，整组语句提交给（写到）数据库表。如果发生错误，则进行回退（撤销）以恢复数据库到某个已知且安全的状态 .</strong> </p>
<p><img src="https://photos.alitaalice.cn/image/20200515163050.png" alt=""></p>
<h2 id="1控制事务处理"><a href="#1控制事务处理" class="headerlink" title="1控制事务处理"></a>1控制事务处理</h2><p>MySQL-使用下面的语句来标识事务的开始  ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">START TRANSACTION</span><br></pre></td></tr></table></figure>

<p>MySQL的ROLLBACK命令用来回退（撤销） MySQL语句，请看下面的语句：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SELECT * FROM ordertotals;</span><br><span class="line">START TRANSACTION;</span><br><span class="line">DELETE FROM ordertotals;</span><br><span class="line">SELECL * FROM ordertotals;</span><br><span class="line">ROLLBACK;</span><br><span class="line">SELECT * FROM ordertotals;</span><br></pre></td></tr></table></figure>

<p>ROLLBACK只能在一个事务处理内使用（在执行一条START<br> TRANSACTION命令之后）  .</p>
<p>事务处理用来<strong>管理INSERT、 UPDATE和DELETE语</strong>句。你不能回退SELECT语句。（这样做也没有什么意义。）你不能<strong>回退CREATE或DROP</strong>操作。事务处理块中可以使用这两条语句，但如果你执行回退，它们不会被撤销。  </p>
<h2 id="2-使用COMMIT"><a href="#2-使用COMMIT" class="headerlink" title="2 使用COMMIT"></a>2 使用COMMIT</h2><p>一般的MySQL语句都是直接针对数据库表执行和编写的。这就是<br>所谓的隐含提交（implicit commit），即提交（写或保存）操作是自动进行的。  </p>
<p>在事务处理块中，提交不会隐含地进行。为进行明确的提交，<br>使用COMMIT语句 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">START TRANSACTION;</span><br><span class="line">DELETE FROM orderitems WHERE order_num =<span class="number">20010</span>;</span><br><span class="line">DELETE FROM orders WHERE order_num=<span class="number">20010</span>;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>

<p>隐含事务关闭 当COMMIT或ROLLBACK语句执行后，事务会自动关闭（将来的更改会隐含提交）。  </p>
<h3 id="3-使用保留点"><a href="#3-使用保留点" class="headerlink" title="3 使用保留点"></a>3 使用保留点</h3><p>为了支持回退部分事务处理，必须能在事务处理块中合适的位置放<br>置占位符。这样，如果需要回退，可以回退到某个占位符。      </p>
<p>这些占位符称为保留点。为了创建占位符，可如下使用SAVEPOINT<br>语句：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SAVEPOINT delete1;</span><br></pre></td></tr></table></figure>

<p>每个保留点都取标识它的唯一名字，以便在回退时， MySQL知道要<br>回退到何处。为了回退到本例给出的保留点，可如下进行  :</p>
<p>–对于关系数据库教务管理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ROLLBACK TO delete1;</span><br></pre></td></tr></table></figure>

<p>留点在事务处理完成（执行一条ROLLBACK或COMMIT）后自动释放。自MySQL 5以来，也可以用RELEASE SAVEPOINT明确地释放保留点。</p>
<h3 id="4-更改默认的提交行为"><a href="#4-更改默认的提交行为" class="headerlink" title="4 更改默认的提交行为"></a>4 更改默认的提交行为</h3><p>为指示MySQL不自动提交更改，需要使用以下语句 ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SET autocommit=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>使用游标mysql</title>
    <url>/2020/05/14/%E4%BD%BF%E7%94%A8%E6%B8%B8%E6%A0%87mysql/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍游标</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p> MySQL检索操作返回一组称为结果集的行。这组返回的行都是与SQL语句相匹配的行（零行或多行）。使用简单的SELECT语<br>句，例如，没有办法得到第一行、下一行或前10行，也不存在每次一行地处理所有行的简单方法（相对于成批地处理它们）  </p>
<p>游标（cursor） 是一个存储在MySQL服务器上的数据库查询，<br>它不是一条SELECT语句，而是被该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据.  </p>
<p>只能用于存储过程 不像多数DBMS， MySQL游标只能用于<br>存储过程（和函数）  </p>
<h2 id="1-创建游标"><a href="#1-创建游标" class="headerlink" title="1 创建游标"></a>1 创建游标</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE processorders()</span><br><span class="line">BEGIN </span><br><span class="line">   DECLARE ordernumbers CURSOR</span><br><span class="line">   FOR</span><br><span class="line">   SELECT order_num FROM orders</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<p>DECLARE语句用来定义和命名游标，这里为ordernumbers。 存储过程处理完成后，游标就消失（因为它局限于存储过程）  </p>
<h2 id="2-打开和关闭游标"><a href="#2-打开和关闭游标" class="headerlink" title="2 打开和关闭游标"></a>2 打开和关闭游标</h2><p>输入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OPEN ordernumbers;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">关闭游标： CLOSE ordernumbers;</span><br></pre></td></tr></table></figure>

<p>如果你不明确关闭游标，MySQL将会在到达END语句时自动关闭它。</p>
<p>前面的例子修改版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">CREATE PROCEDURE <span class="title">processorders</span><span class="params">()</span></span></span><br><span class="line"><span class="function">BEGIN</span></span><br><span class="line"><span class="function">     --Declare the cursor</span></span><br><span class="line"><span class="function">     DECLARE ordernumbers CURSOR</span></span><br><span class="line"><span class="function">     FOR</span></span><br><span class="line"><span class="function">     SELECT order_num FROM orders</span>;</span><br><span class="line">     --Open the cursor</span><br><span class="line">     OPEN ordernumbers;</span><br><span class="line">     --Close the cursor</span><br><span class="line">     CLOSE ordernumbers;</span><br><span class="line">     </span><br><span class="line">     END;</span><br></pre></td></tr></table></figure>

<p>声明打开和关闭一个游标。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">CREATE PROCEDURE <span class="title">processorders</span><span class="params">()</span></span></span><br><span class="line"><span class="function">BEGIN</span></span><br><span class="line"><span class="function">    --Delare local variables</span></span><br><span class="line"><span class="function">    DECLARE done BOOLEAN DEFAULT 0</span>;</span><br><span class="line">    DECLARE o INT;</span><br><span class="line">    --Declare the cursor</span><br><span class="line">    DECLARE ordernumbers CURSOR</span><br><span class="line">    FOR</span><br><span class="line">    SELECT order_num FROM orders;</span><br><span class="line">    --Declare <span class="keyword">continue</span> handler</span><br><span class="line">    DELARE CONTINUE HANDLER FOR SQLSTATE <span class="string">'02000'</span> SET done=<span class="number">1</span>;</span><br><span class="line">    --Open the cursor</span><br><span class="line">    OPEN ordernumbers;</span><br><span class="line">    --LOOP through all rows</span><br><span class="line">    REPEAT</span><br><span class="line">    </span><br><span class="line">    --GET order number</span><br><span class="line">    FETCH ordernumbers INTO o;</span><br><span class="line">    --End of loop</span><br><span class="line">    UNTIL done END REPEAT;</span><br><span class="line">    --Close the cursor</span><br><span class="line">    CLOSE ordernumbers;</span><br><span class="line">    END;</span><br></pre></td></tr></table></figure>

<p>FETCH是在REPEAT内，因此它反复执行直到done为真（由UNTIL<br>done END REPEAT;规定）。为使它起作用，用一个DEFAULT 0（假，不结束）定义变量done。那么， done怎样才能在结束时被设置为真呢？答案是用以下语句：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DECLARE CONTINUE HANDLER FOR SQLSTATE <span class="string">'02000'</span> SET done=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>这条语句定义了一个CONTINUE HANDLER，它是在条件出现时被执行的代码。这里， 它指出当SQLSTATE ‘02000’出现时， SET done=1。SQLSTATE’02000’是一个未找到条件， 当REPEAT由于没有更多的行供循环而不能继续时，出现这个条件。  </p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序</title>
    <url>/2020/06/02/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍冒泡排序</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>平均时间复杂度为O(n^2)</p>
]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>创建和操纵表</title>
    <url>/2020/05/09/%E5%88%9B%E5%BB%BA%E5%92%8C%E6%93%8D%E7%BA%B5%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍表的创建，更改和删除的基本知识</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="1-创建表"><a href="#1-创建表" class="headerlink" title="1.创建表"></a>1.创建表</h2><p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CREATE TABLE customers</span><br><span class="line">(</span><br><span class="line"> cust_id   <span class="keyword">int</span>  NOT <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"> cust_name <span class="keyword">char</span>(<span class="number">50</span>) NOT <span class="literal">NULL</span>,</span><br><span class="line"> cust_address <span class="keyword">char</span>(<span class="number">50</span>) NOT <span class="literal">NULL</span>,</span><br><span class="line"> PRIMARY KEY(cust_id)</span><br><span class="line">) ENGINE=InnoDB</span><br></pre></td></tr></table></figure>

<ul>
<li>语句格式化  MYsql语句中忽略空格，可以采用缩进格式，这样以便阅读和编辑。</li>
<li>处理现有的表 在创建新表时，指定的表名必须不存在，否则将出错。如果你仅仅想在一个表不存在时创建它，应该在表名后给出IF NOT EXISTS  如CREATE TABLE customers IF NOT EXISTS</li>
</ul>
<h3 id="使用NULL值"><a href="#使用NULL值" class="headerlink" title="使用NULL值"></a>使用NULL值</h3><p>NULL值就是没有值或者缺值。</p>
<p>NULL为默认值，如果不指定NOT NULL 则认定为是NULL</p>
<h4 id="理解NULL"><a href="#理解NULL" class="headerlink" title="理解NULL"></a>理解NULL</h4><p>不要把NULL和空串相混淆，NULL值是没有值，它不是空串。</p>
<p>如果指定  ‘ ’   （俩个单引号，其间没有字符）</p>
<p>这在<strong>NOT NULL</strong> 列中是允许的</p>
<p>空串 是一个有效的值，它并不是无值</p>
<p>NULL值用关键字NULL而不是空串指定。</p>
<h2 id="2-主键再介绍"><a href="#2-主键再介绍" class="headerlink" title="2.主键再介绍"></a>2.主键再介绍</h2><p>创建多个列组成的主键，应该以逗号分隔的列表给出列名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">PRIMARY <span class="title">KEY</span><span class="params">(order_num,order_item)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>主键只能使用不允许NULL值的列，允许NULL值的列不能作为唯一标识</strong></p>
<h2 id="3-使用AUTO-INCREMENT"><a href="#3-使用AUTO-INCREMENT" class="headerlink" title="3.使用AUTO_INCREMENT"></a>3.使用AUTO_INCREMENT</h2><p>AUTO_INCREMENT告诉Mysql ，本列每当增加一行时自动增量。每次执行一个INSERT操作时，Mysql自动对该列增量，每个列只允许有一个AUTO_INCREMENT列，而且它必须被索引。（如，通过使它成为主键）</p>
<h2 id="4-使用默认值"><a href="#4-使用默认值" class="headerlink" title="4.使用默认值"></a>4.使用默认值</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE customers</span><br><span class="line">(</span><br><span class="line"> cust_id   int  NOT NULL AUTO_INCREMENT,</span><br><span class="line"> cust_name char(50) NOT NULL,</span><br><span class="line"> cust_address char(50) NOT NULL ,</span><br><span class="line"> quantity int   NOT NULL DEFAULT 1,</span><br><span class="line"> PRIMARY KEY(cust_id)</span><br><span class="line">) ENGINE&#x3D;InnoDB</span><br></pre></td></tr></table></figure>

<p>DEFAULT 1 指示Mysql再未给出数量的情况下，使用数量1</p>
<ul>
<li>不允许函数，Mysql 不允许使用函数作为默认值，它只支持常量</li>
<li>使用默认值而不是NULL值。</li>
</ul>
<h2 id="5-引擎类型"><a href="#5-引擎类型" class="headerlink" title="5.引擎类型"></a>5.引擎类型</h2><p>上述的demo 以ENGINE=InnoDB语句结束。</p>
<p>Mysql有一个具体管理和处理数据的内部引擎，而且MYSQL 具有多种引擎，它打包多个引擎，并且这些引擎都隐藏再Mysql服务器内，全都能执行CREATE TABLE 和SELECT 等命令。</p>
<h3 id="引擎种类"><a href="#引擎种类" class="headerlink" title="引擎种类"></a>引擎种类</h3><table>
<thead>
<tr>
<th>InnoDB</th>
<th>可靠的事务处理引擎，它不支持全文本搜索</th>
</tr>
</thead>
<tbody><tr>
<td>MEMORY</td>
<td>在功能等同于MyISAM,但由于数据存储在内存（不是磁盘中），速度很快（特别适用于临时表）</td>
</tr>
<tr>
<td>MyISAM</td>
<td>性能极高的引擎，它支持全文本搜索，但是不支持事务处理</td>
</tr>
</tbody></table>
<p>如果省略ENGINE=语句，则使用默认引擎（MyISAM）</p>
<p><strong>注意：</strong></p>
<ul>
<li>引擎类型可以混用</li>
<li>外键不能跨引擎，一个引擎的表不能引用具有使用不同引擎的表的外键。</li>
</ul>
<h2 id="6-更新表"><a href="#6-更新表" class="headerlink" title="6.更新表"></a>6.更新表</h2><p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ALTER TABLE vendors ADD vend_phone <span class="title">CHAR</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ALTER TABLE vendors DROP COLUMN vend_phone;</span><br></pre></td></tr></table></figure>

<p>ALTER TABLE 的一种常见用途是定义外键。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE orderitems ADD CONSTRAINT fk_orderitems_orders FOREIGN KEY (order_num) REFERENCES orders (order_num);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE orderitems ADD CONSTRAINT fk_orderitems_products FOREIGN KEY (prod_id) REFERENCES products (prod_id);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE orders ADD CONSTRAINT fk_orders_customers FOREIGN KEY (cust_id)REFERENCES customers (cust_id);</span><br></pre></td></tr></table></figure>

<p>ALTER TABLE要极为小心，应该在改动之前做一个完整的备份</p>
<h3 id="7-删除表"><a href="#7-删除表" class="headerlink" title="7.删除表"></a>7.删除表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE customers2;</span><br></pre></td></tr></table></figure>

<p>无法撤销，永久删除</p>
<h3 id="8-重命名表"><a href="#8-重命名表" class="headerlink" title="8.重命名表"></a>8.重命名表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RENAME TABLE customers2 TO customers;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RENAME TABLE backup_customers TO customers,</span><br><span class="line">             backup_vendors TO vendors,</span><br><span class="line">             backup_products TO products;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>创建表和操控表</title>
    <url>/2020/05/08/%E5%88%9B%E5%BB%BA%E8%A1%A8%E5%92%8C%E6%93%8D%E6%8E%A7%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍表的创建，更改和删除的基本知识。</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
  </entry>
  <entry>
    <title>内部类</title>
    <url>/2020/05/08/%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍JAVA内部类</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h1 id="JAVA内部类"><a href="#JAVA内部类" class="headerlink" title="JAVA内部类"></a>JAVA内部类</h1><h2 id="为什么需要内部类"><a href="#为什么需要内部类" class="headerlink" title="为什么需要内部类"></a>为什么需要内部类</h2><ul>
<li>内部类可以对同一个包中的其他类隐藏</li>
<li>内部类方法可以访问定义这个类的作用域中的数据，包括原有私有的数据。</li>
</ul>
<p>内部类的特点：</p>
<ul>
<li><p>一个内部类方法可以访问自身的数据字段</p>
</li>
<li><p>可以访问创建它的外围类对象的数据字段</p>
<p>示例：</p>
</li>
</ul>
<h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TalkingClock</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> interval;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">boolean</span> beep;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">TalkingClock</span><span class="params">(<span class="keyword">int</span> interval ,<span class="keyword">boolean</span> beep)</span></span></span><br><span class="line"><span class="function">      </span>&#123;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// an inner class</span></span><br><span class="line">      <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimePrinter</span> <span class="keyword">implements</span> <span class="title">ActionListener</span></span></span><br><span class="line"><span class="class">      </span>&#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span></span></span><br><span class="line"><span class="function">          </span>&#123;</span><br><span class="line">              System.out.println(<span class="string">"at the tone,the time is"</span>+Insant.ofEpochMilli(event.getWhen()));</span><br><span class="line">              <span class="keyword">if</span>(beep) Toolkit.getDefaultToolkit().beep();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  TimePrinter类没有实例字段或者名为beep的对象。</p>
<p>  实际上为此，<strong>内部类对象总有一个隐式引用，指向创建它的外部类对象。</strong></p>
<p>​       但是这个引用在内部类的定义中是不可见的。我们将外围类对象的引用称为outer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          System.out.println(<span class="string">"at the tone,the time is"</span>+Insant.ofEpochMilli(event.getWhen()));</span><br><span class="line">          <span class="keyword">if</span>(outer.beep) Toolkit.getDefaultToolkit().beep();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// an inner class</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TimePrinter</span> <span class="keyword">implements</span> <span class="title">ActionListener</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"at the tone,the time is"</span>+Insant.ofEpochMilli(event.getWhen()));</span><br><span class="line">            <span class="keyword">if</span>(beep) Toolkit.getDefaultToolkit().beep();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> listener =<span class="keyword">new</span> TimePrinter();</span><br><span class="line">    <span class="keyword">var</span> timer=<span class="keyword">new</span> Timer(interval,listener);</span><br><span class="line">    timer.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例代码中，只是在start方法中创建这个类型的对象时使用了一次。</p>
<p>当遇到这类情况时，可以在一个方法中局部的定义这个类。</p>
<ul>
<li><p>声明局部类时不能有访问说明符（即public 或者private)</p>
</li>
<li><p>局部类的作用域被限定在声明这个局部类的块中</p>
</li>
<li><p>局部类的优点: 对外部世界完全隐藏。除了start()方法外，没有任何方法知道TimePrinter类的存在。</p>
</li>
<li><p>局部类不仅可以访问外部类的字段，还可以访问局部变量。（必须是事实最终变量）它们一旦赋值就绝对不会改变。</p>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>有时候我为了免去给内部类命名，便倾向于使用匿名内部类，因为它没有名字。匿名内部类的使用需要注意以下几个地方：</p>
<ul>
<li>匿名内部类是没有访问修饰符的；</li>
</ul>
</li>
</ul>
<ul>
<li>匿名内部类是没有构造方法的 (因为匿名内部类连名字都没有)；</li>
</ul>
<ul>
<li>定义匿名内部类的前提是，内部类必须是继承一个类或者实现接口，格式为 new 父类或者接口(){子类的内容(如函数等)}。也就是说，匿名内部类最终提供给我们的是一个匿名子类的对象，例如：</li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例 1</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span><span class="comment">//可调用函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> AbsDwmo()<span class="comment">//匿名内部类</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"x==="</span>+x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">abc</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"haha"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.abc();  <span class="comment">//匿名内部类调用函数,匿名内部类方法只能调用一次</span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例 2</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inner</span> </span>&#123;    <span class="comment">//注释后，编译时提示类Inner找不到 </span></span><br><span class="line">  <span class="function">String <span class="title">getName</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Inner <span class="title">getInner</span><span class="params">(<span class="keyword">final</span> String name, String city)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Inner() &#123; </span><br><span class="line">        <span class="keyword">private</span> String nameStr = name; </span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> nameStr; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    Outer outer = <span class="keyword">new</span> Outer(); </span><br><span class="line">    Inner inner = outer.getInner(<span class="string">"Inner"</span>, <span class="string">"gz"</span>); </span><br><span class="line">    System.out.println(inner.getName()); </span><br><span class="line"></span><br><span class="line">    System.out.println(inner <span class="keyword">instanceof</span> Inner);  <span class="comment">//匿名内部类实质上是一个匿名子类的对象</span></span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">    Inner</span></span><br><span class="line"><span class="comment">  true</span></span><br><span class="line"><span class="comment">  */</span><span class="comment">//:~ </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内部类概述"><a href="#内部类概述" class="headerlink" title="内部类概述"></a>内部类概述</h2><p>　多重继承指的是一个类可以同时从多于一个的父类那里继承行为和特征，然而我们知道Java为了保证数据安全，它只允许单继承。但有时候，我们确实是需要实现多重继承，而且现实生活中也真正地存在这样的情况，比如遗传：我们即继承了父亲的行为和特征也继承了母亲的行为和特征。可幸的是，Java 提供了两种方式让我们曲折地来实现多重继承：接口和内部类。事实上，实现多重继承是内部类的一个极其重要的应用。除此之外，内部类还可以很好的实现隐藏(例如，私有成员内部类)。内部类共有四种类型，即成员内部类、静态内部类、局部内部类和匿名内部类。特别地，</p>
<p><strong>成员内部类：成员内部类是外围类的一个成员，是 依附于外围类的，所以，只有先创建了外围类对象才能够创建内部类对象。也正是由于这个原因，成员内部类也不能含有 static 的变量和方法；</strong></p>
<p><strong>静态内部类：静态内部类，就是修饰为 static 的内部类，该内部类对象 不依赖于外部类对象，就是说我们可以直接创建内部类对象，但其只可以直接访问外部类的所有静态成员和静态方法；</strong></p>
<p><strong>局部内部类：局部内部类和成员内部类一样被编译，只是它的 作用域发生了改变，它只能在该方法和属性中被使用，出了该方法和属性就会失效；</strong></p>
<p><strong>匿名内部类：定义匿名内部类的前提是，内部类必须要继承一个类或者实现接口，格式为 new 父类或者接口(){定义子类的内容(如函数等)}。也就是说，匿名内部类最终提供给我们的是一个匿名子类的对象。</strong></p>
]]></content>
      <categories>
        <category>JAVASE</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>使用存储过程</title>
    <url>/2020/05/12/%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B-1/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍什么是存储过程，为什么要使用存储过程以及如何使用存储过程，并且介绍创建和使用存储过程的基本语法。  </p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>存储过程简单来说，就是为以后的使用而保存的一条或多条MySQL语句的集合。可将其视为批文件，虽然它们的作用不仅限于批处理  。</p>
<h2 id="为什么要使用存储过程"><a href="#为什么要使用存储过程" class="headerlink" title="为什么要使用存储过程"></a>为什么要使用存储过程</h2><p>理由：</p>
<ul>
<li>通过把处理封装在容易使用的单元中，简化复杂的操作（正如前面例子所述）。</li>
<li>由于不要求反复建立一系列处理步骤，这保证了数据的完整性。如果所有开发人员和应用程序都使用同一（试验和测试）存储过程，则所使用的代码都是相同的。这一点的延伸就是防止错误。需要执行的步骤越多，出错的可能性就越大。防止错误保证了数据的一致性。</li>
<li>简化对变动的管理。如果表名、列名或业务逻辑（或别的内容）有变化，只需要更改存储过程的代码。使用它的人员甚至不需要知道这些变化。</li>
</ul>
<p>这一点的延伸就是安全性。通过存储过程限制对基础数据的访问减少了数据讹误（无意识的或别的原因所导致的数据讹误）的机会。</p>
<ul>
<li>提高性能。因为使用存储过程比使用单独的SQL语句要快。</li>
<li>存在一些只能用在单个请求中的MySQL元素和特性，存储过程可以使用它们来编写功能更强更灵活的代码（在下一章的例子中可以看到。）  </li>
</ul>
<p>换句话说，使用存储过程有3个主要的好处，即简单、安全、高性能。显然，它们都很重要。不过，在将SQL代码转换为存储过程前，也必须知道它的一些缺陷。  </p>
<ul>
<li><p>一般来说，存储过程的编写比基本SQL语句复杂，编写存储过程需要更高的技能，更丰富的经验。  </p>
</li>
<li><p>你可能没有创建存储过程的安全访问权限。许多数据库管理员限制存储过程的创建权限，允许用户使用存储过程，但不允许他们创建存储过程。  </p>
</li>
</ul>
<h2 id="eg：一个返回产品平均价格的存储过程"><a href="#eg：一个返回产品平均价格的存储过程" class="headerlink" title="eg：一个返回产品平均价格的存储过程"></a>eg：一个返回产品平均价格的存储过程</h2><p><img src="https://photos.alitaalice.cn/image/20200513001100.png" alt=""></p>
<p>此存储过程名为productpricing，用CREATE PROCEDURE productpricing()语句定义。如果存储过程接受参数，它们将在()中列举出来。此存储过程没有参数，但后跟的()仍然需要。 BEGIN和END语句用来限定存储过程体，过<br>程体本身仅是一个简单的SELECT语句。如何使用这个存储过程呢？</p>
<p><img src="https://photos.alitaalice.cn/image/20200513001134.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200513001157.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200513001232.png" alt=""></p>
<h4 id="如何使用这个存储过程-？"><a href="#如何使用这个存储过程-？" class="headerlink" title="如何使用这个存储过程  ？"></a>如何使用这个存储过程  ？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">CALL <span class="title">productpricing</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://photos.alitaalice.cn/image/20200513001250.png" alt=""></p>
<h4 id="如何删除这个存储过程？"><a href="#如何删除这个存储过程？" class="headerlink" title="如何删除这个存储过程？"></a>如何删除这个存储过程？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DROP PROCEDURE productpricing;</span><br></pre></td></tr></table></figure>

<p>仅当存在时删除 如果指定的过程不存在，则DROP PROCEDURE将产生一个错误。当过程存在想删除它时（如果过程不存在也不产生错误）可使用DROP PROCEDURE IF EXISTS。  </p>
<h4 id="使用参数"><a href="#使用参数" class="headerlink" title="使用参数"></a>使用参数</h4><p>productpricing只是一个简单的存储过程，它简单地显示SELECT语句的结果。一般，存储过程并不显示结果，而是把结果返回给你指定的变量。    </p>
<p>变量（variable） 内存中一个特定的位置，用来临时存储数据。  以下productpricing的修改版本（如果不先删除此存储过程，则不能再次创建它）：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">CREATE PROCEDURE <span class="title">productpricing</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">              OUT p1 DECIMAL(<span class="number">8</span>,<span class="number">2</span>)</span>,</span></span><br><span class="line"><span class="function">              OUT ph <span class="title">DECIMAL</span><span class="params">(<span class="number">8</span>,<span class="number">2</span>)</span>,</span></span><br><span class="line"><span class="function">              OUT pa <span class="title">DECIMAL</span><span class="params">(<span class="number">8</span>,<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function">              )</span></span><br><span class="line"><span class="function">        BEGIN</span></span><br><span class="line"><span class="function">            SELECT <span class="title">Min</span><span class="params">(prod_price)</span></span></span><br><span class="line"><span class="function">            INTO p1</span></span><br><span class="line"><span class="function">            FROM products</span>;</span><br><span class="line">            <span class="function">SELECT <span class="title">Max</span><span class="params">(prod_price)</span></span></span><br><span class="line"><span class="function">            INTO ph</span></span><br><span class="line"><span class="function">            FROM products</span>;</span><br><span class="line">            <span class="function">SELECT <span class="title">Avg</span><span class="params">(prod_price)</span></span></span><br><span class="line"><span class="function">            INTO pa</span></span><br><span class="line"><span class="function">            FROM products</span>;</span><br><span class="line">            END;</span><br></pre></td></tr></table></figure>

<p>此存储过程接受3个参数： pl存储产品最低价格， ph存储产品最高价格， pa存储产品平均价格。每个参数必须具有指定的类型，这里使用十进制值。关键字OUT指出相应的参数用来从存储过程传出一个值（返回给调用者）。 MySQL支持IN（传递给存储过程）、 OUT（从存储过程传出，如这里所用）和INOUT（对存储过程传入和传出）类型的参数。存储过程的代码位于BEGIN和END语句内，如前所见，它们是一系列SELECT语句，用来检索值，然后保存到相应的变量（通过指定INTO关键字）。</p>
<p>​    为调用此修改过的存储过程，必须指定3个变量名  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">CALL <span class="title">productpricing</span><span class="params">(@pricelow,</span></span></span><br><span class="line"><span class="function"><span class="params">                    @pricehigh,</span></span></span><br><span class="line"><span class="function"><span class="params">                    @priceaverage)</span></span>;</span><br></pre></td></tr></table></figure>

<p>由于此存储过程要求3个参数，因此必须正好传递3个参数，不多也不少。所以，这条CALL语句给出3个参数。它们是存储过程将保存结果的3个变量的名字。<br><strong>变量名</strong> 所有MySQL变量都必须以@开始。  </p>
<p><img src="https://photos.alitaalice.cn/image/20200513094242.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200513094323.png" alt=""></p>
<p>另外一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE ordertotal(</span><br><span class="line">IN onumeber INT,</span><br><span class="line">OUT ototal DECIMAL(8,2))</span><br><span class="line">BEGIN</span><br><span class="line">    SELECT Sum(item_price*quantity)</span><br><span class="line">    FROM orderitems</span><br><span class="line">    WHERE order_num&#x3D;onumber</span><br><span class="line">    INTO ototal;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<p>为调用新存储过程，可以使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CALL ordertotal(20005,@total);</span><br></pre></td></tr></table></figure>

<p><strong>必须给ordertotal传递两个参数；第一个参数为订单号，第二个参数为包含计算出来的合计的变量名。</strong>  </p>
<p>为了显示合计：</p>
<p>SELECT @total;</p>
<p><img src="https://photos.alitaalice.cn/image/20200513094845.png" alt=""></p>
<h2 id="建立智能存储过程"><a href="#建立智能存储过程" class="headerlink" title="建立智能存储过程"></a>建立智能存储过程</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-- Name: ordertotal</span><br><span class="line">-- Parameters: onumber =order number</span><br><span class="line">--             taxable= <span class="number">0</span> <span class="keyword">if</span> not taxable,<span class="number">1</span> <span class="keyword">if</span> taxable</span><br><span class="line">--             ototal =order total variable</span><br><span class="line"></span><br><span class="line"><span class="function">CREATE PROCEDURE <span class="title">ordertotal</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        IN onumber INT,</span></span></span><br><span class="line"><span class="function"><span class="params">        IN taxable BOOLEAN,</span></span></span><br><span class="line"><span class="function"><span class="params">        OUT ototal DECIMAL(<span class="number">8</span>,<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function">)COMMENT 'Obtain order total,optionally adding tax'</span></span><br><span class="line"><span class="function">BEGIN</span></span><br><span class="line"><span class="function">     --Declare variable <span class="keyword">for</span> total</span></span><br><span class="line"><span class="function">     DECLARE total <span class="title">DECIMAL</span><span class="params">(<span class="number">8</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">     --Declare tax percentage</span><br><span class="line">     DECLARE taxrate INT DEFAULT <span class="number">6</span>;</span><br><span class="line">     </span><br><span class="line">     --Get the order total</span><br><span class="line">     <span class="function">SELECT <span class="title">Sum</span><span class="params">(item_price*quantity)</span></span></span><br><span class="line"><span class="function">     FROM orderitems</span></span><br><span class="line"><span class="function">     WHERE order_num </span>=onumber</span><br><span class="line">     INTO total;</span><br><span class="line">     </span><br><span class="line">     --is <span class="keyword">this</span> taxable?</span><br><span class="line">     IF taxable THEN</span><br><span class="line">        --Yes,so add taxrate to the total</span><br><span class="line">        SELECT total+(total/<span class="number">100</span>*taxrate) INTO total;</span><br><span class="line">     END IF;</span><br><span class="line">     --And <span class="keyword">finally</span>,save to out variable</span><br><span class="line">     SELECT total INTO ototal;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<p>为了试验它</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CALL ordertotal(20005,0,@total);</span><br><span class="line">SELECT @total;</span><br></pre></td></tr></table></figure>

<p>为显示用来创建一个存储过程的CREATE语句，使用SHOW CREATE<br>PROCEDURE语句：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SHOW CREATE PROCEDURE ordertotal;</span><br></pre></td></tr></table></figure>

<p>为了获得包括何时、由谁创建等详细信息的存储过程列表， 使用SHOW<br>PROCEDURE STATUS。  </p>
<p>SHOW PROCEDURE STATUS列出所有存储过程。为限制其输出，可使用LIKE指定一个过滤模式，例如：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SHOW PROCEDURE STATUS LIKE <span class="string">'ordertotal'</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>单件模式</title>
    <url>/2020/05/27/%E5%8D%95%E4%BB%B6%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>单件模式 –&gt;  确保一个类只有一个实例，并提供全局访问点。</p>
<p>当你需要确保程序中的某个类只有一个实例时，就采用单件模式吧</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2020/08/11/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍单例模式</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>单例模式的示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingleTon singleTon = <span class="keyword">new</span> SingleTon();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleTon <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleTon;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"i am singleTon pattern"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Minister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">3</span> ; i++) &#123;</span><br><span class="line">            SingleTon singleTon = SingleTon.getInstance();</span><br><span class="line">            singleTon.doSomething();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://photos.alitaalice.cn/image/20200813204156.png" alt=""></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>初级排序算法</title>
    <url>/2020/05/12/%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍排序算法</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>我们关注的主要对象是重新排列数组元素 的算法，其中每个元素都有一个主键 。排序算法的目标就是将所有元素的主键按照某种方式排列（通常是按照大小或是字母顺序）。排序后索引较大的主键大于等于索引较小的主键 . </p>
<h2 id="一-初级排序算法"><a href="#一-初级排序算法" class="headerlink" title="一.初级排序算法"></a>一.初级排序算法</h2><p>排序算法类的模板</p>
<p>排序算法类模版”中的 Example 类展示了我们的习惯约定：我们会将排序代码放在类的 sort() 方法中，该类还将包含辅助函数 less() 和 exch() （可能还有其他辅助函数）以及一个示例用例main() 。Example 类还包含了一些早期调试使用的代码：测试用例 main() 将标准输入得到的字符串排序，并用私有方法 show() 打印字符数组的内容。我们还会在本章中遇到各种用于比较不同算法并研究它们的性能的测试用例。为了区别不同的排序算法，我们为相应的类取了不同的名字，用例可以根据名字调用不同的实现，例如 Insertion.sort() 、Merge.sort() 、Quick.sort() 等。<br>大多数情况下，我们的排序代码只会通过两个方法操作数据：less() 方法对元素进行比较，exch()方法将元素交换位置。exch() 方法的实现很简单，通过 Comparable 接口实现 less() 方法也不困难。将数据操作限制在这两个方法中使得代码的可读性和可移植性更好，更容易验证代码的正确性、分析性能以及排序算法之间的比较。在学习具体的排序算法实现之前，我们先讨论几个对于所有排序算法都很<br>重要的问题。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 请见算法2.1、算法2.2、算法2.3、算法2.4、算法2.5或算法2.7*/</span> &#125;<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123; Comparable t = a[i]; a[i] = a[j]; a[j] = t; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 在单行中打印数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++)</span><br><span class="line">StdOut.print(a[i] + <span class="string">" "</span>);</span><br><span class="line">StdOut.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 测试数组元素是否有序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++)</span><br><span class="line"><span class="keyword">if</span> (less(a[i], a[i-<span class="number">1</span>])) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 从标准输入读取字符串，将它们排序并输出</span></span><br><span class="line">String[] a = In.readStrings();</span><br><span class="line">sort(a);</span><br><span class="line"><span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a)</span></span>;</span><br><span class="line">show(a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-java中compareTo-用法详解"><a href="#1-java中compareTo-用法详解" class="headerlink" title="1.java中compareTo()用法详解"></a>1.java中compareTo()用法详解</h2><p>一、字符串比较用compareTo()时:</p>
<p>1，长度相同,从第一位开始比较，如果相同返回0，如果不同则马上返回这两个字符的ascii值的差值。</p>
<p>2，长度不同,直接返回长度差值。</p>
<p>二、Integer比较用compareTo()时：</p>
<p>1，对比数字时相同，返回0。</p>
<p>2，对比数字不同时，返回-1。</p>
<p><strong>对于 v&lt;w 、v=w 和 v&gt;w 三种情况，Java 的习惯是在 v.compareTo(w) 被调用时分别返回一个负整数、零和一个正整数（一般是 -1、0 和 1）</strong></p>
<p>我们接下来用 v&gt;w 来表示<br>v.compareTo(w)&gt;0  </p>
<h2 id="2-实现-Comparable-接口"><a href="#2-实现-Comparable-接口" class="headerlink" title="2.实现 Comparable 接口"></a>2.实现 Comparable 接口</h2><p><strong>我们的排序算法模板适用于任何实现了 Comparable 接口的数据类型。遵守 Java 惯例的好处是很多你希望排序的数据都实现了 Comparable 接口。例如，Java 中封装数字的类型 Integer 和 Double，以及 String 和其他许多高级数据类型（如 File 和 URL ）都实现了 Comparable 接口。因此你可以直接用这些类型的数组作为参数调用我们的排序方法。</strong>  </p>
<p>在创建自己的数据类型时，我们只要实现 Comparable 接口就能够保证用例代码可以将其排序。要做到这一点，只需要实现一个 compareTo() 方法来定义目标类型对象的自然次序  .</p>
<p><img src="https://photos.alitaalice.cn/image/20200513001323.png" alt=""></p>
<h2 id="二-选择排序"><a href="#二-选择排序" class="headerlink" title="二.选择排序"></a>二.选择排序</h2><p><strong>定义</strong>：一种最简单的排序算法是这样的：首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法叫做选择排序 ，因为它在不断地选择剩余元素之中的最小者。  </p>
<p><strong>选择排序代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Selection</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 将a[]按升序排列</span></span><br><span class="line"><span class="keyword">int</span> N = a.length; <span class="comment">// 数组长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">&#123; <span class="comment">// 将a[i]和a[i+1..N]中最小的元素交换</span></span><br><span class="line"><span class="keyword">int</span> min = i; <span class="comment">// 最小元素的索引</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; N; j++)</span><br><span class="line"><span class="keyword">if</span> (less(a[j], a[min])) min = j;</span><br><span class="line">exch(a, i, min);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// less()、exch()、isSorted()和main()方法见“排序算法类模板”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for循环i时，先找到最小a[0]的元素，再找到第二小的元素a[1]…一直进行下去</p>
<p>该算法将第 i 小的元素放到 a[i] 之中。数组的第 i 个位置的左边是 i 个最小的元素且它们不会再被访问。  </p>
<p><img src="https://photos.alitaalice.cn/image/20200513001448.png" alt=""></p>
<h1 id="三-插入排序"><a href="#三-插入排序" class="headerlink" title="三.插入排序"></a>三.插入排序</h1><p>在计算机的实现中，为了给要插入的元素腾出空间，我们需要将其余所有元素在插入之前都向右移动一位。这种算法叫做<strong>插入排序</strong>   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insertion</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 将a[]按升序排列</span></span><br><span class="line"><span class="keyword">int</span> N = a.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">&#123; <span class="comment">// 将 a[i] 插入到 a[i-1]、a[i-2]、a[i-3]...之中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; less(a[j], a[j-<span class="number">1</span>]); j--)</span><br><span class="line">exch(a, j, j-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// less()、exch()、isSorted()和main()方法见“排序算法类模板”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://photos.alitaalice.cn/image/20200513001419.png" alt=""></p>
<p>插入排序原理很简单，讲一组数据分成两组，我分别将其称为有序组与待插入组。每次从待插入组中取出一个元素，与有序组的元素进行比较，并找到合适的位置，将该元素插到有序组当中。就这样，每次插入一个元素，有序组增加，待插入组减少。直到待插入组元素个数为0。当然，插入过程中涉及到了元素的移动。为了排序方便，我们一般将数据第一个元素视为有序组，其他均为待插入组。</p>
<p><img src="https://photos.alitaalice.cn/image/20200513001521.png" alt="">下面是几种典型的部分有序的数组：</p>
<ul>
<li><p>数组中每个元素距离它的最终位置都不远；</p>
</li>
<li><p>一个有序的大数组接一个小数组；</p>
</li>
<li><p>数组中只有几个元素的位置不正确。</p>
<p>插入排序对这样的数组很有效，而选择排序则不然。事实上，当倒置的数量很少时，插入排序很可能比本章中的其他任何算法都要快。  </p>
</li>
</ul>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shell</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 将a[]按升序排列</span></span><br><span class="line"><span class="keyword">int</span> N = a.length;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (h &lt; N/<span class="number">3</span>) h = <span class="number">3</span>*h + <span class="number">1</span>; <span class="comment">// 1, 4, 13, 40, 121, 364, 1093, ...</span></span><br><span class="line"><span class="keyword">while</span> (h &gt;= <span class="number">1</span>)</span><br><span class="line">&#123; <span class="comment">// 将数组变为h有序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; N; i++)</span><br><span class="line">&#123; <span class="comment">// 将a[i]插入到a[i-h], a[i-2*h], a[i-3*h]... 之中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= h &amp;&amp; less(a[j], a[j-h]); j -= h)</span><br><span class="line">exch(a, j, j-h);</span><br><span class="line">&#125;</span><br><span class="line">h = h/<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// less()、exch()、isSorted()和main()方法见“排序算法类模板”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://photos.alitaalice.cn/image/20200513154601.png" alt=""></p>
<p>算法 shell 的实现使用了序列 ，从N/3 开始递减至 1。我们把这个序列称为递增序列 。  实现希尔排序的一种方法是对于每个 h，用插入排序将 h 个子数组独立地排序。但因为子数组是相互独立的，一个更简单的方法是在 h- 子数组中将每个元素交换到比它大的元素之前去（将比它大的元素向右移动一格）。只需要在插入排序的代码中将移动元素的距离由 1 改为 h 即可。这样，希尔排序的实现就转化为了一个类似于插入排序但使用不同增量的过程。  </p>
<p><img src="https://photos.alitaalice.cn/image/20200513154809.png" alt=""></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>反射</title>
    <url>/2020/09/18/%E5%8F%8D%E5%B0%84-1/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>反射的编程思想</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在类的运行期间，通过对class对象的解析，可以获取这个类的属性，方法，构造函数，并执行获取</span><br><span class="line">属性，构造函数和方法，主要用于构建平台和框架</span><br></pre></td></tr></table></figure>

<p>获取class对象的三种方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> 类名<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">2 对象名.<span class="title">getclass</span></span></span><br><span class="line"><span class="class">3 <span class="title">class</span>.<span class="title">forname</span>(包名.类名)</span></span><br></pre></td></tr></table></figure>

<p>常用第三种，第一种需要导包，依赖强，不导包会报错<br>第二种已经有对象了还要反射干啥<br>在使用第三种的时候回有classnotfoundexception的检查异常</p>
<p>getDeclaredFields()获取所有属性<br>getDeclaredField()获取单个属性<br>通过暴力访问setAccessible()可以直接访问类中私有的属性</p>
<p>获取方法getDeclaredMethod(方法名,参数类型.class) invoke()执行方法<br>newInstance()的使用有局限，<br>因为它生成对象只能调用无参的构造函数</p>
]]></content>
  </entry>
  <entry>
    <title>各种注解</title>
    <url>/2020/07/03/%E5%90%84%E7%A7%8D%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍各种注解</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestBody</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ResponseBody</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@PostMapping</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Controller</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>反射</title>
    <url>/2020/06/05/%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍反射</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
      <categories>
        <category>JAVASE</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>命令模式</title>
    <url>/2020/05/28/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍命令模式</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>这个模式允许我们将动作封装成命令对象，这样一来，我们就可以随心所欲地储存，传递和调用他们。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>命令模式：</p>
<p>将请求封装成对象，这可以让你使用不同的请求，队列或者日志请求来参数化其他对象，命令模式也可以支持撤销操作。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>图解JAVA垃圾回收机制</title>
    <url>/2020/05/20/%E5%9B%BE%E8%A7%A3JAVA%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍JAVA垃圾回收机制.</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="对象是否可以被回收的两种经典算法"><a href="#对象是否可以被回收的两种经典算法" class="headerlink" title="对象是否可以被回收的两种经典算法"></a>对象是否可以被回收的两种经典算法</h3><p>1 引用计数算法</p>
<p>2 可达性分析算法</p>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p>转<a href="https://blog.csdn.net/justloveyou_/article/details/71216049">https://blog.csdn.net/justloveyou_/article/details/71216049</a></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>基于拉链和线性探测法的散列表</title>
    <url>/2020/05/13/%E5%9F%BA%E4%BA%8E%E6%8B%89%E9%93%BE%E5%92%8C%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95%E7%9A%84%E6%95%A3%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍基于拉链和线性探测法的散列表</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>使用散列的查找算法分为两步。第一步是用散列函数 将被查找的键转化为数组的一个索引。理想情况下，不同的键都能转化为不同的索引值。当然，这只是理想情况，所以我们需要面对两个或者多个键都会散列到相同的索引值的情况。因此，散列查找的第二步就是一个处理碰撞冲突 的过程，如图 所示。在描述了多种散列函数的计算后，我们会学习两种解决碰撞的方法：拉链法 和 线性探测法 。  </p>
<p><img src="https://photos.alitaalice.cn/image/20200514100602.png" alt=""></p>
<h3 id="散列表的核心问题"><a href="#散列表的核心问题" class="headerlink" title="散列表的核心问题"></a>散列表的核心问题</h3><p>散列表是算法在时间和空间上作出权衡的 经典例子。如果没有内存限制，我们可以直接将键作为（可能是一个超大的）数组的索引，那么所有查找操作只需要访问内存一次即可完成。但这种理想情况不会经常出现，因为当键很多时需要的内存太大。另一方面，如果没有时间限制，我们可以使用无序数组并进行顺序查找，这样就只需要很少的内存。而散列表则使用了适度的空间和时间并在这两个极端之间找到了一种平衡。事实上，我们不必重写代码，只需要调整散列算法的参数就可以在空间和时间之间作出取舍。我们会使用概率论的经典结论来帮助我们选择适当的参数。  </p>
<h3 id="基于拉链法的散列表"><a href="#基于拉链法的散列表" class="headerlink" title="基于拉链法的散列表"></a>基于拉链法的散列表</h3><p>一个散列函数能够将键转化为数组索引。散列算法的第二步是碰撞处理 ，也就是处理两个或多个键的散列值相同的情况。<strong>一种直接的办法是将大小为 M的数组中的每个元素指向一条链表，链表中的每个结点都存储了散列值为该元素的索引的键值对。这种方法被称为拉链法</strong> ，因为发生冲突的元素都被存储在链表中。这个方法的基本思想就是选择足够大的 ，使得所有链表都尽可能短以保证高效的查找。查找分两步：首先根据散列值找到对应的链表，然后沿着链表顺序查找相应的键。  </p>
<h3 id="散列表的大小"><a href="#散列表的大小" class="headerlink" title="散列表的大小"></a>散列表的大小</h3><p>在实现基于拉链法的散列表时，我们的目标是选择适当的数组大小 M，既不会因为空链表而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。而拉链法的一个好处就是这并不是关键性的选择。如果存入的键多于预期，查找所需的时间只会比选择更大的数组稍长；如果少于预期，虽然有些空间浪费但查找会非常快。当内存不是很紧张时，可以选择一个足够大的 M，使得查找需要的时间变为常数；当内存紧张时，选择尽量大的M仍然能够将性能提高 M倍。  </p>
<h3 id="基于线性探测法的散列表"><a href="#基于线性探测法的散列表" class="headerlink" title="基于线性探测法的散列表"></a>基于线性探测法的散列表</h3><p>实现散列表的另一种方式就是用大小为 M的数组保存N 个键值对，其中 M&gt;N。我们需要依靠数组中的空位 解决碰撞冲突。基于这种策略的所有方法被统称为开放地址 散列表。 </p>
<p> 开放地址散列表中最简单的方法叫做线性探测法 ：当碰撞发生时（当一个键的散列值已经被另一个不同的键占用），我们直接检查散列表中的下一个位置（将索引值加 1）。这样的线性探测可能会产生三种结果：  </p>
<ul>
<li>命中，该位置的键和被查找的键相同；</li>
<li>未命中，键为空（该位置没有键）；</li>
<li>继续查找，该位置的键和被查找的键不同。  </li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾收集器与内存分配策略</title>
    <url>/2020/05/18/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍垃圾收集器与内存分配策略</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-java中init和clinit方法"><a href="#1-java中init和clinit方法" class="headerlink" title="1 java中init和clinit方法"></a>1 java中init和clinit方法</h3><p>init是对象构造器方法，也就是说在程序执行 new 一个对象调用该对象类的 constructor 方法时才会执行init方法，而clinit是类构造器方法，也就是在jvm进行类<strong>加载—–验证—-解析—–初始化</strong>，中的初始化阶段jvm会调用clinit方法。</p>
<p><strong>init是instance实例构造器，对非静态变量解析初始化</strong>，而<strong>clinit是class类构造器对静态变量，静态代码块进行初始化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> Log log = LogFactory.getLog(); <span class="comment">// &lt;clinit&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">1</span>;   <span class="comment">// &lt;init&gt;</span></span><br><span class="line"></span><br><span class="line">   X()&#123;</span><br><span class="line">      <span class="comment">// &lt;init&gt;</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="comment">// &lt;clinit&gt;</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="简述可达性分析算法"><a href="#简述可达性分析算法" class="headerlink" title="简述可达性分析算法"></a>简述可达性分析算法</h3><h3 id="finalize关键字"><a href="#finalize关键字" class="headerlink" title="finalize关键字"></a>finalize关键字</h3><p>java提供<a href="http://www.51testing.com/javascrīpt:;"><strong>finalize</strong></a>()方法，垃圾回收器准备释放内存的时候，会先调用finalize()。</p>
<p>​    (1).对象不一定会被回收。</p>
<p>​    (2).垃圾回收不是析构函数。</p>
<p>​    (3).垃圾回收只与内存有关。</p>
<p>​    (4).垃圾回收和finalize()都是靠不住的，只要JVM还没有快到耗尽内存的地步，它是不会浪费时间进行垃圾回收的。</p>
<p>有时当撤消一个对象时，需要完成一些操作。例如，如果一个对象正在处理的是非Java 资源，如文件句柄或window 字符字体，这时你要确认在一个对象被撤消以前要保证这些资源被释放。为处理这样的状况，Java 提供了被称为收尾（finalization ）的机制。使用该机制你可以定义一些特殊的操作，这些操作在一个对象将要被垃圾回收程序释放时执行。</p>
<p>要给一个类增加收尾（finalizer ），你只要定义finalize ( ) 方法即可。Java 回收该类的一个对象时，就会调用这个方法。在finalize ( )方法中，你要指定在一个对象被撤消前必须执行的操作。垃圾回收周期性地运行，检查对象不再被运行状态引用或间接地通过其他对象引用。就在对象被释放之前，Java 运行系统调用该对象的finalize( ) 方法。</p>
<p>finalize()方法的通用格式如下：</p>
<p>protected void finalize( )<br>{<br>// finalization code here<br>}</p>
<h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h3><p>方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。 </p>
<p>Java中所有类都从Object类中继承finalize()方法。</p>
<p>当垃圾回收器(garbage colector)决定回收某对象时，就会运行该对象的finalize()方法。值得C++程序员注意的是，finalize()方法并不能等同与析构函数。Java中是没有析构函数的。C++的析构函数是在对象消亡时运行的。由于C++没有垃圾回收，对象空间手动回收，所以一旦对象用不到时，程序员就应当把它delete()掉。所以析构函数中经常做一些文件保存之类的收尾工作。但是在Java中很不幸，如果内存总是充足的，那么垃圾回收可能永远不会进行，也就是说filalize()可能永远不被执行，显然指望它做收尾工作是靠不住的。</p>
<p>那么finalize()究竟是做什么的呢？它最主要的用途是回收特殊渠道申请的内存。Java程序有垃圾回收器，所以一般情况下内存问题不用程序员操心。但有一种JNI(Java Native Interface)调用non-Java程序（C或C++），finalize()的工作就是回收这部分的内存。</p>
<h3 id="Java中的引用"><a href="#Java中的引用" class="headerlink" title="Java中的引用"></a>Java中的引用</h3><h3 id="简述垃圾回收算法"><a href="#简述垃圾回收算法" class="headerlink" title="简述垃圾回收算法"></a>简述垃圾回收算法</h3><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><h3 id="在垃圾回收器回收对象的时候，程序的逻辑是否可以继续执行"><a href="#在垃圾回收器回收对象的时候，程序的逻辑是否可以继续执行" class="headerlink" title="在垃圾回收器回收对象的时候，程序的逻辑是否可以继续执行"></a>在垃圾回收器回收对象的时候，程序的逻辑是否可以继续执行</h3><h3 id="垃圾回收器在什么时候，对哪些对象，做了什么"><a href="#垃圾回收器在什么时候，对哪些对象，做了什么" class="headerlink" title="垃圾回收器在什么时候，对哪些对象，做了什么"></a>垃圾回收器在什么时候，对哪些对象，做了什么</h3><h3 id="简述minor-GC，与full-GC-java垃圾回收分代，以及何时发生minor-gc，以及full-gc"><a href="#简述minor-GC，与full-GC-java垃圾回收分代，以及何时发生minor-gc，以及full-gc" class="headerlink" title="简述minor GC，与full GC,java垃圾回收分代，以及何时发生minor gc，以及full gc"></a>简述minor GC，与full GC,java垃圾回收分代，以及何时发生minor gc，以及full gc</h3>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>基本索引类型</title>
    <url>/2020/06/09/%E5%9F%BA%E6%9C%AC%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
  </entry>
  <entry>
    <title>堆的特点</title>
    <url>/2020/09/29/%E5%A0%86%E7%9A%84%E7%89%B9%E7%82%B9/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍堆的特点</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p>一棵深度为k的有n个结点的<a href="https://baike.baidu.com/item/二叉树/1602879">二叉树</a>，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树.</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h1 id="1、堆的定义及分类"><a href="#1、堆的定义及分类" class="headerlink" title="1、堆的定义及分类"></a>1、堆的定义及分类</h1><p><img src="https://img-blog.csdnimg.cn/2020011622220553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTY5OTU2Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200116222249759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTY5OTU2Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>NO1、NO2是大顶堆<br>NO3是小顶堆<br>NO4不是堆</strong></p>
<h1 id="2、堆的存储结构【数组】"><a href="#2、堆的存储结构【数组】" class="headerlink" title="2、堆的存储结构【数组】"></a>2、堆的存储结构【数组】<img src="https://img-blog.csdnimg.cn/20200116222555793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTY5OTU2Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></h1><h2 id="3-图的深度优先遍历"><a href="#3-图的深度优先遍历" class="headerlink" title="3.图的深度优先遍历"></a>3.图的深度优先遍历</h2><p>DFS （Depth_First_Search)<br>深度优先搜索</p>
<p><strong>从图中的某个顶点V出发，访问此顶点，然后从V的未被访问的邻接点出发，深度优先遍历图，直到图中所有和V有路径相通的顶点都被访问到。</strong></p>
<h2 id="4-图的广度优先遍"><a href="#4-图的广度优先遍" class="headerlink" title="4.图的广度优先遍"></a>4.图的广度优先遍</h2><p>广度优先搜索，类似于树的层序遍历。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>复合模式</title>
    <url>/2020/05/28/%E5%A4%8D%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
  </entry>
  <entry>
    <title>字节与字符</title>
    <url>/2020/08/14/%E5%AD%97%E8%8A%82%E4%B8%8E%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍字节与字符</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>字节(Byte)是计量单位，表示数据量多少，是计算机存储容量的计量单位。一个字节占8位。</p>
<p>字符(Character)计算机中使用的文字和符号，比如’A’、’B’、’$’、’&amp;’等。</p>
<p>字节与字符：</p>
<p>①ASCII码中，一个英文字母（不分大小写）占一个字节的空间，一个中文汉字占两个字节的空间。</p>
<p>②UTF-8编码中，一个英文字符等于一个字节，一个中文等于三个字节。</p>
<p>③Unicode编码中，一个英文等于两个字节，一个中文等于两个字节。</p>
<p>符号：英文标点占一个字节，中文标点占两个字节。举例：英文句号“.”占1个字节的大小，中文句号“。”占2个字节的大小。</p>
<p>④UTF-16编码中，一个英文字母字符或一个汉字字符存储都需要2个字节（Unicode扩展区的一些汉字存储需要4个字节）。</p>
<p>⑤UTF-32编码中，世界上任何字符的存储都需要4个字节。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>学习方法</title>
    <url>/2020/05/07/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>学习方法</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><ul>
<li>慢一点，你理解的越多，需要记的就越少</li>
<li>勤做练习，自己记笔记</li>
<li>上床睡觉之前就不要再看别的书了，或者至少不能再看其他有难度的东西</li>
<li>要喝水，要多喝水</li>
<li>大声说出来</li>
<li>听听你的大脑怎么说（注意大脑是不是负荷太重）</li>
<li>要有点感觉（真正融入到书的故事中）</li>
</ul>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>学习有感</title>
    <url>/2020/06/03/%E5%AD%A6%E4%B9%A0%E6%9C%89%E6%84%9F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍学习有感</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>不要着急，任何学习都不是一蹴而就的，但是你必须进步，必须每天都有自己的计划，不浪费过多时间，按部就班，每天进步一些，一步一步来。</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>实习</title>
    <url>/2020/05/08/%E5%AE%9E%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍实习</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本日是5.8日  6.15日正式开始面试</p>
<p>需要学习的内容有：</p>
<p>1 数据结构</p>
<p>2 JAVA集合</p>
<p>3 JAVA并发</p>
<p>4 JVM</p>
<p>5 mysql</p>
<p>6 Spring</p>
<p>7 计网和操作系统面经内容。</p>
<p>8 redis了解。</p>
<ul>
<li><p>JAVASE 数据结构算法 mysql 这三个是一类</p>
</li>
<li><p>设计模式 JVM  这两个是一类  能大概谈谈每种设计模式是什么就可以了</p>
</li>
<li><p>剑指offer 这个单独一类 </p>
</li>
</ul>
<p>先定位好去什么样的公司吧，如果想试试大厂，那么后端大数据都无所谓，基础要非常好，</p>
<p>然后大数据/后端 一两个框架搞熟，如果去那种普通的公司，算法啥的，简单看看就行，多搞点项目经验，对框架好熟悉</p>
<p>java做初+中的，mysql建议全做，不会的看答案，然后自己写</p>
<p>做个SSM和Boot的CRUD项目就可以了。<br>            不要花太多精力在上面。<br>几天时间吧。<br>boot估计一天不到。<br>主要是熟悉整个流程。<br>找个手感<br><a href="https://leetcode-cn.com/">https://leetcode-cn.com/</a><br>没事刷刷题<br>java做初+中的，mysql建议全做，不会的看答案，然后自己写</p>
<ul>
<li>2018~2019 </li>
</ul>
<p>​      拿不出就在网上找，，找个牛批的项目，学习一下，，思考一下技术选型，架构，过程中遇到过什么难题等等，，。没做过不重要，会扯就行。crud太low了。，找个牛批的项目</p>
<p>不用等到完全准备好才投简历，，因为一般人永远觉得自己还没准备好，，，准备个差不多就投简历，，，就算通过不了，也能及时发现自己的不足，然后补上</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/2020/05/22/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍工厂模式</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>工厂方法模式：通过让子类决定该创建的对象是什么，来达到将对象创建的过程封装的目的。</p>
<p>创造者（Creator）类   抽象创建者类。定义抽象的工厂方法，让子类实现此方法制造产品。</p>
<p>产品类  具体的产品，实际能制造的东西</p>
<p><img src="https://photos.alitaalice.cn/image/20200525105633.png" alt=""> </p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式详解</title>
    <url>/2020/07/09/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
  </entry>
  <entry>
    <title>已投递的简历</title>
    <url>/2020/08/21/%E5%B7%B2%E6%8A%95%E9%80%92%E7%9A%84%E7%AE%80%E5%8E%86/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>已投:<br>网易互娱<br>奇安信<br>红杉资本<br>广联达<br>小米<br>4399<br>远景<br>巨人网络<br>好未来<br>用友<br>联想<br>招联<br>shopee<br>作业帮<br>美团<br>昆仑</p>
<p>未投：<br>深信服<br>字节跳动</p>
]]></content>
  </entry>
  <entry>
    <title>希尔排序</title>
    <url>/2020/06/02/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
  </entry>
  <entry>
    <title>常量池</title>
    <url>/2020/09/06/%E5%B8%B8%E9%87%8F%E6%B1%A0/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>常量池：</p>
<p>　　即class文件常量池，是class文件的一部分，用于保存编译时确定的数据。</p>
<p>​    保存的内容如下图：</p>
<p><img src="https://img2018.cnblogs.com/blog/1111824/201904/1111824-20190422110927913-1003646094.png" alt="img"></p>
<p>　　<img src="https://img2018.cnblogs.com/blog/1111824/201904/1111824-20190422110625847-2141008140.png" alt="img"></p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="img"> View Code</p>
<p>运行时常量池：</p>
<p>　　Java语言并不要求常量一定只能在编译期产生，运行期间也可能产生新的常量，这些常量被放在运行时常量池中。</p>
<p>　　<strong>类加载后，常量池中的数据会在运行时常量池中存放</strong>！</p>
<p>　　这里所说的常量包括：基本类型包装类（包装类不管理浮点型，整形只会管理-128到127）和String（也可以通过String.intern()方法可以强制将String放入常量池）</p>
<p>字符串常量池：</p>
<p>　　HotSpot VM里，记录interned string的一个全局表叫做StringTable，它本质上就是个HashSet<String>。注意<strong>它只存储对java.lang.String实例的引用，而不存储String对象的内容</strong></p>
<p>jdk 1.7后，移除了方法区间，运行时常量池和字符串常量池都在堆中</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程第一章知识点</title>
    <url>/2020/06/16/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍并发编程第一章知识点</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>1 进程和线程的区别</p>
<p>看了一遍排在前面的答案，类似”<strong>进程是资源分配的最小单位，线程是CPU调度的最小单位“</strong>这样的回答感觉太抽象，都不太容易让人理解。</p>
<p>做个简单的比喻：进程=火车，线程=车厢</p>
<ul>
<li>线程在进程下行进（单纯的车厢无法运行）</li>
<li>一个进程可以包含多个线程（一辆火车可以有多个车厢）</li>
<li>不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）</li>
<li>同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）</li>
<li>进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）</li>
<li>进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）</li>
<li>进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）</li>
<li>进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－”互斥锁”</li>
<li>进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”</li>
</ul>
<p>\2. 竞态</p>
<p>p15</p>
<p>\3. 竞态的两种模式</p>
<p>\4. 原子性</p>
<p>p15</p>
<p>\5. java实现原子性</p>
<p>\6. 可见性</p>
<p>可见性是指当一个线程修改了共享变量后，其他线程能够立即得知这个修改。通过之前对<a href="https://www.jianshu.com/p/d53bf830fa09">synchronzed</a>内存语义进行了分析，当线程获取锁时会从主内存中获取共享变量的最新值，释放锁的时候会将共享变量同步到主内存中。从而，<strong>synchronized具有可见性</strong>。同样的在<a href="https://www.jianshu.com/p/157279e6efdb">volatile分析中</a>，会通过在指令中添加<strong>lock指令</strong>，以实现内存可见性。因此, <strong>volatile具有可见性</strong></p>
<p>\7. 重排序</p>
<p>\8.  锁的概述</p>
<p>\9.  锁的分类</p>
<p>\10. 锁的作用</p>
<p>\11. 使用所保证线程安全是有条件的</p>
<p>\12. 锁的几个概念</p>
<p>\13. 内部锁</p>
<p>\14. 显示锁与内部锁的比较</p>
<p>\15. 锁的选用</p>
<p>\16. 改进锁（读写锁）ReadWriteLock</p>
<p>\17. 锁的使用场景</p>
<p>\18. 线程同步的底层助手：内存屏障</p>
<p>\19. 锁与重排序</p>
<p>\20. 轻量级同步机制volatile</p>
<p>\21. volatile的作用</p>
<p>\22. CAS与原子变量</p>
<p>\23. 字段更新器</p>
<p>\24. 对象初始化线程安全：重放final和static</p>
<p>\25. 线程数的设置</p>
<p>\26. 等待与通知：notify/notify</p>
<p>\27. wait,notify的开销及问题</p>
<p>\28. 多线程编程的硬件基础与java内存模型</p>
<p>\29. volatile关键字的实现</p>
<p><img src="https://photos.alitaalice.cn/image/20200616210931.png" alt=""></p>
<p>\30. Java实现生产者消费者的三种方法</p>
<p>\31. 启动线程</p>
<p>\32. volatile关键字的作用</p>
<p><img src="https://photos.alitaalice.cn/image/20200616210716.png" alt=""></p>
<p>\33. final域的内存语义</p>
<p>\34. 双重检查加锁与延迟初始化</p>
<p>\35. 线程优先级</p>
<p>\36. 什么是线程安全</p>
<p>\37. 线程池线程数量</p>
<p>\38. 线程池超负载了怎么办（jdk内置的拒绝策略）</p>
<p>\39. sleep和wait的区别</p>
<p>\40. Java中的NIO，BIO，AIO分别是什么</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>序列化</title>
    <url>/2020/07/09/%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
  </entry>
  <entry>
    <title>待学习的点</title>
    <url>/2020/07/24/%E5%BE%85%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%82%B9/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2020/08/29/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
  </entry>
  <entry>
    <title>抽象类和接口的区别详解</title>
    <url>/2020/05/11/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍抽象类和接口</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>它不能被实例化，只能被用作 子类的超类。抽象类是被用来创建继承层级里子类的模板。</p>
<p>以JDK中的GenericServlet为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span>, <span class="title">ServletConfig</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// abstract method</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Its implementation</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// other method related to Servlet</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当HttpServlet类继承GenericServlet时，它提供了<strong>service</strong>方法的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServlet</span> <span class="keyword">extends</span> <span class="title">GenericServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// implementation</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Implementation</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Implementation</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// some other methods related to HttpServlet</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口是抽象方法的集合，如果一个类实现了某个接口，那么它就继承了这个接口的抽象方法，这就像契约的模式，如果实现了这个接口，那么就必须确保使用了这些方法，接口只是一种形式，它本身不能实现任何方法，以Externalizable接口为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Externalizable</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当你继承这个接口时，你就必须实现上面的俩个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Externalizable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> employeeId;</span><br><span class="line">    String employeeName;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        employeeId = in.readInt();</span><br><span class="line">        employeeName = (String) in.readObject();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"> </span><br><span class="line">        out.writeInt(employeeId);</span><br><span class="line">        out.writeObject(employeeName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="什么时候使用抽象类和接口？"><a href="#什么时候使用抽象类和接口？" class="headerlink" title="什么时候使用抽象类和接口？"></a>什么时候使用抽象类和接口？</h2><ul>
<li>如果你拥有一些方法，并且想让它们中的一些有默认实现，那么使用抽象类吧</li>
<li>如果你想实现多重继承，那么请使用接口，抽象类不允许多重继承</li>
<li>如果基本功能在不断的进行改变，那么你就需要使用抽象类。如果不断改变基本功能，并且使用接口，那么就需要改变所有实现了该接口的类。</li>
</ul>
<h2 id="JAVA8中的默认方法和静态方法"><a href="#JAVA8中的默认方法和静态方法" class="headerlink" title="JAVA8中的默认方法和静态方法"></a>JAVA8中的默认方法和静态方法</h2><p>Oracle已经开始尝试向接口中引入默认方法和静态方法，依次来减少抽象类和接口之间的差异。</p>
<p>现在我们可以为接口提供默认实现的方法并且不用强制子类来实现它。default方法。</p>
<h2 id="抽象类和接口的异同"><a href="#抽象类和接口的异同" class="headerlink" title="抽象类和接口的异同"></a>抽象类和接口的异同</h2><p>接口和抽象类都是继承树的上层，他们的共同点如下：</p>
<p>1)    都是上层的抽象层。<br>2)    都不能被实例化<br>3)    都能包含抽象的方法，这些抽象的方法用于描述类具备的功能，但是不比提供具体的实现。<br>他们的区别如下：</p>
<p>1)    在抽象类中可以写非抽象的方法，从而避免在子类中重复书写他们，这样可以提高代码的复用性，这是抽象类的优势；接口中只能有抽象的方法。<br>2)    一个类只能继承一个直接父类，这个父类可以是具体的类也可是抽象类；但是一个类可以实现多个接口。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>指针</title>
    <url>/2020/05/04/%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="10-1-指针变量"><a href="#10-1-指针变量" class="headerlink" title="10.1 指针变量"></a>10.1 指针变量</h1><p> 由于通过地址能访问指定的内存存储单元。可以说地址“指向”该内存单元。地址可以形象地称为指针，意思是通过指针能够找到内存单元。<br> <a id="more"></a></p>
<h2 id="1一个变量的地址称为该变量的指针，如果有一个变量专门用来存放另一个变量的地址，那么它就是指针变量。"><a href="#1一个变量的地址称为该变量的指针，如果有一个变量专门用来存放另一个变量的地址，那么它就是指针变量。" class="headerlink" title="1一个变量的地址称为该变量的指针，如果有一个变量专门用来存放另一个变量的地址，那么它就是指针变量。"></a>1一个变量的地址称为该变量的指针，如果有一个变量专门用来存放另一个变量的地址，那么它就是指针变量。</h2><p>一般形式为：<br>类型说明 * 变量名<br>int * q;<br>C语言中提供了地址运算符“&amp;”来表示变量的地址。其中一般形式为：<br>&amp;变量名;</p>
<h2 id="2给指针变量赋值一般有俩个方法"><a href="#2给指针变量赋值一般有俩个方法" class="headerlink" title="2给指针变量赋值一般有俩个方法"></a>2给指针变量赋值一般有俩个方法</h2><p>1   </p>
<pre><code>int a;
int *p=&amp;a;</code></pre><p>2       </p>
<pre><code>int a;
int *p;
p=&amp;a;</code></pre><h2 id="3-指针变量的引用"><a href="#3-指针变量的引用" class="headerlink" title="3 指针变量的引用"></a>3 指针变量的引用</h2><p>引用指针变量是对变量进行间接访问的一种形式</p>
<p>对指针变量的引用形式如下：</p>
<p>*指针变量 其含义是引用指针变量所指向的值</p>
<h2 id="4-amp-和-的区别"><a href="#4-amp-和-的区别" class="headerlink" title="4 &amp; 和 *的区别"></a>4 &amp; 和 *的区别</h2><p> &amp;运算符是一个返回操作数地址的单目运算符，叫做取地址运算符</p>
<p> *运算符是返回指定的地址内的变量的值，叫做指针运算符。</p>
<h2 id="5-指针自增和自减运算"><a href="#5-指针自增和自减运算" class="headerlink" title="5 指针自增和自减运算"></a>5 指针自增和自减运算</h2><p>基本整型变量i在内存中占4个字节，指针P是指向变量i的地址的，p++是指向下一个存放基本整型数的地址。</p>
<h2 id="6-数组与指针"><a href="#6-数组与指针" class="headerlink" title="6 数组与指针"></a>6 数组与指针</h2><p>在定义一个一维数组时，系统会在内存中为该数组分配一个存储空间，其数组的名称就是数组在内存中的首地址。<br>例如：</p>
<p>1     </p>
<pre><code>int *p,a[10]; 
 p=a;</code></pre><p>或</p>
<p>2   </p>
<pre><code>int *p,a[10]; 
p=&amp;a[0];</code></pre><h2 id="7-二维数组与指针"><a href="#7-二维数组与指针" class="headerlink" title="7 二维数组与指针"></a>7 二维数组与指针</h2><p>表示二维数组中元素地址的方法：</p>
<p>&amp;a[0][0]可以看作数组0行0列的首地址，也可以看作二维数组的首地址。</p>
<p>&amp;a[m][n]就是第m行n列元素的地址。而a[0]+n表示第0行第n个元素的地址。</p>
<h2 id="8指针变量作为函数参数"><a href="#8指针变量作为函数参数" class="headerlink" title="8指针变量作为函数参数"></a>8指针变量作为函数参数</h2><p>指针变量也可以作为函数参数</p>
<p>例<br>在swap（int <em>a,int</em> b)中</p>
<p>在函数调用的过程中，主调用函数与被调用函数之间有一个数值传递的过程。函数调用中发生的数据传递是单向的，只能把实际参数的值传递给形式参数，在函数调用的过程中，形式参数的值发生改变，但是实际参数的值不会发生变化。</p>
<p>如果swap(int a,int b) 则不能实现x与y值的互换。</p>
<p>通过指针传递参数可以减少值传递带来的开销，也可以使函数调用不产生值传递。</p>
<h2 id="9返回指针值的函数"><a href="#9返回指针值的函数" class="headerlink" title="9返回指针值的函数"></a>9返回指针值的函数</h2><p>返回的值的类型为指针类型，返回指针值的函数简称为指针函数</p>
<p>定义指针函数的一般形式为 </p>
<p>类型名 *函数名（参数列表） </p>
<p>如   int *fun(int x,int y)</p>
<p>如 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *per(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">int</span> *p;</span><br><span class="line"> p=&amp;Perimeter;</span><br><span class="line"> Perimeter=(a+b)*<span class="number">2</span>;</span><br><span class="line"> <span class="keyword">return</span> p; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>插入排序</title>
    <url>/2020/06/02/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍插入排序</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>转自<a href="https://www.runoob.com/w3cnote/insertion-sort.html">https://www.runoob.com/w3cnote/insertion-sort.html</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">insertionSort</span><span class="params">(arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="keyword">var</span> preIndex, current;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        preIndex = i - <span class="number">1</span>;</span><br><span class="line">        current = arr[i];</span><br><span class="line">        <span class="keyword">while</span>(preIndex &gt;= <span class="number">0</span> &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class="line">            arr[preIndex+<span class="number">1</span>] = arr[preIndex];</span><br><span class="line">            preIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[preIndex+<span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法的稳定性</title>
    <url>/2020/10/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="排序算法稳定性和不稳定性的理解"><a href="#排序算法稳定性和不稳定性的理解" class="headerlink" title="排序算法稳定性和不稳定性的理解"></a>排序算法稳定性和不稳定性的理解</h2><hr>
<h3 id="稳定性初解"><a href="#稳定性初解" class="headerlink" title="稳定性初解"></a>稳定性初解</h3><p>说到稳定性，与之对应就是不稳定性，那么排序算法的稳定性又为何意呢？通俗地讲就是，能保证排序前两个相等的数其在序列的前后位置顺序与排序后它们的前后位置顺序一致。形式化解释如下：一列数中，如果Ai = Aj，Ai位于Aj的前置位，那么经过升降序排序后Ai仍然位于Aj的前置位。</p>
<h3 id="稳定性优劣"><a href="#稳定性优劣" class="headerlink" title="稳定性优劣"></a>稳定性优劣</h3><p>那么排序稳定性又有什么优势和劣势呢？首先优势应该是比较明显的，比如：1. 能够节约时间，稳定性算法会减少一次交换时间（但多了不交换这个限制后，稳定排序的冒泡／插入／选择都是O(n^2);而不稳定排序快排／堆排却是O(nlogn)）;2. 排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用;</p>
<h3 id="各排序算法稳定性分析"><a href="#各排序算法稳定性分析" class="headerlink" title="各排序算法稳定性分析"></a>各排序算法稳定性分析</h3><h4 id="稳定性排序算法"><a href="#稳定性排序算法" class="headerlink" title="稳定性排序算法"></a>稳定性排序算法</h4><p>（1）冒泡排序<br>冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。</p>
<p>（2）插入排序<br>插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。</p>
<p>（3）归并排序<br>归并排序是在分解的子列中，有1个或2个元素时，1个元素不会交换，2个元素如果大小相等也不会交换。在序列合并的过程中，如果两个当前元素相等时，我们把处在前面的序列的元素保存在结果序列的前面，所以，归并排序也是稳定的。</p>
<p>（4）基数排序<br>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p>
<h4 id="不稳定排序算法"><a href="#不稳定排序算法" class="headerlink" title="不稳定排序算法"></a>不稳定排序算法</h4><p>（1）简单选择排序<br>排序算法在一趟选择中，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。光说可能有点模糊，来看个小实例：858410，第一遍扫描，第1个元素8会和4交换，那么原序列中2个8的相对前后顺序和原序列不一致了，所以选择排序不稳定。</p>
<p>（2）快速排序<br>快速排序有两个方向，左边的i下标一直往右走，当a[i] &lt;= a[center_index]，其中center_index是中枢元素的数组下标，一般取为数组第0个元素。而右边的j下标一直往左走，当a[j] &gt; a[center_index]。如果i和j都走不动了，i &lt;= j，交换a[i]和a[j],重复上面的过程，直到i &gt; j。 交换a[j]和a[center_index]，完成一趟快速排序。在中枢元素和a[j]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为5 3 3 4 3 8 9 10 11，现在中枢元素5和3（第5个元素，下标从1开始计）交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j] 交换的时刻。</p>
<p>（3）希尔排序<br>希尔排序是按照不同步长对元素进行插入排序，一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，稳定性就会被破坏，所以希尔排序不稳定。</p>
<p>（4）堆排序<br>堆排序的过程是从第n/2开始和其子节点共3个值选择最大(大顶堆)或者最小(小顶堆),这3个元素之间的选择当然不会破坏稳定性。但当为n/2-1, n/2-2, …这些父节点选择元素时，有可能第n/2个父节点交换把后面一个元素交换过去了，而第n/2-1个父节点把后面一个相同的元素没有交换，所以堆排序并不稳定。</p>
<h4 id="注：附上一张各个排序算法的稳定性以及时间空间复杂度的图"><a href="#注：附上一张各个排序算法的稳定性以及时间空间复杂度的图" class="headerlink" title="注：附上一张各个排序算法的稳定性以及时间空间复杂度的图"></a>注：附上一张各个排序算法的稳定性以及时间空间复杂度的图</h4><p><img src="https://img-blog.csdn.net/20170301012851776?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenlmNTIwY2hpbmE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
]]></content>
  </entry>
  <entry>
    <title>数据库相关</title>
    <url>/2020/06/02/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍数据库相关。</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-MyISAM和-InnoDB的区别"><a href="#1-MyISAM和-InnoDB的区别" class="headerlink" title="1 MyISAM和 InnoDB的区别"></a>1 MyISAM和 InnoDB的区别</h3><p><strong>区别：</strong></p>
<p>\1. InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</p>
<p>\2. InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；  </p>
<p>\3. InnoDB 是聚集索引，MyISAM 是非聚集索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。 </p>
<p>\4. InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；    </p>
<p>\5. InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</p>
<p><strong>如何选择：</strong></p>
<p>\1. 是否要支持事务，如果要请选择 InnoDB，如果不需要可以考虑 MyISAM；</p>
<p>\2. 如果表中绝大多数都只是读查询，可以考虑 MyISAM，如果既有读写也挺频繁，请使用InnoDB。</p>
<p>\3. 系统奔溃后，MyISAM恢复起来更困难，能否接受，不能接受就选 InnoDB；</p>
<p> \4. MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的。如果你不知道用什么存储引擎，那就用InnoDB，至少不会差。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>文件路径</title>
    <url>/2020/08/19/%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍文件路径中，“/”、“\”与“\”三种符号的区别</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>1、指本地目录的，在不同系统的情况： windows下是\，linux和unix下是/。</p>
<p>2、网络路径使用的是/</p>
<p><strong>出现在普通字符串中的路径，如果代表的是windows文件路径，则使用斜杆/和反斜杠\是一样的；如果代表的是网络文件路径，则必须使用 斜杠/</strong></p>
<p>而在程序中，字符串中的“ \ \”主要是为了转义，“\ \”转义后被理解为“\”，</p>
<p>如果是 / 就不需要使用转义了 。</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>散列表详解</title>
    <url>/2020/05/13/%E6%95%A3%E5%88%97%E8%A1%A8%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍散列表。</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><p>我们面对的第一个问题就是散列函数的计算，这个过程会将键转化为数组的索引。如果我们有一个能够保存 M个键值对的数组，那么我们就需要一个能够将任意键转化为该数组范围内的索引([0,M-1] 范围内的整数）的散列函数 -</p>
<p>散列函数和键的类型有关。<strong>严格地说，对于每种类型的键都我们都需要一个与之对应的散列函数 。</strong>如果键是一个数，比如社会保险号，我们就可以直接使用这个数；如果键是一个字符串，比如一个人的名字，<br>我们就需要将这个字符串转化为一个数；<strong>如果键含有多个部分，比如邮件地址，我们需要用某种方法将这些部分结合起来</strong>。对于许多常见类型的键，我们可以利用 Java 提供的默认实现。我们会简略讨论多种数<br>据类型的散列函数。你应该看看它们是如何实现的，因为你也需要为自定义的类型实现散列函数。  </p>
<h3 id="正整数"><a href="#正整数" class="headerlink" title="正整数"></a>正整数</h3><p>将整数散列最常用方法是<strong>除留余数法</strong> 。我们选择大小为素数 的数组，对于任意正整数 ，计算除以M 的余数。这个函数的计算非常容易（在 Java 中为 k% M ）并能够有效地将键散布在 0 到M-1的范围内。  </p>
<p><img src="https://photos.alitaalice.cn/image/20200513162105.png" alt=""></p>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>如果键是 0 到 1 之间的实数，我们可以将它乘以 M并四舍五入得到一个 0 至 M-1之间的索引值。<br>尽管这个方法很容易理解，但它是有缺陷的，因为这种情况下键的高位起的作用更大，最低位对散列的结果没有影响。修正这个问题的办法是将键表示为二进制数然后再使用除留余数法（Java 就是这么做的）  </p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h2 id="组合键"><a href="#组合键" class="headerlink" title="组合键"></a>组合键</h2><h2 id="JAVA的约定"><a href="#JAVA的约定" class="headerlink" title="JAVA的约定"></a>JAVA的约定</h2><p>每种数据类型都需要相应的散列函数，于是 Java 令所有数据类型都继承了一个能够返回一个 32 比特整数的 hashCode() 方法。每一种数据类型的 hashCode() 方法都必须和 equals() 方法一致 。也就是说，如果 a.equals(b) 返回 true ，那么 a.hashCode() 的返回值必然和 b.hashCode()的返回值相同。相反，如果两个对象的 hashCode() 方法的返回值不同，那么我们就知道这两个对象是不同的。但如果两个对象的 hashCode() 方法的返回值相同，这两个对象也有可能不同，我们还需要用equals() 方法进行判断。请注意，这说明如果你要为自定义的数据类型定义散列函数，你需要同时重写 hashCode() 和 equals() 两个方法。默认散列函数会返回对象的内存地址，但这只适用于很少的情况。Java 为很多常用的数据类型重写了 hashCode() 方法（包括 String 、Integer 、Double、File 和 URL ）。  </p>
<h3 id="将hashCode-的返回值转化为一个数组索引"><a href="#将hashCode-的返回值转化为一个数组索引" class="headerlink" title="将hashCode()的返回值转化为一个数组索引"></a>将hashCode()的返回值转化为一个数组索引</h3><p>因为我们需要的是数组的索引而不是一个 32 位的整数，我们在实现中会将默认的 hashCode() 方法和除留余数法结合起来产生一个 0 到M-1 的整数，方法如下：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key x)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> (x.hashCode() &amp; <span class="number">0x7fffffff</span>) % M; &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码会将符号位屏蔽（将一个 32 位整数变为一个 31 位非负整数），然后用除留余数法计算它除以M 的余数。在使用这样的代码时我们一般会将数组的大小 M 取为素数 以充分利用原散列值的所有位。  </p>
<h3 id="自定义的hashCode-方法"><a href="#自定义的hashCode-方法" class="headerlink" title="自定义的hashCode()方法"></a>自定义的hashCode()方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transaction</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String who;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Date when;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> amount;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> hash = <span class="number">17</span>;</span><br><span class="line">hash = <span class="number">31</span> * hash + who.hashCode();</span><br><span class="line">hash = <span class="number">31</span> * hash + when.hashCode();</span><br><span class="line">hash = <span class="number">31</span> * hash+ ((Double) amount).hashCode();</span><br><span class="line"><span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义类型中 hashCode() 方法的实现  </p>
<p>对于原始类型的对象，可以将其转化为对应的数据类型然后再调用 hashCode() 方法。和以前一样，系数的具体值（这里是 31）并不是很重要。  </p>
<h3 id="软缓存"><a href="#软缓存" class="headerlink" title="软缓存"></a>软缓存</h3><p>如果散列值的计算很耗时，那么我们或许可以将每个键的散列值缓存起来 ，即在每个键中使用一个hash 变量来保存它的 hashCode() 的返回值（请见练习 3.4.25）。第一次调用 hashCode() 方法时，我们需要计算对象的散列值，但之后对 hashCode() 方法的调用会直接返回 hash 变量的值。<br>Java 的 String 对象的 hashCode() 方法就使用了这种方法来减少计算量。  </p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库总复习</title>
    <url>/2020/09/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%BB%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍数据库总复习</p>
<p>总复习2   1小时后的做题讲解</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="1-create-alter-drop-insert-delete-update"><a href="#1-create-alter-drop-insert-delete-update" class="headerlink" title="1 create alter drop insert delete update"></a>1 create alter drop insert delete update</h2><h2 id="2-创建一个表的命令-列级约束和表级约束的区别"><a href="#2-创建一个表的命令-列级约束和表级约束的区别" class="headerlink" title="2 创建一个表的命令  列级约束和表级约束的区别"></a>2 创建一个表的命令  列级约束和表级约束的区别</h2><p><img src="https://photos.alitaalice.cn/image/20200910144359.png" alt=""></p>
<p>check  约束 域完整约束</p>
<p>default 约束</p>
<p>完整性约束</p>
<ul>
<li>实体完整性  实体完整性这项规则要求每个数据表都必须有主键,而作为主键的所有字段,其属性必须是独一及非空值</li>
<li>参照完整性</li>
<li>用户自定义的完整性</li>
</ul>
<h2 id="3-创建表实例：-填空"><a href="#3-创建表实例：-填空" class="headerlink" title="3 创建表实例：  填空"></a>3 创建表实例：  <strong>填空</strong></h2><p><img src="https://photos.alitaalice.cn/image/20200910144915.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200910145413.png" alt=""></p>
<h2 id="4-修改表结构的实例-考点"><a href="#4-修改表结构的实例-考点" class="headerlink" title="4 修改表结构的实例 考点"></a>4 修改表结构的实例 <strong>考点</strong></h2><ul>
<li><p>修改已有列</p>
</li>
<li><p>增加新列</p>
</li>
<li><p>删除指定的完整性约束或指定的列</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alter table 基础.职工</span><br><span class="line"></span><br><span class="line">drop constraint ref_wh </span><br><span class="line"><span class="comment">##############################</span></span><br><span class="line">alter table 基础.职工</span><br><span class="line">add constraint ref_wh</span><br><span class="line">foreign key (仓库号) references 仓储.仓库（仓库号）</span><br><span class="line"><span class="comment">########################</span></span><br><span class="line">alter table 订货.订购明细</span><br><span class="line">add 完成日期 datetime</span><br><span class="line"><span class="comment">#########</span></span><br><span class="line">alter table 订购.订购明细</span><br><span class="line">drop column 完成日期</span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line">alter table 订货.订购单</span><br><span class="line">add 完成日期 datetime default null</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="5-查询"><a href="#5-查询" class="headerlink" title="5 查询"></a>5 查询</h1><p><img src="https://photos.alitaalice.cn/image/20200910150605.png" alt=""></p>
<h3 id="1-简单查询"><a href="#1-简单查询" class="headerlink" title="1 简单查询"></a>1 简单查询</h3><p>where   and not or   </p>
<p>between and</p>
<p>like</p>
<p>in</p>
<p>distinct</p>
<p>all any</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ny 是任意一个</span><br><span class="line">all 是所有</span><br><span class="line"></span><br><span class="line">any表示有任何一个满足就返回<span class="literal">true</span>，all表示全部都满足才返回<span class="literal">true</span></span><br><span class="line">**感觉这句很清楚</span><br><span class="line"></span><br><span class="line">比如</span><br><span class="line">select * from student <span class="built_in">where</span> 班级=’01’ and age &gt; all (select age from student <span class="built_in">where</span> 班级=’02’);</span><br><span class="line">就是说，查询出01班中，年龄大于 02班所有人的同学</span><br><span class="line">相当于</span><br><span class="line">select * from student <span class="built_in">where</span> 班级=’01’ and age &gt; (select max(age) from student <span class="built_in">where</span> 班级=’02’);</span><br><span class="line"></span><br><span class="line">而</span><br><span class="line">select * from student <span class="built_in">where</span> 班级=’01’ and age &gt; any (select age from student <span class="built_in">where</span> 班级=’02’);</span><br><span class="line">就是说，查询出01班中，年龄大于 02班任意一个 的 同学</span><br><span class="line">相当于</span><br><span class="line">select * from student <span class="built_in">where</span> 班级=’01’ and age &gt; (select min(age) from student <span class="built_in">where</span> 班级=’02’);</span><br></pre></td></tr></table></figure>

<h3 id="2-连接查询"><a href="#2-连接查询" class="headerlink" title="2 连接查询"></a>2 连接查询</h3><p>外连接</p>
<p>内连接</p>
<p>自连接</p>
<h3 id="3-聚合函数"><a href="#3-聚合函数" class="headerlink" title="3 聚合函数"></a>3 聚合函数</h3><h3 id="4-分组"><a href="#4-分组" class="headerlink" title="4 分组"></a>4 分组</h3><p>  group by </p>
<p>  having （和聚合函数联合使用   对分组结果进行二次筛选）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">select 仓库号,count(*),avg(工资) from 基础.职工</span><br><span class="line"><span class="built_in">where</span> 工资&gt;1250  group by 仓库号 having count(*)&gt;=2</span><br></pre></td></tr></table></figure>

<h3 id="5-not-in"><a href="#5-not-in" class="headerlink" title="5 not in"></a>5 not in</h3><p>not exists</p>
<p>exists  </p>
<h1 id="6-视图-考"><a href="#6-视图-考" class="headerlink" title="6 视图  考"></a>6 视图  考</h1><p>如何建立视图   视图修改不考</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create view as</span><br><span class="line">xxxx</span><br></pre></td></tr></table></figure>

<p>建索引 </p>
<p>改表结构 建表</p>
<h1 id="7-关系代数"><a href="#7-关系代数" class="headerlink" title="7 关系代数"></a>7 关系代数</h1><h1 id="8-游标"><a href="#8-游标" class="headerlink" title="8 游标"></a>8 游标</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int a; -----&gt;<span class="built_in">declare</span> @int a;</span><br></pre></td></tr></table></figure>

<p>定义一个游标</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">declare</span> cur_sc cursor <span class="keyword">for</span></span><br><span class="line">select * from sc`</span><br><span class="line">open cur_sc</span><br><span class="line">fetch next from cur_sc</span><br></pre></td></tr></table></figure>

<p>步骤：</p>
<p><img src="https://photos.alitaalice.cn/image/20200910154736.png" alt=""></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">declare</span> xcur cursor <span class="keyword">for</span> </span><br><span class="line">select * from student</span><br><span class="line"><span class="built_in">where</span> studentname like <span class="string">'张%'</span> order by studentName </span><br><span class="line">open xcur</span><br><span class="line">fetch next from xcur</span><br><span class="line"><span class="keyword">while</span> @@fetch_status=0</span><br><span class="line">begin</span><br><span class="line">fetch next from xcur </span><br><span class="line">end</span><br><span class="line">close xcur</span><br><span class="line">deallocate xcur</span><br><span class="line"><span class="comment">##############################</span></span><br><span class="line">@@fetch_status</span><br><span class="line">0  上一个执行成功</span><br><span class="line">-1 被提取的行不在结果集</span><br><span class="line">-2 被提取的行已经不存在</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">字符串拼接的游标如何操作？</span><br><span class="line"><span class="comment">############################</span></span><br><span class="line"><span class="built_in">declare</span> @学号 varchar(40),@姓名 varchar(20),@年龄 int</span><br><span class="line"><span class="built_in">declare</span> xcursor cursor <span class="keyword">for</span></span><br><span class="line">select 学号，姓名，年龄 from 学生基本信息表</span><br><span class="line"><span class="built_in">where</span> 姓名 like <span class="string">'张%'</span></span><br><span class="line">order by 姓名</span><br><span class="line">open xcursor</span><br><span class="line">fetch next from xcursor into @学号，@姓名，@年龄</span><br><span class="line"><span class="keyword">while</span> @@fetch_status=0</span><br><span class="line">begin</span><br><span class="line"><span class="built_in">print</span> <span class="string">'学生姓名为'</span>+@姓名+<span class="string">'学号为'</span>+@学号+<span class="string">'年龄为'</span>+cast(@年龄 as char(3))</span><br><span class="line">fetch next from xcursor into @学号，@姓名，@年龄</span><br><span class="line">END</span><br><span class="line">CLOSE xcursor</span><br><span class="line">deallocate xcursor</span><br></pre></td></tr></table></figure>

<p><img src="https://photos.alitaalice.cn/image/20200910163501.png" alt=""></p>
<h1 id="9-存储过程"><a href="#9-存储过程" class="headerlink" title="9 存储过程"></a>9 存储过程</h1><p><img src="https://photos.alitaalice.cn/image/20200910164606.png" alt=""></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create procedure proc_bjrs</span><br><span class="line">as</span><br><span class="line">xxxxxxxxxxx</span><br><span class="line">go</span><br><span class="line">execute proc_bjrs</span><br><span class="line"></span><br><span class="line"><span class="comment">###########################</span></span><br><span class="line">输入参数 查询</span><br><span class="line"><span class="comment">#######################</span></span><br><span class="line">create procedure proc_bjcx (@bjbh varchar(8))</span><br><span class="line">as</span><br><span class="line">select *from 学生基本信息表 <span class="built_in">where</span> 班级编号=@bjbh</span><br><span class="line">go</span><br><span class="line">其中@bjbh用于接收班级编号</span><br><span class="line">execute proc_bjcx <span class="string">'20092221'</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">############# ######</span></span><br><span class="line">示例  输入参数</span><br><span class="line"><span class="comment">##################</span></span><br><span class="line">create procedure update_course</span><br><span class="line">(@course_name varchar(20)=NULL,@xf int=NULL)  <span class="comment">##默认值</span></span><br><span class="line">as</span><br><span class="line"><span class="keyword">if</span> @course_name is NULL</span><br><span class="line">Begin </span><br><span class="line"><span class="built_in">print</span> <span class="string">'必须给出课程名'</span></span><br><span class="line"><span class="built_in">return</span> -4</span><br><span class="line">end</span><br><span class="line"><span class="keyword">if</span> @xf is NULL</span><br><span class="line">Begin</span><br><span class="line"><span class="built_in">print</span> <span class="string">'必须给出学分'</span></span><br><span class="line"><span class="built_in">return</span> -3</span><br><span class="line">end</span><br><span class="line"><span class="keyword">if</span> @xf&lt;1 of @xf&gt;6</span><br><span class="line">Begin</span><br><span class="line"><span class="built_in">print</span> <span class="string">'学费必须为1到6之间的整数'</span></span><br><span class="line">end</span><br><span class="line"><span class="keyword">if</span> not exists(select * from 课程 <span class="built_in">where</span> 课程名=@curse_name)</span><br><span class="line">begin</span><br><span class="line"><span class="built_in">print</span> <span class="string">'该课程不存在'</span></span><br><span class="line"><span class="built_in">return</span> -2</span><br><span class="line">end</span><br><span class="line">update 课程 <span class="built_in">set</span> 学分=@xf <span class="built_in">where</span> 课程名=@curse_name</span><br><span class="line"><span class="built_in">return</span> 0</span><br><span class="line"></span><br><span class="line">execute update_course <span class="string">'数据库'</span>,<span class="string">'4'</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">存储过程的输出参数</span><br><span class="line"><span class="comment">###################################################</span></span><br><span class="line">use school</span><br><span class="line">go</span><br><span class="line">create procedure average(@st_no int,@st_name char(8) output,@st_avg <span class="built_in">float</span> output)As</span><br><span class="line">select @st_name=student.sname,@st_avg=avg(score.degree)</span><br><span class="line">from student,score</span><br><span class="line"><span class="built_in">where</span> student.sno=score.snp group by student.sno having</span><br><span class="line">student.sno=@st_no</span><br><span class="line"><span class="built_in">declare</span> @st_name char(8)</span><br><span class="line"><span class="built_in">declare</span> @st_avg <span class="built_in">float</span></span><br><span class="line">execute average 108,@st_name output,@st_avg output</span><br><span class="line">select <span class="string">'姓名'</span>=@st_name,<span class="string">'平均分'</span>=@st_avg</span><br><span class="line">go</span><br><span class="line"></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line"><span class="built_in">return</span> 的输出</span><br><span class="line">use <span class="built_in">test</span></span><br><span class="line">go</span><br><span class="line">create procedure  test_rest(@input_int int=0)as</span><br><span class="line"><span class="keyword">if</span> @input_int=0 <span class="built_in">return</span> 0</span><br><span class="line"><span class="keyword">if</span> @input_int&lt;0 <span class="built_in">return</span> -1000</span><br><span class="line"><span class="keyword">if</span> @input_int&gt;0 <span class="built_in">return</span> 1000</span><br><span class="line"><span class="built_in">declare</span> @ret_int int</span><br><span class="line">execute @ret_int=test_ret 1</span><br><span class="line"><span class="built_in">print</span> @ret_int</span><br><span class="line">execute @ret_int=test_ret 0</span><br><span class="line"><span class="built_in">print</span> @ret_int</span><br><span class="line">execute @ret_int=test_ret -1</span><br><span class="line"><span class="built_in">print</span> @ret_int</span><br></pre></td></tr></table></figure>

<h1 id="10-触发器"><a href="#10-触发器" class="headerlink" title="10.触发器"></a>10.触发器</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">触发器 特殊的存储过程 insert delete update触发器</span><br><span class="line">inserted deleted 临时表</span><br><span class="line"></span><br><span class="line">级联删</span><br><span class="line">use xscj</span><br><span class="line">go</span><br><span class="line">create trigger del_bj on 班级表</span><br><span class="line"><span class="keyword">for</span> delete</span><br><span class="line">as</span><br><span class="line">delete from 学生基本信息表 <span class="built_in">where</span> 班级编号 </span><br><span class="line"><span class="keyword">in</span> (select 班级编号 from deleted)</span><br><span class="line">go</span><br><span class="line">空值删</span><br><span class="line">create tigger del_course on 课程 <span class="keyword">for</span> delete</span><br><span class="line">as</span><br><span class="line"><span class="keyword">if</span> exists(select *from 成绩 <span class="built_in">where</span> 课程编号 <span class="keyword">in</span>(select 课程编号 from deleted))</span><br><span class="line">begin</span><br><span class="line">update 成绩 <span class="built_in">set</span> 课程编号=null <span class="built_in">where</span> 课程编号 <span class="keyword">in</span>(select 课程编号 from deleted)</span><br><span class="line">end</span><br><span class="line">拒绝删</span><br></pre></td></tr></table></figure>

<h1 id="11-依赖关系和范式"><a href="#11-依赖关系和范式" class="headerlink" title="11 依赖关系和范式"></a>11 依赖关系和范式</h1><h1 id="12-ER图"><a href="#12-ER图" class="headerlink" title="12 ER图"></a>12 ER图</h1><p><img src="https://photos.alitaalice.cn/image/20200912203951.png" alt=""></p>
<p>外模式/模式的映象。<br>保证了数据的逻辑独立性  </p>
<p>模式/内模式的映象保证了数据的物理独立性，   </p>
<p>数据库系统的三级模式结构由外 模式、模式个内模式组成。</p>
<blockquote>
<p>(1)外模式，亦称子模式或者用户模式（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。<br>(2)模式，亦称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。模式描述的是数据的全局逻辑结构。<br>(3)内模式，亦称存储模式，是数据在数据库系统内部的表示，即对数据的物理结构和存储方式的描述。</p>
</blockquote>
<p>数据库系统的三级模式是对数据的三个抽象级别，它把<strong>数据的具体组织留给DBMS管理，使用户能逻辑抽象地处理数据，而不必关心数据在计算机中的表示和存储</strong>。为了能够在内部实现这三个抽象层次的联系和转换，数据库系统在这三级模式之间提供了两层映像：外模式/模式映像和模式/内模式映像。正是这两层映像<strong>保证了数据库系统中的数据能够具有较高的逻辑独立性和物理独立性</strong></p>
<h1 id="13-数据库的安全性"><a href="#13-数据库的安全性" class="headerlink" title="13 数据库的安全性"></a>13 数据库的安全性</h1><p><strong>第一关、对用户安全管理</strong></p>
<p><strong>第二关、定义视图</strong></p>
<p><strong>第三关、数据加密</strong></p>
<p><strong>第四关、事务管理和故障恢复</strong></p>
<p><strong>第五关、数据库备份与恢复</strong></p>
<p><strong>第六关、审计追踪机制</strong></p>
<p><strong>第七关、重点在服务器</strong></p>
<p><img src="https://photos.alitaalice.cn/image/20200912222436.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200912223121.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200912223401.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200912223524.png" alt=""></p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>方法宗量</title>
    <url>/2020/05/28/%E6%96%B9%E6%B3%95%E5%AE%97%E9%87%8F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍方法宗量。</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>宗量：方法的接收者和方法的参数统称为方法的宗量。</p>
<p>宗量（argument）,可以理解为<a href="https://en.wikipedia.org/wiki/Argument_of_a_function">自变量</a>，在计算机科学中可能当成<a href="https://en.wikipedia.org/wiki/Parameter_(computer_programming)">形式参数</a>更好理解一些。</p>
<p>方法的接收者，在运行时可以理解为方法的实际执行者。</p>
<p>看一下下面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doRead</span><span class="params">(Book b)</span></span>&#123;</span><br><span class="line">    b.read();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类方法 <code>Book.doRead(Book)</code> 他的接收者就是 <code>Book</code> 这个类对象，他的参数 <code>b</code> 是一个形式参数。意思是在方法没被调用前，b 没有具体的值，就只是一个形式而已，相当于于一个占位符。再来看方法体:<code>b.read()</code>，我们可以说<code>b.read()</code>一定是指向<code>Book#read</code>这个方法吗？也可以不严谨的说 <code>read</code> 的执行者 <code>b</code> 一定是 <code>Book</code> 对象吗？不行的，因为面向对象的多态性，<strong>父类的方法是可以被子类重写的</strong>。只有运行时，我们调用这个方法时才可以确定方法的接收者，比如 <code>Book.doRead(new Magazine())</code>，在运行时实际指向的是 <code>Magazine#read</code>。所以说方法的接收者是形式变量(宗量)。</p>
]]></content>
      <categories>
        <category>JAVASE</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2020/05/14/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍归并排序</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在本节中我们所讨论的算法都基于归并 这个简单的操作，即将两个有序的数组归并成一个更大的有序数组。很快人们就根据这个操作发明了一种简单的递归排序算法：<strong>归并排序</strong> 。  </p>
<p><img src="https://photos.alitaalice.cn/image/20200514103423.png" alt=""></p>
<p>​                                         归并排序示意图  </p>
<h2 id="原地归并"><a href="#原地归并" class="headerlink" title="原地归并"></a>原地归并</h2>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>时间复杂度</title>
    <url>/2020/05/05/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h1><h2 id="算法时间复杂度定义"><a href="#算法时间复杂度定义" class="headerlink" title="算法时间复杂度定义"></a>算法时间复杂度定义</h2><ul>
<li><p>O()来体现算法时间复杂度的记法</p>
<a id="more"></a>

<h2 id="推导大O阶的方法"><a href="#推导大O阶的方法" class="headerlink" title="推导大O阶的方法"></a>推导大O阶的方法</h2><ol>
<li><p>用常数1代替所有加法常数</p>
</li>
<li><p>在修改后的运行次数函数中，只保留最高阶项</p>
</li>
<li><p>如果最高阶项存在且不是1，则去除这个项相乘的常数</p>
<p>得到的结果就是大O阶.</p>
<h3 id="举例说明："><a href="#举例说明：" class="headerlink" title="举例说明："></a>举例说明：</h3><h4 id="常数阶"><a href="#常数阶" class="headerlink" title="常数阶"></a>常数阶</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>,n=<span class="number">100</span>; <span class="comment">//执行1次</span></span><br><span class="line">sum=(<span class="number">1</span>+n)*n/<span class="number">2</span>; <span class="comment">//执行2次</span></span><br><span class="line">sum=(<span class="number">1</span>+n)*n/<span class="number">2</span>; <span class="comment">//</span></span><br><span class="line">sum=(<span class="number">1</span>+n)*n/<span class="number">2</span>; <span class="comment">//</span></span><br><span class="line">sum=(<span class="number">1</span>+n)*n/<span class="number">2</span>; <span class="comment">//</span></span><br><span class="line">...</span><br><span class="line">sum=(<span class="number">1</span>+n)*n/<span class="number">2</span>; <span class="comment">//执行10次</span></span><br></pre></td></tr></table></figure>

<p>事实上无论n为多少，上面代码就是1次，2次，10次的差别，这种与问题大小无关（与n的大小无关）执行时间恒定的算法。称为O(1)阶，又叫常数阶</p>
<h4 id="线性阶"><a href="#线性阶" class="headerlink" title="线性阶"></a>线性阶</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 时间复杂度为O(1)的程序     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<p>​               循环的时间复杂度为O(n)</p>
<h4 id="对数阶"><a href="#对数阶" class="headerlink" title="对数阶"></a>对数阶</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int count&#x3D;1;</span><br><span class="line">while (count &lt;n)</span><br><span class="line">&#123;</span><br><span class="line">count &#x3D;count *2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2^x=n  x=log2 n   所以这个循环的时间复杂度为O(log n).</p>
<h4 id="平方阶"><a href="#平方阶" class="headerlink" title="平方阶"></a>平方阶</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">/*时间复杂度为O(1)的程序步骤序列      */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(m*n)</p>
<p>又如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=i;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">/* 时间复杂度为O(1)的程序*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行总次数 n+n-1+(n-2)+…+1=n(n+1)/2   时间复杂度为O(n^2) </p>
<h4 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h4><p>常用时间复杂度耗费时间比对：</p>
<p>O(1)&lt;O(log n)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>方法签名</title>
    <url>/2020/05/28/%E6%96%B9%E6%B3%95%E7%AD%BE%E5%90%8D/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍方法签名</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>方法签名由方法名称和一个参数列表（方法的参数的顺序和类型）组成。<br>注意，方法签名不包括方法的返回类型。不包括返回值和访问修饰符。</p>
]]></content>
      <categories>
        <category>JAVASE</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>模板方法模式</title>
    <url>/2020/05/28/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍模板方法模式</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>定义： 在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>树</title>
    <url>/2020/05/07/%E6%A0%91/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>树的相关概念</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="树的相关概念"><a href="#树的相关概念" class="headerlink" title="树的相关概念"></a>树的相关概念</h2><h3 id="度"><a href="#度" class="headerlink" title="度"></a>度</h3><ul>
<li>结点拥有的子树树称为结点的度</li>
<li>度为0的结点称为叶结点（Leaf）或者终端结点。</li>
<li>度不为0的结点称为非终端结点或者分支结点</li>
<li>树的度是树内各结点度的最大值</li>
</ul>
<h3 id="深度（Depth-或高度"><a href="#深度（Depth-或高度" class="headerlink" title="深度（Depth)或高度"></a>深度（Depth)或高度</h3><ul>
<li>层次：结点的层次从根开始定义起，根为第一层，根的孩子为第二层，以此类推</li>
<li>树中结点的最大层次被称为树的深度（Depth）或者高度。</li>
</ul>
<h3 id="有序树和无序树"><a href="#有序树和无序树" class="headerlink" title="有序树和无序树"></a>有序树和无序树</h3><p>如果将树中结点的各子树看成从左至右是由次序的，不能互换的，那么该树为有序树，否则为无序树。</p>
<h3 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h3><p>森林是m（m&gt;=0)颗互不相交的树的集合。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>测试端口是否打开</title>
    <url>/2020/08/28/%E6%B5%8B%E8%AF%95%E7%AB%AF%E5%8F%A3%E6%98%AF%E5%90%A6%E6%89%93%E5%BC%80/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍如何测试端口是否打开</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="1、telent"><a href="#1、telent" class="headerlink" title="1、telent"></a>1、telent</h2><p>命令：telnet ip port</p>
<p><img src="https://img-blog.csdnimg.cn/20190428140356245.png" alt="img"></p>
<h2 id="2、curl"><a href="#2、curl" class="headerlink" title="2、curl"></a>2、curl</h2><p>命令：curl ip:port</p>
<p><img src="https://img-blog.csdnimg.cn/20190428140522813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIzOTUzNzE3,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="3、ssh"><a href="#3、ssh" class="headerlink" title="3、ssh"></a>3、ssh</h2><p>命令：ssh -v -p port username@ip</p>
<p><img src="https://img-blog.csdnimg.cn/20190428140716326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIzOTUzNzE3,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="4、nc"><a href="#4、nc" class="headerlink" title="4、nc"></a>4、nc</h2><p>命令：nc-v -w 1 ip -z port</p>
<p><img src="https://img-blog.csdnimg.cn/20190428140818643.png" alt="img"></p>
<h2 id="5、wget"><a href="#5、wget" class="headerlink" title="5、wget"></a>5、wget</h2><p>命令：wget ip:port</p>
<p><img src="https://img-blog.csdnimg.cn/20190428140912447.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIzOTUzNzE3,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="6-nmap"><a href="#6-nmap" class="headerlink" title="6.nmap"></a>6.nmap</h2><p>nmap target ip</p>
]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>熔断限流降级</title>
    <url>/2020/09/05/%E7%86%94%E6%96%AD%E9%99%90%E6%B5%81%E9%99%8D%E7%BA%A7/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="1-熔断限流降级"><a href="#1-熔断限流降级" class="headerlink" title="1 熔断限流降级"></a>1 熔断限流降级</h2><p><strong>降级</strong></p>
<p>服务降级是当服务器压力剧增的情况下，<strong>根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行</strong>。降级往往会指定不同的级别，面临不同的异常等级执行不同的处理。根据服务方式：可以拒接服务，可以延迟服务，也有时候可以随机服务。根据服务范围：可以砍掉某个功能，也可以砍掉某些模块。总之服务降级需要根据不同的业务需求采用不同的降级策略。主要的目的就是服务虽然有损但是总比没有好。</p>
<p><strong>限流</strong></p>
<p>限流可以认为服务降级的一种，限流就是限制系统的输入和输出流量已达到保护系统的目的。一般来说系统的吞吐量是可以被测算的，为了保证系统的稳定运行，一旦达到的需要限制的阈值，就需要限制流量并采取一些措施以完成限制流量的目的。比如：延迟处理，拒绝处理，或者部分拒绝处理等等。</p>
<p><strong>熔断</strong></p>
<h2 id="2-线程池参数-线程池的理解"><a href="#2-线程池参数-线程池的理解" class="headerlink" title="2 线程池参数 线程池的理解"></a>2 线程池参数 线程池的理解</h2><h2 id="3-sychnized理解-该怎么用"><a href="#3-sychnized理解-该怎么用" class="headerlink" title="3 sychnized理解 该怎么用"></a>3 sychnized理解 该怎么用</h2><h2 id="4-Redis如何实现消息队列"><a href="#4-Redis如何实现消息队列" class="headerlink" title="4 Redis如何实现消息队列"></a>4 Redis如何实现消息队列</h2><p><img src="https://photos.alitaalice.cn/image/20200907160615.png" alt=""></p>
<h2 id="5-十大算法"><a href="#5-十大算法" class="headerlink" title="5 十大算法"></a>5 十大算法</h2>]]></content>
  </entry>
  <entry>
    <title>状态模式</title>
    <url>/2020/05/28/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/2020/05/14/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍策略模式。</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="策略模式："><a href="#策略模式：" class="headerlink" title="策略模式："></a>策略模式：</h2><p><img src="https://photos.alitaalice.cn/image/20200514101320.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200527205338.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200527205407.png" alt=""></p>
]]></content>
      <categories>
        <category>理论</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>索引基本操作</title>
    <url>/2020/05/29/%E7%B4%A2%E5%BC%95%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
  </entry>
  <entry>
    <title>类加载的过程</title>
    <url>/2020/05/25/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍类加载的过程</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><img src="https://photos.alitaalice.cn/image/20200525210206.png" alt=""></p>
<h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1 加载"></a>1 加载</h3><p>JAVA虚拟机需要完成：</p>
<p>1 通过一个类的全限定名来获取定义此类的二进制字节流</p>
<p>2 通过这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p>
<p>3 在内存中生成一个代表这个类的java.lang.Class对象 作为方法区这个类的各种数据的访问入口。</p>
<h3 id="2-验证"><a href="#2-验证" class="headerlink" title="2 验证"></a>2 验证</h3><p>验证是连接阶段的第一步，这么做是确保Class文件的字节流中包含的信息符合《JAVA虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全</p>
<p>分为：</p>
<p>1 文件格式验证</p>
<p>2 元数据验证</p>
<p>3 字节码验证</p>
<p>4 符号引用验证</p>
<h3 id="3-准备"><a href="#3-准备" class="headerlink" title="3 准备"></a>3 准备</h3><p>准备阶段是正式为类中定义的变量（静态变量、被static修饰的变量）分配内存并设置类变量初始值的阶段，从概念上讲，这些变量所使用的内存都应当在方法区中进行分配</p>
<h3 id="4-解析"><a href="#4-解析" class="headerlink" title="4 解析"></a>4 解析</h3><p>解析阶段是JAVA虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<p>符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量</p>
<p>直接引用：直接引用是可以直接指向目标的指针</p>
<h3 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5 初始化"></a>5 初始化</h3><p>直到初始化阶段，JAVA虚拟机才真正开始执行类中编写的JAVA程序代码，将主导权移交给应用程序。</p>
<p>初始化阶段就是执行类构造器<clinit>()方法的过程。<clinit>()并不是程序员在JAVA代码中直接编写的方法，它是JAVAC编译器的自动生成物，</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>线性表</title>
    <url>/2020/05/05/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h2 id="线性表的定义："><a href="#线性表的定义：" class="headerlink" title="线性表的定义："></a>线性表的定义：</h2><ul>
<li>线性表：零个或多个数据元素的有限序列</li>
<li>线性表元素的个数n 定义为线性表的长度，当n=0时，称为空表<a id="more"></a>

</li>
</ul>
<h2 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h2><ul>
<li><p>顺序存储定义： 线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素</p>
<h3 id="顺序存储方式"><a href="#顺序存储方式" class="headerlink" title="顺序存储方式"></a>顺序存储方式</h3><ul>
<li><p>顺序存储的结构代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>

<p>MAXSIZE：数组长度</p>
<p>length： 线性表当前的长度</p>
<p>另外以数组data进行存储</p>
</li>
<li><p>线性表中的地址</p>
<p>存储器中的每个存储单元都有自己的编号，这个编号称为地址。</p>
<h3 id="顺序存储结构的插入与删除"><a href="#顺序存储结构的插入与删除" class="headerlink" title="顺序存储结构的插入与删除"></a>顺序存储结构的插入与删除</h3><h4 id="获得元素操作"><a href="#获得元素操作" class="headerlink" title="获得元素操作"></a>获得元素操作</h4><p>我们实现GetElem操作，即把线性表L中的第i个元素值返回。只要i的数值在数组范围内，就是把数组的第i-1下标返回即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status; <span class="comment">/*函数的类型 */</span></span><br><span class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(SqList L,<span class="keyword">int</span> i,ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L.length==<span class="number">0</span> ||i&lt;<span class="number">1</span> ||i&gt;L.length)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    *e=L.data[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>算法思路：</p>
<ul>
<li><p>插入位置不合理</p>
</li>
<li><p>线性表长度大于数组长度</p>
</li>
<li><p>从最后一个元素遍历到第i个元素</p>
</li>
<li><p>将要插入的元素填到位置i处</p>
</li>
<li><p>表长+1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(SqList *L,<span class="keyword">int</span> i,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">if</span>(L-&gt;length==MAXSIZE)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L-&gt;length+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="keyword">if</span>(i&lt;=L-&gt;length)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(k=L-&gt;length<span class="number">-1</span>;k&gt;=i<span class="number">-1</span>;k--)</span><br><span class="line">&#123;</span><br><span class="line">L-&gt;data[k+<span class="number">1</span>]=L-&gt;data[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">L-&gt;data[i<span class="number">-1</span>]=e;</span><br><span class="line">L-&gt;length++;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>线程和进程的区别</title>
    <url>/2020/06/09/%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍线程和进程的区别。</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>转<a href="https://blog.csdn.net/ThinkWon/article/details/102021274">https://blog.csdn.net/ThinkWon/article/details/102021274</a></p>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理第一章</title>
    <url>/2020/08/19/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍编译原理</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><img src="https://photos.alitaalice.cn/image/20200819115543.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200819115719.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200819120008.png" alt=""></p>
<p>正规闭包差别就在于空字上</p>
<p><img src="https://photos.alitaalice.cn/image/20200819120214.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200819120533.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200819120834.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200819120956.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200819121910.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200819122006.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200819122127.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200819122419.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200819122520.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200819122747.png" alt=""></p>
<h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p><img src="https://photos.alitaalice.cn/image/20200819162130.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200819162608.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200819162800.png" alt=""></p>
<p>把最后读入的标识符退出去 *</p>
<h6 id="字母或者数字-标识符"><a href="#字母或者数字-标识符" class="headerlink" title="字母或者数字  标识符"></a>字母或者数字  标识符</h6><p>数字 ： 整常数</p>
<p><img src="https://photos.alitaalice.cn/image/20200819163056.png" alt=""></p>
<h2 id="正规式和正规集"><a href="#正规式和正规集" class="headerlink" title="正规式和正规集"></a>正规式和正规集</h2><p><img src="https://photos.alitaalice.cn/image/20200915092231.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200915093318.png" alt=""></p>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理-语法分析</title>
    <url>/2020/08/20/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍编译原理_语法分析</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><img src="https://photos.alitaalice.cn/image/20200820120728.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200820120431.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200820121022.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200820121244.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200820121942.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200820122216.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200820122746.png" alt="        "></p>
<h2 id="First集合"><a href="#First集合" class="headerlink" title="First集合"></a>First集合</h2><p><img src="https://photos.alitaalice.cn/image/20200820153953.png" alt=""></p>
<p>以a开头的文法 a为终结符</p>
<p><img src="https://photos.alitaalice.cn/image/20200823223523.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200820154422.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200820155708.png" alt="">+</p>
<p><img src="C:%5CUsers%5C16508%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200820172051504.png" alt="image-20200820172051504"></p>
<p><img src="C:%5CUsers%5C16508%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200820172747211.png" alt="image-20200820172747211"></p>
<p>S’-&gt;E</p>
<p>E-&gt;aA | bB</p>
<p>A-&gt;cA | d</p>
<p>B-&gt;cB | d</p>
<p><img src="C:%5CUsers%5C16508%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200824000026575.png" alt="image-20200824000026575"></p>
<p><img src="C:%5CUsers%5C16508%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200824000036963.png" alt="image-20200824000036963"></p>
<p><img src="https://img-blog.csdn.net/20180114195016769?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSm9oYW5fSm9lX0tpbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>线程安全性</title>
    <url>/2020/05/17/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍线程安全性</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-并发与并行"><a href="#1-并发与并行" class="headerlink" title="1 并发与并行"></a>1 并发与并行</h3><p>你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。<br>你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。<br>你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。</p>
<p>并发的关键是你有处理多个任务的能力，不一定要同时。<br>并行的关键是你有同时处理多个任务的能力。</p>
<p>所以我认为它们最关键的点就是：是否是『同时』。</p>
<h3 id="2-原子性"><a href="#2-原子性" class="headerlink" title="2 原子性"></a>2 原子性</h3><p><strong>即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。原子性就像数据库里面的事务一样，他们是一个团队，同生共死。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i = <span class="number">0</span>;       <span class="comment">//1</span></span><br><span class="line">j = i ;      <span class="comment">//2</span></span><br><span class="line">i++;         <span class="comment">//3</span></span><br><span class="line">i = j + <span class="number">1</span>;   <span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<p>上面四个操作，有哪个几个是原子操作，那几个不是？如果不是很理解，可能会认为都是原子性操作，其实只有1才是原子操作，其余均不是。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>在Java中，对基本数据类型的变量和赋值操作都是原子性操作； </span><br><span class="line"><span class="number">2</span>中包含了两个操作：读取i，将i值赋值给j </span><br><span class="line"><span class="number">3</span>中包含了三个操作：读取i值、i + <span class="number">1</span> 、将+<span class="number">1</span>结果赋值给i； </span><br><span class="line"><span class="number">4</span>中同三一样</span><br></pre></td></tr></table></figure>

<p>在单线程环境下我们可以认为整个步骤都是原子性操作，但是在多线程环境下则不同，Java只保证了基本数据类型的变量和赋值操作才是原子性的（注：在32位的JDK环境下，对64位数据的读取不是原子性操作*，如long、double）。</p>
<p>要想在多线程环境下保证原子性，则可以通过锁、synchronized来确保。volatile是无法保证复合操作的原子性。</p>
<h3 id="3可见性"><a href="#3可见性" class="headerlink" title="3可见性"></a>3可见性</h3><p><strong>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程1执行的代码</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2执行的代码</span></span><br><span class="line">j = i;</span><br></pre></td></tr></table></figure>

<p>假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i = 10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10。这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p>
<p>在上面已经分析了，在多线程环境下，一个线程对共享变量的操作对其他线程是不可见的。<br>对于可见性，Java提供了volatile关键字来保证可见性。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>
<h3 id="4有序性"><a href="#4有序性" class="headerlink" title="4有序性"></a>4有序性</h3><p><strong>程序执行的顺序按照代码的先后顺序执行</strong></p>
<p><strong>在Java里面，可以通过volatile关键字来保证一定的“有序性”</strong>。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p>
<h4 id="3-竞态条件"><a href="#3-竞态条件" class="headerlink" title="3 竞态条件"></a>3 竞态条件</h4><p>在并发编程中，这种由于不恰当的执行时序而出现不正确的结果是一种非常。重要的情况，它有一个正式的名字：竞态条件  </p>
<p>最常见的竞态条件类型就是“先检查后执行（Check-Then-Act）”操作，即通过一个可能失效的观测结果来决定下一步的动作  </p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>自动化测试手册</title>
    <url>/2020/07/24/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍自动化测试手册</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
  </entry>
  <entry>
    <title>网络基础TCP/IP</title>
    <url>/2020/05/13/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80TCP-IP/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍网络基础TCP/IP</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="1-TCP-IP的定义"><a href="#1-TCP-IP的定义" class="headerlink" title="1 TCP/IP的定义"></a>1 TCP/IP的定义</h2><p>定义：计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）。  </p>
<p><img src="https://photos.alitaalice.cn/image/20200513211754.png" alt=""></p>
<p>图：TCP/IP 是互联网相关的各类协议族的总称  </p>
<h2 id="2-TCP-IP的分层管理"><a href="#2-TCP-IP的分层管理" class="headerlink" title="2 TCP/IP的分层管理"></a>2 TCP/IP的分层管理</h2><p>TCP/IP 协议族里重要的一点就是分层。TCP/IP 协议族按层次分别分为以下 4 层：应用层、传输层、网络层和数据链路层。  </p>
<p>把 TCP/IP 层次化是有好处的。比如，如果互联网只由一个协议统筹，某个地方需要改变设计时，就必须把所有部分整体替换掉。而分层之后只需把变动的层替换掉即可。把各层之间的接口部分规划好之后，每个层次内部的设计就能够自由改动了。  </p>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p><strong>应用层决定了向用户提供应用服务时通信的活动。</strong><br>TCP/IP 协议族内预存了各类通用的应用服务。比如，FTP（File Transfer Protocol，文件传输协议）和DNS（Domain Name System，域名系统）服务就是其中两类。<br>HTTP 协议也处于该层。  </p>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。<strong>在传输层有两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Data Protocol，用户数据报协议）</strong>  </p>
<h2 id="网络层（又名网络互连层）"><a href="#网络层（又名网络互连层）" class="headerlink" title="网络层（又名网络互连层）"></a>网络层（又名网络互连层）</h2><p>网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。<strong>该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。</strong><br>与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。  </p>
<h2 id="链路层（又名数据链路层，网络接口层）"><a href="#链路层（又名数据链路层，网络接口层）" class="headerlink" title="链路层（又名数据链路层，网络接口层）"></a>链路层（又名数据链路层，网络接口层）</h2><p>用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链<br>路层的作用范围之内。  </p>
<h2 id="3-流程"><a href="#3-流程" class="headerlink" title="3 流程"></a>3 流程</h2><p><img src="https://photos.alitaalice.cn/image/20200513213825.png" alt=""></p>
<p>利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。<br>我们用 HTTP 举例来说明，首先作为发送端的客户端在应用层（HTTP 协议）发出一个想看某个 Web 页面的 HTTP 请求。</p>
<p>接着，为了传输方便，在传输层（TCP 协议）把从应用层处收到的数据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。</p>
<p>在网络层（IP 协议），增加作为通信目的地的 MAC 地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。<br>接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的 HTTP 请求。  </p>
<p><img src="https://photos.alitaalice.cn/image/20200513214119.png" alt=""></p>
<p>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。<br>这种把数据信息包装起来的做法称为封装（encapsulate）  </p>
<h2 id="4-IP-TCP-DNS"><a href="#4-IP-TCP-DNS" class="headerlink" title="4 IP.TCP.DNS"></a>4 IP.TCP.DNS</h2><h3 id="4-1-IP"><a href="#4-1-IP" class="headerlink" title="4.1 IP"></a>4.1 IP</h3><p>按层次分，IP（Internet Protocol）网际协议位于网络层。  可能有人会把“IP”和“IP 地址”搞混，“IP”其实是一种协议的名称  </p>
<p>IP 协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是 IP 地址和 MAC 地址（Media Access Control Address）  </p>
<p>IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定地址。IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC 地址基本上不会更改。  </p>
]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>考试安排</title>
    <url>/2020/09/10/%E8%80%83%E8%AF%95%E5%AE%89%E6%8E%92/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><table>
<thead>
<tr>
<th>数据库</th>
<th>36-105</th>
<th></th>
<th>9月14日（周一）12节</th>
</tr>
</thead>
<tbody><tr>
<td>云计算与大数据</td>
<td>35-208</td>
<td>许强</td>
<td>9月17日（周四）56节</td>
</tr>
<tr>
<td>软件测试</td>
<td>36-3JT</td>
<td></td>
<td>9月14日（周一）56节</td>
</tr>
<tr>
<td>软件编译技术</td>
<td>36-2JT</td>
<td></td>
<td>9月16日（周三）12节</td>
</tr>
<tr>
<td>计算方法</td>
<td></td>
<td></td>
<td>9.21晚上</td>
</tr>
<tr>
<td>毛概</td>
<td></td>
<td></td>
<td>10.1后</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>顺网测评 新华三测评</td>
<td></td>
<td></td>
</tr>
<tr>
<td>良品铺子测评</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>考试</category>
      </categories>
      <tags>
        <tag>考试</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰者模式</title>
    <url>/2020/05/18/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍装饰者模式。</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="装饰者模式定义"><a href="#装饰者模式定义" class="headerlink" title="装饰者模式定义"></a>装饰者模式定义</h3><p><img src="https://photos.alitaalice.cn/image/20200518102539.png" alt=""></p>
<p>设计原则：</p>
<p>类应该对扩展开放，对修改关闭。</p>
<p>我们的目标是允许类容易扩展，在不修改现有代码的情况下，就可搭配新的行为。如果能实现这样的目标，有什么好处呢？这样的设计具有弹性可以应对改变，可以接受新的功能来应对改变的需求。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>计算方法速成</title>
    <url>/2020/08/31/%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%E9%80%9F%E6%88%90/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<blockquote>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2></blockquote>
<p><img src="https://photos.alitaalice.cn/image/20200831084112.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200831084409.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200831085210.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200831090027.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200831090521.png" alt=""></p>
]]></content>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/2020/05/14/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍观察者模式</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><img src="https://photos.alitaalice.cn/image/20200527204326.png" alt="">)<img src="C:%5CUsers%5C16508%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200527204301788.png" alt="image-20200527204301788"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络概述</title>
    <url>/2020/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍计算机网络概述</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>1 局域网 </p>
<blockquote>
</blockquote>
<p><img src="https://photos.alitaalice.cn/image/20200712204915.png" alt=""></p>
<p>2 Internet</p>
<p>  <img src="https://photos.alitaalice.cn/image/20200712205323.png" alt=""></p>
<p>1 公司在电信网通之类的机房托管自己的服务器，电信机房给它分配ip地址。</p>
<p>2我们公司通过自己的服务器，用光纤连接到运营商。</p>
<p>3 我们通过ADSL上网呢</p>
<p>4 Internet ISP运营商组成，有自己的机房，为网民提供访问Internet</p>
<h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><p><img src="https://photos.alitaalice.cn/image/20200712205640.png" alt=""></p>
<h2 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h2><p><img src="https://photos.alitaalice.cn/image/20200712205722.png" alt=""></p>
<p>距离远，超过100M，花钱租带宽，其他人维护</p>
<p>ADSL 只是其中一种</p>
<p>也包括光纤</p>
<p>为什么访问 有的地址快，有点地址慢</p>
<p>4  浏览网站的过程</p>
<p>  DNS 解析域名为IP地址</p>
<p> 网络部分，主机部分  </p>
<p> IP地址  子网掩码</p>
<p>网关 ：配置网关 15.0.0.1</p>
<p>路由器 ：在不同网段转发数据            15.0.0.1 路由器接口的地址 </p>
<p>MAC：网卡 出厂就被固定  又叫物理地址  48位2进制  全球唯一</p>
<p><img src="C:%5CUsers%5C16508%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200712210430808.png" alt="image-20200712210430808"></p>
<p><img src="https://photos.alitaalice.cn/image/20200712210758.png" alt=""></p>
<h2 id="7层架构"><a href="#7层架构" class="headerlink" title="7层架构"></a>7层架构</h2><p>1  应用层</p>
<p>2 表示层  </p>
<p>3 会话层  网站和网站之间的会话  查木马 netstat -nb</p>
<p>4 传输层 </p>
<p><img src="https://photos.alitaalice.cn/image/20200716082223.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200716083347.png" alt=""></p>
<p>5 MAC冲突  </p>
<p><img src="https://photos.alitaalice.cn/image/20200716091319.png" alt=""></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计网专业知识</title>
    <url>/2020/08/28/%E8%AE%A1%E7%BD%91%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍计算机网络</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="LAN口和WAN口的区别"><a href="#LAN口和WAN口的区别" class="headerlink" title="LAN口和WAN口的区别"></a>LAN口和WAN口的区别</h3><p>LAN口和WAN口，想必所属设备应为家用的路由器吧。按照此假设，作以下科普：家用路由器的WAN口用来连接家用宽带网络；LAN口用来连接家中的局域网。</p>
<p><img src="https://photos.alitaalice.cn/image/20200828160957.png" alt=""></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>语法分析</title>
    <url>/2020/05/19/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><img src="https://photos.alitaalice.cn/image/20200519182456.png" alt=""> </p>
<p><img src="https://photos.alitaalice.cn/image/20200519182209.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200519182733.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200519183255.png" alt=""></p>
<h3 id="自上而下分析面临的问题"><a href="#自上而下分析面临的问题" class="headerlink" title="自上而下分析面临的问题"></a>自上而下分析面临的问题<img src="https://photos.alitaalice.cn/image/20200519183424.png" alt=""></h3><h3 id="单词没向下进行，而语法树一直生成，死循环"><a href="#单词没向下进行，而语法树一直生成，死循环" class="headerlink" title="单词没向下进行，而语法树一直生成，死循环"></a><strong>单词没向下进行，而语法树一直生成，死循环</strong></h3><p><img src="https://photos.alitaalice.cn/image/20200519183702.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200519184233.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200519184615.png" alt=""></p>
<p> <img src="https://photos.alitaalice.cn/image/20200519185010.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200519185526.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200519190630.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200519190602.png" alt=""></p>
<p>通用消除左递归的方法</p>
<p><img src="https://photos.alitaalice.cn/image/20200519190928.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200519191437.png" alt=""></p>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>费曼学习法</title>
    <url>/2020/08/14/%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍费曼学习法</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>该技巧主要包含四步：</p>
<h3 id="第一步：把它教给一个小孩子。"><a href="#第一步：把它教给一个小孩子。" class="headerlink" title="第一步：把它教给一个小孩子。"></a><strong>第一步：把它教给一个小孩子</strong>。</h3><p>拿出一张白纸，在上方写下你想要学习的主题。想一下，如果你要把它教给一个孩子，你会讲哪些，并写下来。这里你的教授对象不是你自己那些聪明的成年朋友，而是一个8岁的孩子，他的词汇量和注意力刚好能够理解基本概念和关系。</p>
<p>许多人会倾向于使用复杂的词汇和行话来掩盖他们不明白的东西。问题是我们只在糊弄自己，因为我们不知道自己也不明白。另外，使用行话会隐藏周围人对我们的误解。</p>
<p>当你自始至终都用孩子可以理解的简单的语言写出一个想法（提示：只用最常见的单词），那么你便迫使自己在更深层次上理解了该概念，并简化了观点之间的关系和联系。如果你努力，就会清楚地知道自己在哪里还有不明白的地方。这种紧张状态很好——预示着学习的机会到来了。</p>
<h3 id="第二步：回顾。"><a href="#第二步：回顾。" class="headerlink" title="第二步：回顾。"></a>第二步：回顾。</h3><h5 id="在第一步中，你不可避免地会卡壳，忘记重要的点，不能解释，或者说不能将重要的概念联系起来。"><a href="#在第一步中，你不可避免地会卡壳，忘记重要的点，不能解释，或者说不能将重要的概念联系起来。" class="headerlink" title="在第一步中，你不可避免地会卡壳，忘记重要的点，不能解释，或者说不能将重要的概念联系起来。"></a>在第一步中，你不可避免地会卡壳，忘记重要的点，不能<a href="https://baike.baidu.com/item/解释">解释</a>，或者说不能将重要的概念联系起来。</h5><p>这一反馈相当宝贵，因为你已经发现了自己<a href="https://baike.baidu.com/item/知识">知识</a>的边缘。懂得自己能力的界限也是一种能力，你刚刚就确定了一个！</p>
<p>这是学习开始的地方。现在你知道自己在哪里卡住了，那么就回到原始<a href="https://baike.baidu.com/item/材料">材料</a>，重新学习，直到你可以用基本的术语解释这一概念。</p>
<p>认定自己知识的界限，会限制你可能犯的错误，并且在应用该知识时，可以增加成功的几率。</p>
<h3 id="第三步：将语言条理化，简化。"><a href="#第三步：将语言条理化，简化。" class="headerlink" title="第三步：将语言条理化，简化。"></a>第三步：将语言条理化，简化。</h3><p>现在你手上有一套自己手写笔记，检查一下确保自己没有从<a href="https://baike.baidu.com/item/原材料">原材料</a>中借用任何行话。将这些笔记用简单的语言组织成一个流畅的故事。</p>
<p>将这个故事大声读出来，如果这些解释不够简单，或者听起来比较混乱，很好，这意味着你想要理解该领域，还<a href="https://baike.baidu.com/item/需要">需要</a>做一些<a href="https://baike.baidu.com/item/工作">工作</a>。</p>
<h3 id="第四步（可选）：传授"><a href="#第四步（可选）：传授" class="headerlink" title="第四步（可选）：传授"></a>第四步（可选）：传授</h3><p>如果你真的想确保你的理解没什么问题，就把它教给另一个人（<a href="https://baike.baidu.com/item/理想">理想</a>状态下，这个人<a href="https://baike.baidu.com/item/应该">应该</a>对这个话题知之甚少，或者就找个 8 岁的孩子）。检测知识最终的途径是你能有能力把它<a href="https://baike.baidu.com/item/传播">传播</a>给另一个人。</p>
<p>这不仅是学习的妙方，还是窥探不同<a href="https://baike.baidu.com/item/思维方式">思维方式</a>的窗口，它让你将想法撕开揉碎，从头<a href="https://baike.baidu.com/item/重组">重组</a>。这种学习方法会让你对观点和概念有更为深入的理解。重要的是，以这种方式解决问题，你可以在别人不知道他们自己在说什么的情况下，理解这个问题。</p>
<p>费曼的方法直观地认为<a href="https://baike.baidu.com/item/智力">智力</a>是一个增长的过程，这与 Carol Dweck 的研究非常吻合，Carol Dweck 精确地描述了停滞型<a href="https://baike.baidu.com/item/思维">思维</a>（fixed mindset）和成长型思维（growth mindset）之间的区别。</p>
]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>学习心得</tag>
      </tags>
  </entry>
  <entry>
    <title>语法分析消除回溯</title>
    <url>/2020/05/20/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%B6%88%E9%99%A4%E5%9B%9E%E6%BA%AF/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><img src="https://photos.alitaalice.cn/image/20200520110241.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200520110725.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200520110909.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200520111151.png" alt=""></p>
<p><img src="C:%5CUsers%5C16508%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200520111712012.png" alt="image-20200520111712012"></p>
<p><img src="https://photos.alitaalice.cn/image/20200520112422.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200520112834.png" alt=""> </p>
<p><img src="https://photos.alitaalice.cn/image/20200520113021.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    public boolean Judge(List&lt;String&gt; list)&#123;</span><br><span class="line">         ArrayList&lt;node&gt; analy &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">            node aa &#x3D; new node(list.get(i).charAt(0),list.get(i).substring(3));</span><br><span class="line">            analy.add(aa);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;0;i&lt;analy.size();i++)&#123;</span><br><span class="line">            if(analy.get(i).left &#x3D;&#x3D; analy.get(i).right.charAt(0))&#123;   &#x2F;&#x2F;当产生式的左部等于右部第一个符号，则具有左递归</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    class node&#123;          &#x2F;&#x2F;用于方便查找产生式的左部与右部</span><br><span class="line">    public char left;</span><br><span class="line">    public String right;</span><br><span class="line">    public node(char left,String right)&#123;</span><br><span class="line">        this.left&#x3D;left;</span><br><span class="line">        this.right&#x3D;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>输入url发生了什么</title>
    <url>/2020/10/08/%E8%BE%93%E5%85%A5url%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍输入url发生了什么</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>1 在浏览器中输入url<br> 用户输入url，例如<a href="http://www.baidu.com。其中http为协议，[www.baidu.com](http://www.baidu.com)为网络地址，及指出需要的资源在那台计算机上。一般网络地址可以为域名或IP地址，此处为域名。使用域名是为了方便记忆，但是为了让计算机理解这个地址还需要把它解析为IP地址。">http://www.baidu.com。其中http为协议，[www.baidu.com](http://www.baidu.com)为网络地址，及指出需要的资源在那台计算机上。一般网络地址可以为域名或IP地址，此处为域名。使用域名是为了方便记忆，但是为了让计算机理解这个地址还需要把它解析为IP地址。</a></p>
<p>2.应用层DNS解析域名<br> 客户端先检查本地是否有对应的IP地址，若找到则返回响应的IP地址。若没找到则请求上级DNS服务器，直至找到或到根节点。</p>
<p>3.应用层客户端发送HTTP请求<br> HTTP请求包括请求报头和请求主体两个部分，其中请求报头包含了至关重要的信息，包括请求的方法（GET / POST）、目标url、遵循的协议（http / https / ftp…），返回的信息是否需要缓存，以及客户端是否发送cookie等。</p>
<p>4.传输层TCP传输报文<br> 位于传输层的TCP协议为传输报文提供可靠的字节流服务。它为了方便传输，将大块的数据分割成以报文段为单位的数据包进行管理，并为它们编号，方便服务器接收时能准确地还原报文信息。TCP协议通过“三次握手”等方法保证传输的安全可靠。</p>
<p>“三次握手”的过程是，发送端先发送一个带有SYN（synchronize）标志的数据包给接收端，在一定的延迟时间内等待接收的回复。接收端收到数据包后，传回一个带有SYN/ACK标志的数据包以示传达确认信息。接收方收到后再发送一个带有ACK标志的数据包给接收端以示握手成功。在这个过程中，如果发送端在规定延迟时间内没有收到回复则默认接收方没有收到请求，而再次发送，直到收到回复为止。</p>
<p>5.网络层IP协议查询MAC地址<br> IP协议的作用是把TCP分割好的各种数据包传送给接收方。而要保证确实能传到接收方还需要接收方的MAC地址，也就是物理地址。IP地址和MAC地址是一一对应的关系，一个网络设备的IP地址可以更换，但是MAC地址一般是固定不变的。ARP协议可以将IP地址解析成对应的MAC地址。当通信的双方不在同一个局域网时，需要多次中转才能到达最终的目标，在中转的过程中需要通过下一个中转站的MAC地址来搜索下一个中转目标。</p>
<p>6.数据到达数据链路层<br> 在找到对方的MAC地址后，就将数据发送到数据链路层传输。这时，客户端发送请求的阶段结束</p>
<p>7.服务器接收数据<br> 接收端的服务器在链路层接收到数据包，再层层向上直到应用层。这过程中包括在运输层通过TCP协议讲分段的数据包重新组成原来的HTTP请求报文。</p>
<p>8.服务器响应请求<br> 服务接收到客户端发送的HTTP请求后，查找客户端请求的资源，并返回响应报文，响应报文中包括一个重要的信息——状态码。状态码由三位数字组成，其中比较常见的是200 OK表示请求成功。301表示永久重定向，即请求的资源已经永久转移到新的位置。在返回301状态码的同时，响应报文也会附带重定向的url，客户端接收到后将http请求的url做相应的改变再重新发送。404 not found 表示客户端请求的资源找不到。</p>
<p>9 服务器返回相应文件<br> 请求成功后，服务器会返回相应的HTML文件。接下来就到了页面的渲染阶段了。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试基本理论</title>
    <url>/2020/08/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E6%9C%AC%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍软件测试基本理论</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="黑盒测试-白盒测试-灰盒测试"><a href="#黑盒测试-白盒测试-灰盒测试" class="headerlink" title="黑盒测试 白盒测试 灰盒测试"></a>黑盒测试 白盒测试 灰盒测试</h3><p><strong>目标</strong> ：确保软件的质量、提高软件质量</p>
<h4 id="一、黑盒测试"><a href="#一、黑盒测试" class="headerlink" title="一、黑盒测试"></a>一、黑盒测试</h4><p>黑盒测试也称功能测试，它是通过测试来检测每个功能是否都能正常使用。在测试中，把程序看作一个不能打开的黑盒子，在完全不考虑程序内部结构和内部特性的情况下，在程序接口进行测试，它只检查程序功能是否按照需求规格说明书的规定正常使用，程序是否能适当地接收输入数据而产生正确的输出信息。</p>
<p><strong>黑盒测试方法</strong>：等价类划分法；边界值分析法；因果图法；场景法；正交实验设计法；判定表驱动分析法；错误推测法；功能图分析法。</p>
<h4 id="二、白盒测试"><a href="#二、白盒测试" class="headerlink" title="二、白盒测试"></a>二、白盒测试</h4><p>白盒测试也称为结构测试或逻辑驱动测试。”白盒”法全面了解程序内部逻辑结构、<strong>对所有逻辑路径进行测试</strong>。”白盒”法是穷举路径测试。按照程序内部的结构测试程序，检验程序中的每条通路是否都有能按预定要求正确工作，而不顾它的功能。</p>
<p><strong>白盒测试方法</strong>：主要有<strong>代码检查法</strong>、<strong>逻辑覆盖法</strong>(语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖、路径覆盖)、基本路径测试法。<br>白盒测试工具是对源代码进行的测试，测试的<strong>主要内容</strong>包括词法分析与语法分析、静态错误分析、动态检测等。</p>
<p>白盒测试的基本步骤包括测试者对被测试的源代码有一个深层次的理解。程序员必须对应用有一个深度理解，以清楚的知道应创建哪种测试用例，从而使得测试中的所有可见路径都可以被执行。源代码被理解之后才可以被分析，以创造测试用例。以下是白盒测试创建测试用例的三个基本步骤：</p>
<ul>
<li>输入包括不同种类的需求，功能方面，文档中的详细设计，合适的源码，安全方面。<a href="https://zh.wikipedia.org/wiki/白盒测试#cite_note-method-1">[1]</a>这是白盒测试列出所有基本信息的准备阶段。</li>
<li>过程包括风险分析来导向整个测试过程，合适的测试计划，执行测试用例和交流过程。<a href="https://zh.wikipedia.org/wiki/白盒测试#cite_note-method-1">[1]</a> 这是创建测试用例的阶段，以确保他们彻底的测试了应用程序，并且记录下了相应的测试结果。</li>
<li>输出包括准备最后报告，其中包含了以上所有准备材料和结果</li>
</ul>
<h4 id="三、灰盒测试"><a href="#三、灰盒测试" class="headerlink" title="三、灰盒测试"></a>三、灰盒测试</h4><p>灰盒测试是介于白盒测试与黑盒测试之间的一种测试，灰盒测试多用于 集成测试 阶段，不仅关注输出、输入的正确性，同时也关注程序内部的情况。灰盒测试不像白盒那样详细、完整，但又比黑盒测试更关注程序的内部逻辑，常常是通过一些表征性的现象、事件、标志来判断内部的运行状态。</p>
<h3 id="1-何为-冒烟测试"><a href="#1-何为-冒烟测试" class="headerlink" title="1.何为\冒烟测试****"></a><strong>1.何为\</strong>冒烟测试****</h3><p>　　冒烟测试是自由测试的一种。冒烟测试在测试中发现问题，找到了一个bug，然后开发人员会来修复这个bug。这时想知道这次修复是否真的解决了程序的bug，或者是否会对其它模块造成影响，就需要针对此问题进行专门测试，这个过程就被称为冒烟测试。在很多情况下，做冒烟测试是开发人员在试图解决一个问题的时候，造成了其它功能模块一系列的连锁反应，原因可能是只集中考虑了一开始的那个问题，而忽略其它的问题，这就可能引起了新的bug。</p>
<p>　　冒烟测试引入到<strong>软件测试</strong>中，是指测试人员在正规测试一个新版本之前，先投入较少的人力和时间验证一个软件的主要功能，如果主要功能都没有实现，则打回开发组重新开发。这样做的好处是可以节省大量的时间成本和人力成本。</p>
<h3 id="2-何为-回归测试"><a href="#2-何为-回归测试" class="headerlink" title="2.何为\回归测试****"></a><strong>2.何为\</strong>回归测试****</h3><p>　　回归测试是指修改了旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误。回归测试作为软件生命周期的一个组成部分，在整个软件测试过程中占有很大的工作量比重，<strong>软件开发</strong>的各个阶段都会进行多次回归测试。在渐进和快速迭代开发中，新版本的连续发布使回归测试进行的更加频繁，而在极端编程方法中，更是要求每天都进行若干次回归测试。因此，通过选择正确的回归测试策略来改进回归测试的效率和有效性是非常有意义的。</p>
<p>　　回归测试一般是在进行软件的第二轮测试开始的，验证第一轮中发现的问题是否得到修复。当然回归也是一个循环的过程，穿插在软件测试整个生命周期里面。如果回归的问题不通过，则需要开发人员修改后再次回归，直到通过为止。</p>
<h3 id="3-两者有何区别"><a href="#3-两者有何区别" class="headerlink" title="3.两者有何区别"></a><strong>3.两者有何区别</strong></h3><p>　　冒烟测试就是完成一个新版本的开发后，对该版本最基本的功能进行测试，保证基本的功能和流程能走通。如果不通过，则打回开发那边重新开发；如果通过测试，才会进行下一步的测试(<strong>功能测试</strong>，集成测试，<strong>系统测试</strong>等等)。冒烟测试优点是节省测试时间，防止build失败。缺点是覆盖率还是比较低。</p>
<p>　　回归测试我有两层理解，一是就是当你修复一个bug后，把之前的<strong>测试用例</strong>再次应用到修复后的版本上进行测试。二是当一个新版本开发好后，而且冒烟测试通过，此时可以先用上一个版本的测试用例对新版本进行测试，看是否有bug！其实回归测试用的很多，比如新增加一个功能模块等等，所以<strong>自动化测试</strong>可以高效率的进行回归测试。</p>
<blockquote>
</blockquote>
]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试复习</title>
    <url>/2020/09/10/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="软件测试的定义-软件测试的内涵-软件测试和软件调试"><a href="#软件测试的定义-软件测试的内涵-软件测试和软件调试" class="headerlink" title="软件测试的定义 软件测试的内涵 软件测试和软件调试"></a>软件测试的定义 软件测试的内涵 软件测试和软件调试</h3><p>定义：分析某个软件项以发现现存和要求的条件之差别并评价此软件项的特性</p>
<h2 id="设计测试用例-输入数据-期望输出这俩部分组成"><a href="#设计测试用例-输入数据-期望输出这俩部分组成" class="headerlink" title="设计测试用例 输入数据 期望输出这俩部分组成"></a>设计测试用例 输入数据 期望输出这俩部分组成</h2><p>测试用例定义：一个文档，详细说明输入 期望输出，和为测试项所准备的一组执行条件</p>
]]></content>
  </entry>
  <entry>
    <title>适配器模式和外观模式</title>
    <url>/2020/05/28/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍适配器模式和外观模式</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>OO适配器将一个接口转换为另一个接口，就像转换电源插口的接口那样。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>适配器模式将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。</p>
<h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p><strong>提供了一个统一的接口，用来访问子系统的一群接口。外观定义了一个高层接口，让子系统更容易使用。</strong></p>
<p>设计原则：</p>
<p><strong>最少知识原则：只和你的密友谈话</strong></p>
<p>我们要减少对象之间的交互，只留下几个密友。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>选择排序</title>
    <url>/2020/06/02/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
  </entry>
  <entry>
    <title>验证二叉搜索树</title>
    <url>/2020/05/25/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h4 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h4><p>难度中等589</p>
<p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：</p>
<ul>
<li>节点的左子树只包含<strong>小于</strong>当前节点的数。</li>
<li>节点的右子树只包含<strong>大于</strong>当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   4</span><br><span class="line">     &#x2F; \</span><br><span class="line">    3   6</span><br><span class="line">输出: false</span><br><span class="line">解释: 输入为: [5,1,4,null,null,3,6]。</span><br><span class="line">     根节点的值为 5 ，但是其右子节点值为 4 。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2020/05/07/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>线性表的链式存储结构详解</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>单链表存储状态图示：</p>
<p>Node由存放数据元素的数据域和存放后继结点地址的指针域组成。</p>
<p>头结点的数据域可以不存储任何信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">LinkList</span>;</span></span><br></pre></td></tr></table></figure>

<p>假设p是指向线性表第i个元素的指针，则该结点ai的数据域 可以用p-&gt;data 来表示</p>
<p>结点ai的指针域用p-&gt;next来表示。p-&gt;next指向第i-1个元素，即指向ai+1的指针。即p-&gt;data=ai</p>
<p>那么p-&gt;next-&gt;data=ai+1</p>
<p><img src="%E9%93%BE%E8%A1%A801.png" alt=""></p>
<h2 id="单链表的读取"><a href="#单链表的读取" class="headerlink" title="单链表的读取"></a>单链表的读取</h2><p>算法思路：<br>从第一个头结点开始，指针域p-&gt; next一直向下指向第i个元素的指针域。</p>
<ol>
<li>声明指针p指向链表的第一个结点 ，初始化从1开始</li>
<li>当j&lt;i时就遍历链表，p不断向后移动，j++</li>
<li>当链表末尾p为空时，则说明第i个结点不存在</li>
<li>若查找成功，那么返回结点p的数据。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(LinkList L,<span class="keyword">int</span> i,ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> j;</span><br><span class="line">  LinkList p;</span><br><span class="line">  p=L-&gt;next;</span><br><span class="line">  j=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(p&amp;&amp;j&lt;i)</span><br><span class="line">  &#123;</span><br><span class="line">  p=p-&gt;next;</span><br><span class="line">  j++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!p || j&gt;i)</span><br><span class="line">  <span class="keyword">return</span> ERROR；</span><br><span class="line">  *e=p-&gt;data;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单链表的插入与删除"><a href="#单链表的插入与删除" class="headerlink" title="单链表的插入与删除"></a>单链表的插入与删除</h2><h3 id="单链表插入"><a href="#单链表插入" class="headerlink" title="单链表插入"></a>单链表插入</h3><p>思路：在俩节点之间再插入一个结点</p>
<p>图示：</p>
<p><img src="%E9%93%BE%E8%A1%A802.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">s-&gt;next=p-&gt;next;</span><br><span class="line">p-next=s;   <span class="comment">/*单链表插入标准语句 */</span></span><br></pre></td></tr></table></figure>

<p>实现插入操作的具体思路：</p>
<ol>
<li></li>
<li></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(LinkList *L,<span class="keyword">int</span> i,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(p&amp;&amp;j&lt;i)</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p||j&gt;i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    s=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    s-&gt;data=e;</span><br><span class="line">    s-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next=s;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>malloc  函数，生成一个新的结点，其类型与Node一样的，其实质就是在内存中找一小块空地，准备用来存放数据e的s结点。</p>
<h2 id="单链表的删除："><a href="#单链表的删除：" class="headerlink" title="单链表的删除："></a>单链表的删除：</h2><p>图示：</p>
<p><img src="%E9%93%BE%E8%A1%A803.png" alt=""></p>
<p>实际上就是p-&gt;next=p-&gt;next-&gt;next;</p>
<p>如果用q来表示p-&gt;next即</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">q=p-&gt;next;</span><br><span class="line">p-&gt;next=q-&gt;next;</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>具体实现代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListDelete</span><span class="params">(LinkList *L,<span class="keyword">int</span> i,ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line">LinkList p,q;</span><br><span class="line">p=*L;</span><br><span class="line">j=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(p-&gt;next &amp;&amp; j&lt;i)</span><br><span class="line">&#123;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!(p-&gt;next)||j&gt;i)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">q=p-&gt;next;</span><br><span class="line">p-&gt;next=q-&gt;next;</span><br><span class="line">*e=q-&gt;data;</span><br><span class="line"><span class="built_in">free</span>(q);<span class="comment">/* 回收一个Node结点 */</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>永久代</title>
    <url>/2020/09/06/%E6%B0%B8%E4%B9%85%E4%BB%A3/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍永久代到元空间</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h1 id="面试官，Java8-JVM内存结构变了，永久代到元空间"><a href="#面试官，Java8-JVM内存结构变了，永久代到元空间" class="headerlink" title="面试官，Java8 JVM内存结构变了，永久代到元空间"></a>面试官，Java8 JVM内存结构变了，永久代到元空间</h1><p>在文章《<a href="https://www.choupangxia.com/2019/10/18/jvm之内存结构详解/">JVM之内存结构详解</a>》中我们描述了Java7以前的JVM内存结构，但在Java8和以后版本中JVM的内存结构慢慢发生了变化。作为面试官如果你还不知道，那么面试过程中是不是有些露怯？作为面试者，如果知晓这些变化，又将成为面试中的亮点。</p>
<p>如果在网络上搜索JVM内存结构，90%的可能会搜到Java7及以前的内存图，本篇文章将会对JVM内存结构再次细化，深入理解Java8之后的内部变化。现在意识到关注公众号“程序新视界”的好处了吧。在这里可以不断的刷新你的知识和认知。</p>
<h2 id="JVM内存结构的细化"><a href="#JVM内存结构的细化" class="headerlink" title="JVM内存结构的细化"></a>JVM内存结构的细化</h2><p>再来看一下《<a href="https://www.choupangxia.com/2019/10/18/jvm之内存结构详解/">JVM之内存结构详解</a>》中的内存结构图。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/10/22/16df19d7d4e9c226?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="jvm内存结构"></p>
<p>为了更细化的讲解，我们将该图进行进一步的优化调整。针对java7及以前版本的细化。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/10/22/16df19d81ad389b4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="jvm内存结构"></p>
<p>看出变化了吗？堆和方法区连在了一起，但这并不能说堆和方法区是一起的，它们在逻辑上依旧是分开的。但在物理上来说，它们又是连续的一块内存。也就是说，方法区和前面讲到的Eden和老年代是连续的。</p>
<p>![jvm内存结构](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1280" height="798"></svg>)</p>
<p>在继续进行下去之前，我们先来理解两个概念：规范和实现。</p>
<h2 id="规范和实现"><a href="#规范和实现" class="headerlink" title="规范和实现"></a>规范和实现</h2><p>针对Java虚拟机的实现有专门的《Java虚拟机规范》，在遵守规范的前提下，不同的厂商会对虚拟机进行不同的实现。 就好比开发的过程中定义了接口，具体的接口实现大家可以根据不同的业务需求进行实现。</p>
<p>PS：大家都有必要了解一下《Java虚拟机规范》，关注公众号“程序新视界”，回复“002”获得Java SE 7的虚拟机规范PDF版。</p>
<p>我们通常使用的Java SE都是由Sun JDK和OpenJDK所提供，这也是应用最广泛的版本。而该版本使用的VM就是HotSpot VM。通常情况下，我们所讲的java虚拟机指的就是HotSpot的版本。</p>
<h2 id="永久代（PermGen）"><a href="#永久代（PermGen）" class="headerlink" title="永久代（PermGen）"></a>永久代（PermGen）</h2><p>上面理解了规范和实现之后，来看认识一个概念“永久代(Permanet Generation，也称PermGen)”。对于习惯了在HotSpot虚拟机上开发、部署的程序员来说，很多都愿意将方法区称作永久代。</p>
<p>本质上来讲两者并不等价，仅因为Hotspot将GC分代扩展至方法区，或者说使用永久代来实现方法区。在其他虚拟机上是没有永久代的概念的。也就是说方法区是规范，永久代是Hotspot针对该规范进行的实现。</p>
<p>理解上面的概念之后，我们对Java7及以前版本的堆和方法区的构造再进行一下变动。</p>
<p>![jvm内存结构](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1280" height="805"></svg>)</p>
<p>再重复一遍就是对Java7及以前版本的Hotspot中方法区位于永久代中。同时，永久代和堆是相互隔离的，但它们使用的物理内存是连续的。</p>
<p>永久代的垃圾收集是和老年代捆绑在一起的，因此无论谁满了，都会触发永久代和老年代的垃圾收集。</p>
<p>但在Java7中永久代中存储的部分数据已经开始转移到Java Heap或Native Memory中了。比如，符号引用(Symbols)转移到了Native Memory；字符串常量池(interned strings)转移到了Java Heap；类的静态变量(class statics)转移到了Java Heap。</p>
<p>然后，在Java8中，时代变了，Hotspot取消了永久代。永久代真的成了永久的记忆。永久代的参数-XX:PermSize和-XX：MaxPermSize也随之失效。</p>
<h2 id="元空间-Metaspace"><a href="#元空间-Metaspace" class="headerlink" title="元空间(Metaspace)"></a>元空间(Metaspace)</h2><p>对于Java8，HotSpots取消了永久代，那么是不是就没有方法区了呢？当然不是，方法区只是一个规范，只不过它的实现变了。</p>
<p>在Java8中，元空间(Metaspace)登上舞台，方法区存在于元空间(Metaspace)。同时，元空间不再与堆连续，而且是存在于本地内存（Native memory）。</p>
<p>![jvm内存结构](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="875" height="521"></svg>)</p>
<p>本地内存（Native memory），也称为C-Heap，是供JVM自身进程使用的。当Java Heap空间不足时会触发GC，但Native memory空间不够却不会触发GC。</p>
<p>针对Java8的调整，我们再次对内存结构图进行调整。<img src="https://user-gold-cdn.xitu.io/2019/10/22/16df19d8f942f7c0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="jvm内存结构"></p>
<p>元空间存在于本地内存，意味着只要本地内存足够，它不会出现像永久代中“java.lang.OutOfMemoryError: PermGen space”这种错误。看上图中的方法区，是不是“膨胀”了。</p>
<p>默认情况下元空间是可以无限使用本地内存的，但为了不让它如此膨胀，JVM同样提供了参数来限制它使用的使用。</p>
<ul>
<li>-XX:MetaspaceSize，class metadata的初始空间配额，以bytes为单位，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当的降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize（如果设置了的话），适当的提高该值。</li>
<li>-XX：MaxMetaspaceSize，可以为class metadata分配的最大空间。默认是没有限制的。</li>
<li>-XX：MinMetaspaceFreeRatio,在GC之后，最小的Metaspace剩余空间容量的百分比，减少为class metadata分配空间导致的垃圾收集。</li>
<li>-XX:MaxMetaspaceFreeRatio,在GC之后，最大的Metaspace剩余空间容量的百分比，减少为class metadata释放空间导致的垃圾收集。</li>
</ul>
<h2 id="永久代为什么被替换了"><a href="#永久代为什么被替换了" class="headerlink" title="永久代为什么被替换了"></a>永久代为什么被替换了</h2><p>思考一下，为什么使用元空间替换永久代？</p>
<p>表面上看是为了避免OOM异常。因为通常使用PermSize和MaxPermSize设置永久代的大小就决定了永久代的上限，但是不是总能知道应该设置为多大合适, 如果使用默认值很容易遇到OOM错误。</p>
<p>当使用元空间时，可以加载多少类的元数据就不再由MaxPermSize控制, 而由系统的实际可用空间来控制。</p>
<p>更深层的原因还是要合并HotSpot和JRockit的代码，JRockit从来没有所谓的永久代，也不需要开发运维人员设置永久代的大小，但是运行良好。同时也不用担心运行性能问题了,在覆盖到的测试中, 程序启动和运行速度降低不超过1%，但是这点性能损失换来了更大的安全保障。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>集合排序</title>
    <url>/2020/06/02/%E9%9B%86%E5%90%88%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍集合排序。</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
      <categories>
        <category>JAVA集合</category>
      </categories>
      <tags>
        <tag>JAVA集合</tag>
      </tags>
  </entry>
  <entry>
    <title>词法分析</title>
    <url>/2020/05/21/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><div id="article_content" class="article_content clearfix" style="height: 2193px; overflow: hidden;">
            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-211130ba7a.css">
                            <div id="content_views" class="markdown_views">
                    <!-- flowchart 箭头图标 勿删 -->
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                                            <p><strong>摘要：</strong></p>

<p>　　所谓排序，就是根据排序码的递增或者递减顺序把数据元素依次排列起来，使一组任意排列的元素变为一组按其排序码线性有序的元素。本文将介绍八种最为经典常用的内部排序算法的基本思想与实现，包括插入排序(直接插入排序，希尔排序)、选择排序(直接选择排序，堆排序)、交换排序(冒泡排序，快速排序)、归并排序、分配排序(基数排序)，并给出各种算法的时间复杂度、空间复杂度和稳定性。</p>

<hr>

<p><strong>版权声明：</strong></p>

<p>　　本文原创作者：<a href="http://my.csdn.net/justloveyou_" rel="nofollow" target="_blank">书呆子Rico</a> <br>
　　作者博客地址：<a href="http://blog.csdn.net/justloveyou_/" target="_blank">http://blog.csdn.net/justloveyou_/</a></p>

<hr>

<p><strong>友情提示：</strong></p>

<p>　　若读者需要本博文相关完整代码，请移步我的Github自行获取，项目名为 DataStructure(具体算法实现在cn.tju.edu.rico.sort包)，项目链接地址为：<a href="https://github.com/githubofrico/DataStructure" target="_blank">https://github.com/githubofrico/DataStructure</a>。</p>

<hr>



<h2 id="一-排序算法概述"><a name="t0"></a><a name="t0"></a>一. 排序算法概述</h2>

<p>　　所谓排序，就是根据排序码的递增或者递减顺序把数据元素依次排列起来，使一组任意排列的元素变为一组按其排序码线性有序的元素。本文将介绍八种最为经典常用的内部排序算法，包括插入排序(直接插入排序，希尔排序)、选择排序(直接选择排序，堆排序)、交换排序(冒泡排序，快速排序)、归并排序、分配排序(基数排序)。实际上，无论是基本排序方法(直接插入排序，直接选择排序，冒泡排序)，还是高效排序方法(快速排序，堆排序，归并排序)等，它们各有所长，都拥有特定的使用场景。因此，在实际应用中，我们必须根据实际任务的特点和各种排序算法的特性来做出最合适的选择。一般地，我们衡量一个算法的指标包括：</p>

<ul>
<li><p>时间复杂度 (在排序过程中需要比较和交换的次数)</p></li>
<li><p>空间复杂度 (在排序过程中需要的辅助存储空间)</p></li>
<li><p>稳定性 (该算法的实现是否可以保证排序后相等元素的初始顺序，只要该算法存在一种实现可以保证这种特征，那么该算法就是稳定的)</p></li>
<li><p>内部排序/外部排序 (在排序过程中数据元素是否完全在内存)</p></li>
</ul>



<hr>

<p>　　笔者将在本文着重探讨上述八种排序算法的思想和实现，并就各算法根据以上指标进行分析和归类，以便进一步熟悉它们各自的应用场景。</p>

<hr>



<h2 id="二-插入排序"><a name="t1"></a><a name="t1"></a>二. 插入排序</h2>

<p>　　<font color="red"><b>插入排序的基本思想</b></font>：每步将一个待排序元素，按其排序码大小插入到前面已经排好序的一组元素中，直到元素全部插入为止。在这里，我们介绍三种具体的插入排序算法：直接插入排序，希尔排序与折半插入排序。</p>

<hr>

<p><strong>1、直接插入排序</strong></p>

<p>　　<font color="red"><b>直接插入排序的思想：</b></font>当插入第i(i&gt;=1)个元素时，前面的V[0],…,V[i-1]等i-1个 元素已经有序。这时，将第i个元素与前i-1个元素V[i-1]，…，V[0]依次比较，找到插入位置即将V[i]插入，同时原来位置上的元素向后顺移。在这里，插入位置的查找是顺序查找。直接插入排序是一种稳定的排序算法，其实现如下：</p>



<pre class="prettyprint" name="code"><code class="language-java hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-javadoc">/**        
 * Title: 插入排序中的直接插入排序，依赖于初始序列    
 * Description: 在有序序列中不断插入新的记录以达到扩大有序区到整个数组的目的
 *              时间复杂度：最好情形O(n)，平均情形O(n^2)，最差情形O(n^2)
 *              空间复杂度：O(1)
 *              稳    定   性：稳定
 *              内部排序(在排序过程中数据元素完全在内存)
 *<span class="hljs-javadoctag"> @author</span> rico       
 *<span class="hljs-javadoctag"> @created</span> 2017年5月20日 上午10:40:00    
 */</span>      
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StraightInsertionSort</span> {</span>

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] <span class="hljs-title">insertSort</span>(<span class="hljs-keyword">int</span>[] target){

        <span class="hljs-keyword">if</span>(target != <span class="hljs-keyword">null</span> &amp;&amp; target.length != <span class="hljs-number">1</span>){   <span class="hljs-comment">// 待排序数组不为空且长度大于1</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; target.length; i++) { <span class="hljs-comment">// 不断扩大有序序列，直到扩展到整个数组</span>
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &gt; <span class="hljs-number">0</span>; j--) {    <span class="hljs-comment">// 向有序序列中插入新的元素</span>
                    <span class="hljs-keyword">if</span>(target[j]  &lt; target[j-<span class="hljs-number">1</span>]){  <span class="hljs-comment">// 交换</span>
                        <span class="hljs-keyword">int</span> temp = target[j];
                        target[j] = target[j-<span class="hljs-number">1</span>];
                        target[j-<span class="hljs-number">1</span>] = temp;
                    }
                }
            }
        }
        <span class="hljs-keyword">return</span> target;
    }
}<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li></ul></pre>

<hr>

<p><strong>2、希尔排序</strong></p>

<p>　　<font color="red"><b>希尔排序的思想：</b></font>设待排序序列共n个元素，首先取一个整数gap&lt;n作为间隔，将全部元素分为间隔为gap的gap个子序列并对每一个子序列进行直接插入排序。然后，缩小间隔gap，重复上述操作，直至gap缩小为1，此时所有元素位于同一个序列且有序。由于刚开始时，gap较大，每个子序列元素较少，排序速度较快；待到排序后期，gap变小，每个子序列元素较多，但大部分元素基本有序，所以排序速度仍较快。一般地，gap取 （gap/3 + 1）。希尔排序是一种不稳定的排序方法，其实现如下：</p>



<pre class="prettyprint" name="code"><code class="language-java hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-javadoc">/**        
 * Title: 插入排序中的希尔排序，依赖于初始序列    
 * Description: 分别对间隔为gap的gap个子序列进行直接插入排序，不断缩小gap,直至为 1 
 * 
 *              刚开始时，gap较大，每个子序列元素较少，排序速度较快；
 *              待到排序后期，gap变小，每个子序列元素较多，但大部分元素基本有序，所以排序速度仍较快。                
 * 
 *              时间复杂度：O(n) ~ O(n^2)
 *              空间复杂度：O(1)
 *              稳    定   性：不稳定
 *              内部排序(在排序过程中数据元素完全在内存)
 *<span class="hljs-javadoctag"> @author</span> rico       
 *<span class="hljs-javadoctag"> @created</span> 2017年5月20日 上午10:40:00    
 */</span>      
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShellSort</span> {</span>

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shellSort</span>(<span class="hljs-keyword">int</span>[] target) {
        <span class="hljs-keyword">if</span> (target != <span class="hljs-keyword">null</span> &amp;&amp; target.length != <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">int</span> gap = target.length;    
            <span class="hljs-keyword">while</span> (gap &gt; <span class="hljs-number">1</span>) {      <span class="hljs-comment">// gap为int型，自动取整</span>
                gap = gap / <span class="hljs-number">3</span> + <span class="hljs-number">1</span>;
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = gap; i &lt; target.length; i++) {
                    <span class="hljs-keyword">int</span> j = i - gap;
                    <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span>) {
                        <span class="hljs-keyword">if</span> (target[j + gap] &lt; target[j]) {
                            swap(target, j, j+gap);
                            j -= gap;
                        }<span class="hljs-keyword">else</span>{
                            <span class="hljs-keyword">break</span>;
                        }
                    }
                }
            }
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span>(<span class="hljs-keyword">int</span>[] target, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j) {
        <span class="hljs-keyword">int</span> temp = target[i];
        target[i] = target[j];
        target[j] = temp;
    }
}<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li><li style="color: rgb(153, 153, 153);">31</li><li style="color: rgb(153, 153, 153);">32</li><li style="color: rgb(153, 153, 153);">33</li><li style="color: rgb(153, 153, 153);">34</li><li style="color: rgb(153, 153, 153);">35</li><li style="color: rgb(153, 153, 153);">36</li><li style="color: rgb(153, 153, 153);">37</li><li style="color: rgb(153, 153, 153);">38</li><li style="color: rgb(153, 153, 153);">39</li><li style="color: rgb(153, 153, 153);">40</li><li style="color: rgb(153, 153, 153);">41</li><li style="color: rgb(153, 153, 153);">42</li></ul></pre>

<hr>

<p><strong>3、折半插入排序</strong></p>

<p>　　<font color="red"><b>折半插入排序的思想：</b></font>当插入第i(i&gt;=1)个元素时，前面的V[0],…,V[i-1]等i-1个 元素已经有序。这时，折半搜索第i个元素在前i-1个元素V[i-1]，…，V[0]中的插入位置，然后直接将V[i]插入，同时原来位置上的元素向后顺移。与直接插入排序不同的是，折半插入排序比直接插入排序明显减少了关键字之间的比较次数，但是移动次数是没有改变。所以，折半插入排序和插入排序的时间复杂度相同都是O（N^2），但其减少了比较次数，所以该算法仍然比直接插入排序好。折半插入排序是一种稳定的排序算法，其实现如下：</p>



<pre class="prettyprint" name="code"><code class="language-java hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-javadoc">/**        
 * Title: 插入排序中的折半插入排序，依赖于初始序列  
 * Description: 折半搜索出插入位置，并直接插入;与直接插入搜索的区别是，后者的搜索要快于顺序搜索
 *              时间复杂度：折半插入排序比直接插入排序明显减少了关键字之间的比较次数，但是移动次数是没有改变。所以，
 *              折半插入排序和插入排序的时间复杂度相同都是O（N^2），在减少了比较次数方面它确实相当优秀，所以该算法仍然比直接插入排序好。
 *              空间复杂度：O(1)
 *              稳    定   性：稳定
 *              内部排序(在排序过程中数据元素完全在内存)
 *<span class="hljs-javadoctag"> @author</span> rico       
 *<span class="hljs-javadoctag"> @created</span> 2017年5月25日 下午12:03:23    
 */</span>      
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinaryInsertSort</span> {</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] <span class="hljs-title">binaryInsertSort</span>(<span class="hljs-keyword">int</span>[] target) {
        <span class="hljs-keyword">if</span> (target != <span class="hljs-keyword">null</span> &amp;&amp; target.length &gt; <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; target.length; i++) {
                <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">int</span> right = i - <span class="hljs-number">1</span>;
                <span class="hljs-keyword">int</span> mid;
                <span class="hljs-keyword">int</span> temp = target[i];
                <span class="hljs-keyword">if</span>(temp &lt; target[right]){   <span class="hljs-comment">// 当前值小于有序序列的最大值时，开始查找插入位置</span>
                    <span class="hljs-keyword">while</span>(left &lt;= right){
                        mid = (left + right)/<span class="hljs-number">2</span>;
                        <span class="hljs-keyword">if</span>(target[mid] &lt; temp){
                            left = mid + <span class="hljs-number">1</span>;    <span class="hljs-comment">// 缩小插入区间</span>
                        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target[mid] &gt; temp){
                            right = mid - <span class="hljs-number">1</span>;    <span class="hljs-comment">// 缩小插入区间</span>
                        }<span class="hljs-keyword">else</span>{        <span class="hljs-comment">// 待插入值与有序序列中的target[mid]相等，保证稳定性的处理</span>
                            left = left + <span class="hljs-number">1</span>;   
                        }
                    }

                    <span class="hljs-comment">// left及其后面的数据顺序向后移动，并在left位置插入</span>
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &gt; left; j--) {
                        target[j] = target[j-<span class="hljs-number">1</span>];
                    }
                    target[left] = temp;
                }
            }
        }
        <span class="hljs-keyword">return</span> target;
    }
}<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li><li style="color: rgb(153, 153, 153);">31</li><li style="color: rgb(153, 153, 153);">32</li><li style="color: rgb(153, 153, 153);">33</li><li style="color: rgb(153, 153, 153);">34</li><li style="color: rgb(153, 153, 153);">35</li><li style="color: rgb(153, 153, 153);">36</li><li style="color: rgb(153, 153, 153);">37</li><li style="color: rgb(153, 153, 153);">38</li><li style="color: rgb(153, 153, 153);">39</li><li style="color: rgb(153, 153, 153);">40</li><li style="color: rgb(153, 153, 153);">41</li><li style="color: rgb(153, 153, 153);">42</li></ul></pre>

<hr>



<h2 id="三-选择排序"><a name="t2"></a><a name="t2"></a>三. 选择排序</h2>

<p>　　<font color="red"><b>选择排序的基本思想：</b></font>每一趟 (例如第i趟，i = 0,1,…)在后面第n-i个待排序元素中选出最小元素作为有序序列的第i个元素，直到第n-1趟结束后，所有元素有序。在这里，我们介绍两种具体的选择排序算法：直接选择排序与堆排序。</p>

<hr>

<p><strong>1、直接选择排序</strong></p>

<p>　　<font color="red"><b>直接选择排序的思想：</b></font>第一次从R[0]~R[n-1]中选取最小值，与R[0]交换，第二次从R<a href="http://static.zybuluo.com/Rico123/ymihfm526o5xv5bo1btvm1fy/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.jpg" rel="nofollow" target="_blank">1</a>~R[n-1]中选取最小值，与R<a href="http://static.zybuluo.com/Rico123/ymihfm526o5xv5bo1btvm1fy/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.jpg" rel="nofollow" target="_blank">1</a>交换，….，第i次从R[i-1]~R[n-1]中选取最小值，与R[i-1]交换，…..，第n-1次从R[n-2]~R[n-1]中选取最小值，与R[n-2]交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列。直接选择排序是一种不稳定的排序算法，其实现如下：</p>



<pre class="prettyprint" name="code"><code class="language-java hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-javadoc">/**        
 * Title: 选择排序中的直接选择排序，依赖于初始序列     
 * Description: 每一趟 (例如第i趟，i = 0,1,...)在后面第n-i个待排序元素中选出最小元素作为有序序列的第i个元素
 *              时间复杂度：最好情形O(n^2)，平均情形O(n^2)，最差情形O(n^2)
 *              空间复杂度：O(1)
 *              稳    定   性：不稳定
 *              内部排序(在排序过程中数据元素完全在内存)
 *<span class="hljs-javadoctag"> @author</span> rico       
 *<span class="hljs-javadoctag"> @created</span> 2017年5月20日 上午10:40:00    
 */</span>      
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StraightSelectSort</span> {</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] <span class="hljs-title">selectSort</span>(<span class="hljs-keyword">int</span>[] target){
        <span class="hljs-keyword">if</span>(target != <span class="hljs-keyword">null</span> &amp;&amp; target.length != <span class="hljs-number">1</span>){
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; target.length; i++) {
                <span class="hljs-keyword">int</span> min_index = i;
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; target.length; j++) {
                    <span class="hljs-keyword">if</span>(target[min_index] &gt; target[j]){
                        min_index = j;
                    }
                }
                <span class="hljs-keyword">if</span>(target[min_index] != target[i]){  <span class="hljs-comment">// 导致不稳定的因素：交换</span>
                    <span class="hljs-keyword">int</span> min = target[min_index];
                    target[min_index] = target[i];
                    target[i] = min;
                }
            }
        }
        <span class="hljs-keyword">return</span> target;
    }
}<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li></ul></pre>

<hr>

<p><strong>2、堆排序</strong></p>

<p>　　<font color="red"><b>堆排序的核心是堆调整算法。</b></font>首先根据初始输入数据，利用堆调整算法shiftDown()形成初始堆；然后，将堆顶元素与堆尾元素交换，缩小堆的范围并重新调整为堆，如此往复。堆排序是一种不稳定的排序算法，其实现如下：</p>



<pre class="prettyprint" name="code"><code class="language-java hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-javadoc">/**        
 * Title: 堆排序(选择排序)，升序排序(最大堆)，依赖于初始序列     
 * Description: 现将给定序列调整为最大堆，然后每次将堆顶元素与堆尾元素交换并缩小堆的范围，直到将堆缩小至1
 * 时间复杂度：O(nlgn)
 * 空间复杂度：O(1) 
 * 稳 定 性：不稳定
 * 内部排序(在排序过程中数据元素完全在内存)
 *<span class="hljs-javadoctag"> @author</span> rico       
 *<span class="hljs-javadoctag"> @created</span> 2017年5月25日 上午9:48:06    
 */</span>      
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeapSort</span> {</span>

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] <span class="hljs-title">heapSort</span>(<span class="hljs-keyword">int</span>[] target) {
        <span class="hljs-keyword">if</span> (target != <span class="hljs-keyword">null</span> &amp;&amp; target.length &gt; <span class="hljs-number">1</span>) {

            <span class="hljs-comment">// 调整为最大堆</span>
            <span class="hljs-keyword">int</span> pos = (target.length - <span class="hljs-number">2</span>) / <span class="hljs-number">2</span>;
            <span class="hljs-keyword">while</span> (pos &gt;= <span class="hljs-number">0</span>) {
                shiftDown(target, pos, target.length - <span class="hljs-number">1</span>);
                pos--;
            }

            <span class="hljs-comment">// 堆排序</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = target.length-<span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) {
                <span class="hljs-keyword">int</span> temp = target[i];
                target[i] = target[<span class="hljs-number">0</span>];
                target[<span class="hljs-number">0</span>] = temp;
                shiftDown(target, <span class="hljs-number">0</span>, i-<span class="hljs-number">1</span>);
            }
            <span class="hljs-keyword">return</span> target;
        }
        <span class="hljs-keyword">return</span> target;
    }


    <span class="hljs-javadoc">/**     
     *<span class="hljs-javadoctag"> @description</span> 自上而下调整为最大堆
     *<span class="hljs-javadoctag"> @author</span> rico       
     *<span class="hljs-javadoctag"> @created</span> 2017年5月25日 上午9:45:40     
     *<span class="hljs-javadoctag"> @param</span> target
     *<span class="hljs-javadoctag"> @param</span> start
     *<span class="hljs-javadoctag"> @param</span> end     
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shiftDown</span>(<span class="hljs-keyword">int</span>[] target, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end) {
        <span class="hljs-keyword">int</span> i = start;
        <span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span> * start + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> temp = target[i];
        <span class="hljs-keyword">while</span> (j &lt;= end) {   <span class="hljs-comment">// 迭代条件</span>
            <span class="hljs-keyword">if</span> (j &lt; end &amp;&amp; target[j + <span class="hljs-number">1</span>] &gt; target[j]) {  <span class="hljs-comment">//找出较大子女</span>
                j = j + <span class="hljs-number">1</span>;
            }
            <span class="hljs-keyword">if</span> (target[j] &lt;= temp) {  <span class="hljs-comment">// 父亲大于子女</span>
                <span class="hljs-keyword">break</span>;
            } <span class="hljs-keyword">else</span> {
                target[i] = target[j];
                i = j;
                j = <span class="hljs-number">2</span> * j + <span class="hljs-number">1</span>;
            }
        }
        target[i] = temp;
    }
}<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li><li style="color: rgb(153, 153, 153);">31</li><li style="color: rgb(153, 153, 153);">32</li><li style="color: rgb(153, 153, 153);">33</li><li style="color: rgb(153, 153, 153);">34</li><li style="color: rgb(153, 153, 153);">35</li><li style="color: rgb(153, 153, 153);">36</li><li style="color: rgb(153, 153, 153);">37</li><li style="color: rgb(153, 153, 153);">38</li><li style="color: rgb(153, 153, 153);">39</li><li style="color: rgb(153, 153, 153);">40</li><li style="color: rgb(153, 153, 153);">41</li><li style="color: rgb(153, 153, 153);">42</li><li style="color: rgb(153, 153, 153);">43</li><li style="color: rgb(153, 153, 153);">44</li><li style="color: rgb(153, 153, 153);">45</li><li style="color: rgb(153, 153, 153);">46</li><li style="color: rgb(153, 153, 153);">47</li><li style="color: rgb(153, 153, 153);">48</li><li style="color: rgb(153, 153, 153);">49</li><li style="color: rgb(153, 153, 153);">50</li><li style="color: rgb(153, 153, 153);">51</li><li style="color: rgb(153, 153, 153);">52</li><li style="color: rgb(153, 153, 153);">53</li><li style="color: rgb(153, 153, 153);">54</li><li style="color: rgb(153, 153, 153);">55</li><li style="color: rgb(153, 153, 153);">56</li><li style="color: rgb(153, 153, 153);">57</li><li style="color: rgb(153, 153, 153);">58</li><li style="color: rgb(153, 153, 153);">59</li><li style="color: rgb(153, 153, 153);">60</li><li style="color: rgb(153, 153, 153);">61</li><li style="color: rgb(153, 153, 153);">62</li></ul></pre>

<hr>



<h2 id="四-交换排序"><a name="t3"></a><a name="t3"></a>四. 交换排序</h2>

<p>　　<font color="red"><b>交换排序的基本思想：</b></font>根据序列中两个元素的比较结果来对换这两个记录在序列中的位置，也就是说，将键值较大的记录向序列的尾部移动，键值较小的记录向序列的前部移动。</p>

<hr>

<p><strong>1、冒泡排序</strong></p>

<p>　　<font color="red"><b>冒泡排序的思想：</b></font>根据序列中两个元素的比较结果来对换这两个记录在序列中的位置，将键值较大的记录向序列的尾部移动，键值较小的记录向序列的前部移动。因此，每一趟都将较小的元素移到前面，较大的元素自然就逐渐沉到最后面了，也就是说，最大的元素最后才能确定，这就是冒泡。冒泡排序是一种稳定的排序算法，其实现如下：</p>



<pre class="prettyprint" name="code"><code class="language-java hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-javadoc">/**
 * Title: 交换排序中的冒泡排序 ，一般情形下指的是优化后的冒泡排序，最多进行n-1次比较，依赖于初始序列  
 * Description:因为越大的元素会经由交换慢慢"浮"到数列的顶端(最后位置)，最大的数最后才确定下来，所以称为冒泡排序
 * 时间复杂度：最好情形O(n)，平均情形O(n^2)，最差情形O(n^2) 
 * 空间复杂度：O(1) 
 * 稳 定 性：稳定
 * 内部排序(在排序过程中数据元素完全在内存)
 * 
 *<span class="hljs-javadoctag"> @author</span> rico
 *<span class="hljs-javadoctag"> @created</span> 2017年5月20日 上午10:40:00
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BubbleSort</span> {</span>

    <span class="hljs-javadoc">/**     
     *<span class="hljs-javadoctag"> @description</span> 朴素冒泡排序(共进行n-1次比较)
     *<span class="hljs-javadoctag"> @author</span> rico         
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] <span class="hljs-title">bubbleSort</span>(<span class="hljs-keyword">int</span>[] target) {
        <span class="hljs-keyword">int</span> n = target.length;
        <span class="hljs-keyword">if</span> (target != <span class="hljs-keyword">null</span> &amp;&amp; n != <span class="hljs-number">1</span>) {
            <span class="hljs-comment">// 最多需要进行n-1躺，每一趟将比较小的元素移到前面，比较大的元素自然就逐渐沉到最后面了，这就是冒泡</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n-<span class="hljs-number">1</span>; i++) {      
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = n-<span class="hljs-number">1</span>; j &gt; i; j--) {
                    <span class="hljs-keyword">if</span>(target[j] &lt; target[j-<span class="hljs-number">1</span>]){
                        <span class="hljs-keyword">int</span> temp = target[j];
                        target[j] = target[j-<span class="hljs-number">1</span>];
                        target[j-<span class="hljs-number">1</span>] = temp;
                    }
                }
                System.out.println(Arrays.toString(target));
            }
        }
        <span class="hljs-keyword">return</span> target;
    }

    <span class="hljs-javadoc">/**     
     *<span class="hljs-javadoctag"> @description</span> 优化冒泡排序
     *<span class="hljs-javadoctag"> @author</span> rico         
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] <span class="hljs-title">optimizeBubbleSort</span>(<span class="hljs-keyword">int</span>[] target) {
        <span class="hljs-keyword">int</span> n = target.length;
        <span class="hljs-keyword">if</span> (target != <span class="hljs-keyword">null</span> &amp;&amp; n != <span class="hljs-number">1</span>) {
            <span class="hljs-comment">// 最多需要进行n-1躺，每一趟将比较小的元素移到前面，比较大的元素自然就逐渐沉到最后面了，这就是冒泡</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n-<span class="hljs-number">1</span>; i++) {      
                <span class="hljs-keyword">boolean</span> exchange = <span class="hljs-keyword">false</span>;
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = n-<span class="hljs-number">1</span>; j &gt; i; j--) {
                    <span class="hljs-keyword">if</span>(target[j] &lt; target[j-<span class="hljs-number">1</span>]){
                        <span class="hljs-keyword">int</span> temp = target[j];
                        target[j] = target[j-<span class="hljs-number">1</span>];
                        target[j-<span class="hljs-number">1</span>] = temp;
                        exchange = <span class="hljs-keyword">true</span>;
                    }
                }
                System.out.println(Arrays.toString(target));
                <span class="hljs-keyword">if</span> (!exchange){    <span class="hljs-comment">// 若 i 到 n-1 这部分元素已经有序，则直接返回</span>
                    <span class="hljs-keyword">return</span> target;
                }
            }
        }
        <span class="hljs-keyword">return</span> target;
    }
}<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li><li style="color: rgb(153, 153, 153);">31</li><li style="color: rgb(153, 153, 153);">32</li><li style="color: rgb(153, 153, 153);">33</li><li style="color: rgb(153, 153, 153);">34</li><li style="color: rgb(153, 153, 153);">35</li><li style="color: rgb(153, 153, 153);">36</li><li style="color: rgb(153, 153, 153);">37</li><li style="color: rgb(153, 153, 153);">38</li><li style="color: rgb(153, 153, 153);">39</li><li style="color: rgb(153, 153, 153);">40</li><li style="color: rgb(153, 153, 153);">41</li><li style="color: rgb(153, 153, 153);">42</li><li style="color: rgb(153, 153, 153);">43</li><li style="color: rgb(153, 153, 153);">44</li><li style="color: rgb(153, 153, 153);">45</li><li style="color: rgb(153, 153, 153);">46</li><li style="color: rgb(153, 153, 153);">47</li><li style="color: rgb(153, 153, 153);">48</li><li style="color: rgb(153, 153, 153);">49</li><li style="color: rgb(153, 153, 153);">50</li><li style="color: rgb(153, 153, 153);">51</li><li style="color: rgb(153, 153, 153);">52</li><li style="color: rgb(153, 153, 153);">53</li><li style="color: rgb(153, 153, 153);">54</li><li style="color: rgb(153, 153, 153);">55</li><li style="color: rgb(153, 153, 153);">56</li><li style="color: rgb(153, 153, 153);">57</li><li style="color: rgb(153, 153, 153);">58</li><li style="color: rgb(153, 153, 153);">59</li><li style="color: rgb(153, 153, 153);">60</li><li style="color: rgb(153, 153, 153);">61</li><li style="color: rgb(153, 153, 153);">62</li></ul></pre>

<hr>

<p><strong>2、快速排序</strong></p>

<p>　　<font color="red"><b>快速排序的思想：</b></font>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小(划分过程)，然后再按此方法对这两部分数据分别进行快速排序(快速排序过程)，整个排序过程可以递归进行，以此达到整个数据变成有序序列。快速排序是一种不稳定的排序算法。</p>



<pre class="prettyprint" name="code"><code class="language-java hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-javadoc">/**
 * Title: 交换排序中的快速排序，目前应用最为广泛的排序算法，是一个递归算法，依赖于初始序列  
 * Description:快速排序包括两个过程：划分 和 快排
 * "划分"是指将原序列按基准元素划分两个子序列
 * "快排"是指分别对子序列进行快排
 * 
 * 就平均计算时间而言，快速排序是所有内部排序方法中最好的一个
 * 
 * 对大规模数据排序时，快排是快的；对小规模数据排序时，快排是慢的，甚至慢于简单选择排序等简单排序方法
 * 
 * 快速排序依赖于原始序列，因此其时间复杂度从O(nlgn)到O(n^2)不等
 * 时间复杂度：最好情形O(nlgn)，平均情形O(nlgn)，最差情形O(n^2)
 * 
 * 递归所消耗的栈空间
 * 空间复杂度：O(lgn)
 * 
 * 可选任一元素作为基准元素
 * 稳 定 性：不稳定
 * 
 * 
 * 内部排序(在排序过程中数据元素完全在内存)
 * 
 *<span class="hljs-javadoctag"> @author</span> rico
 *<span class="hljs-javadoctag"> @created</span> 2017年5月20日 上午10:40:00
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuickSort</span> {</span>

    <span class="hljs-javadoc">/**     
     *<span class="hljs-javadoctag"> @description</span> 快排算法(递归算法)：在递去过程中就把问题解决了
     *<span class="hljs-javadoctag"> @author</span> rico       
     *<span class="hljs-javadoctag"> @created</span> 2017年5月20日 下午5:12:06     
     *<span class="hljs-javadoctag"> @param</span> target
     *<span class="hljs-javadoctag"> @param</span> left
     *<span class="hljs-javadoctag"> @param</span> right
     *<span class="hljs-javadoctag"> @return</span>     
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] <span class="hljs-title">quickSort</span>(<span class="hljs-keyword">int</span>[] target, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right) {

        <span class="hljs-keyword">if</span>(right &gt; left){     <span class="hljs-comment">// 递归终止条件</span>
            <span class="hljs-keyword">int</span> base_index = partition(target,left, right);  <span class="hljs-comment">// 原序列划分后基准元素的位置</span>
            quickSort(target, left, base_index-<span class="hljs-number">1</span>);    <span class="hljs-comment">// 对第一个子序列快速排序，不包含基准元素！</span>
            quickSort(target, base_index+<span class="hljs-number">1</span>, right);   <span class="hljs-comment">// 对第二个子序列快速排序，不包含基准元素！</span>
            <span class="hljs-keyword">return</span> target;
        }
        <span class="hljs-keyword">return</span> target;
    }


    <span class="hljs-javadoc">/**     
     *<span class="hljs-javadoctag"> @description</span> 序列划分，以第一个元素为基准元素
     *<span class="hljs-javadoctag"> @author</span> rico       
     *<span class="hljs-javadoctag"> @created</span> 2017年5月20日 下午5:10:54     
     *<span class="hljs-javadoctag"> @param</span> target  序列
     *<span class="hljs-javadoctag"> @param</span> left 序列左端
     *<span class="hljs-javadoctag"> @param</span> right  序列右端
     *<span class="hljs-javadoctag"> @return</span>     
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span>(<span class="hljs-keyword">int</span>[] target, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right){

        <span class="hljs-keyword">int</span> base = target[left];   <span class="hljs-comment">// 基准元素的值</span>
        <span class="hljs-keyword">int</span> base_index = left;    <span class="hljs-comment">// 基准元素最终应该在的位置</span>

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left+<span class="hljs-number">1</span>; i &lt;= right; i++) {  <span class="hljs-comment">// 从基准元素的下一个元素开始</span>
            <span class="hljs-keyword">if</span>(target[i] &lt; base){       <span class="hljs-comment">//  若其小于基准元素</span>
                base_index++;           <span class="hljs-comment">// 若其小于基准元素,则基准元素最终位置后移；否则不用移动</span>
                <span class="hljs-keyword">if</span>(base_index != i){    <span class="hljs-comment">// 相等情况意味着i之前的元素都小于base,只需要换一次即可，不需要次次都换</span>
                    <span class="hljs-keyword">int</span> temp = target[base_index];
                    target[base_index] = target[i];
                    target[i] = temp;
                }
            }
        }

        <span class="hljs-comment">// 将基准元素就位</span>
        target[left] = target[base_index];   
        target[base_index] = base;

        System.out.println(Arrays.toString(target));

        <span class="hljs-keyword">return</span> base_index;  <span class="hljs-comment">//返回划分后基准元素的位置</span>
    }
}<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li><li style="color: rgb(153, 153, 153);">31</li><li style="color: rgb(153, 153, 153);">32</li><li style="color: rgb(153, 153, 153);">33</li><li style="color: rgb(153, 153, 153);">34</li><li style="color: rgb(153, 153, 153);">35</li><li style="color: rgb(153, 153, 153);">36</li><li style="color: rgb(153, 153, 153);">37</li><li style="color: rgb(153, 153, 153);">38</li><li style="color: rgb(153, 153, 153);">39</li><li style="color: rgb(153, 153, 153);">40</li><li style="color: rgb(153, 153, 153);">41</li><li style="color: rgb(153, 153, 153);">42</li><li style="color: rgb(153, 153, 153);">43</li><li style="color: rgb(153, 153, 153);">44</li><li style="color: rgb(153, 153, 153);">45</li><li style="color: rgb(153, 153, 153);">46</li><li style="color: rgb(153, 153, 153);">47</li><li style="color: rgb(153, 153, 153);">48</li><li style="color: rgb(153, 153, 153);">49</li><li style="color: rgb(153, 153, 153);">50</li><li style="color: rgb(153, 153, 153);">51</li><li style="color: rgb(153, 153, 153);">52</li><li style="color: rgb(153, 153, 153);">53</li><li style="color: rgb(153, 153, 153);">54</li><li style="color: rgb(153, 153, 153);">55</li><li style="color: rgb(153, 153, 153);">56</li><li style="color: rgb(153, 153, 153);">57</li><li style="color: rgb(153, 153, 153);">58</li><li style="color: rgb(153, 153, 153);">59</li><li style="color: rgb(153, 153, 153);">60</li><li style="color: rgb(153, 153, 153);">61</li><li style="color: rgb(153, 153, 153);">62</li><li style="color: rgb(153, 153, 153);">63</li><li style="color: rgb(153, 153, 153);">64</li><li style="color: rgb(153, 153, 153);">65</li><li style="color: rgb(153, 153, 153);">66</li><li style="color: rgb(153, 153, 153);">67</li><li style="color: rgb(153, 153, 153);">68</li><li style="color: rgb(153, 153, 153);">69</li><li style="color: rgb(153, 153, 153);">70</li><li style="color: rgb(153, 153, 153);">71</li><li style="color: rgb(153, 153, 153);">72</li><li style="color: rgb(153, 153, 153);">73</li><li style="color: rgb(153, 153, 153);">74</li><li style="color: rgb(153, 153, 153);">75</li><li style="color: rgb(153, 153, 153);">76</li><li style="color: rgb(153, 153, 153);">77</li><li style="color: rgb(153, 153, 153);">78</li><li style="color: rgb(153, 153, 153);">79</li><li style="color: rgb(153, 153, 153);">80</li><li style="color: rgb(153, 153, 153);">81</li><li style="color: rgb(153, 153, 153);">82</li></ul></pre>

<hr>



<h2 id="五-归并排序"><a name="t4"></a><a name="t4"></a>五. 归并排序</h2>

<p>　　<font color="red"><b>归并排序包含两个过程：”归”和”并”。</b></font>其中，”归”是指将原序列分成半子序列，分别对子序列进行递归排序；”并”是指将排好序的各子序列合并成原序列。归并排序算法是一个典型的递归算法，因此也是概念上最为简单的排序算法。与快速排序算法相比，归并排序算法不依赖于初始序列，并且是一种稳定的排序算法，但需要与原序列一样大小的辅助存储空间。</p>



<pre class="prettyprint" name="code"><code class="language-java hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-javadoc">/**
 * Title: 归并排序 ，概念上最为简单的排序算法，是一个递归算法 Description:归并排序包括两个过程：归 和 并
 * "归"是指将原序列分成半子序列，分别对子序列进行递归排序 "并"是指将排好序的各子序列合并成原序列
 * 
 * 归并排序的主要问题是：需要一个与原待排序数组一样大的辅助数组空间
 * 
 * 归并排序不依赖于原始序列，因此其最好情形、平均情形和最差情形时间复杂度都一样 时间复杂度：最好情形O(n)，平均情形O(n^2)，最差情形O(n^2)
 * 空间复杂度：O(n) 稳 定 性：稳定 内部排序(在排序过程中数据元素完全在内存)
 * 
 *<span class="hljs-javadoctag"> @author</span> rico
 *<span class="hljs-javadoctag"> @created</span> 2017年5月20日 上午10:40:00
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MergeSort</span> {</span>

    <span class="hljs-javadoc">/**
     *<span class="hljs-javadoctag"> @description</span> 归并排序算法(递归算法)：递去分解，归来合并
     *<span class="hljs-javadoctag"> @author</span> rico
     *<span class="hljs-javadoctag"> @created</span> 2017年5月20日 下午4:04:52
     *<span class="hljs-javadoctag"> @param</span> target
     *            待排序序列
     *<span class="hljs-javadoctag"> @param</span> left
     *            待排序序列起始位置
     *<span class="hljs-javadoctag"> @param</span> right
     *            待排序序列终止位置
     *<span class="hljs-javadoctag"> @return</span>
     */</span>

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span>(<span class="hljs-keyword">int</span>[] target) {
        <span class="hljs-keyword">int</span>[] copy = Arrays.copyOf(target, target.length);    <span class="hljs-comment">// 空间复杂度O(n)</span>
        mergeSort(target, copy, <span class="hljs-number">0</span>, target.length - <span class="hljs-number">1</span>);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span>(<span class="hljs-keyword">int</span>[] target, <span class="hljs-keyword">int</span>[] copy, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right) {
        <span class="hljs-keyword">if</span> (right &gt; left) { <span class="hljs-comment">// 递归终止条件</span>
            <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;
            mergeSort(target, copy, left, mid); <span class="hljs-comment">// 归并排序第一个子序列</span>
            mergeSort(target, copy, mid + <span class="hljs-number">1</span>, right); <span class="hljs-comment">// 归并排序第二个子序列</span>
            merge(target, copy, left, mid, right); <span class="hljs-comment">// 合并子序列成原序列</span>
        }
    }

    <span class="hljs-javadoc">/**
     *<span class="hljs-javadoctag"> @description</span> 两路归并算法
     *<span class="hljs-javadoctag"> @author</span> rico
     *<span class="hljs-javadoctag"> @created</span> 2017年5月20日 下午3:59:16
     *<span class="hljs-javadoctag"> @param</span> target
     *            用于存储归并结果
     *<span class="hljs-javadoctag"> @param</span> left
     *            第一个有序表的第一个元素所在位置
     *<span class="hljs-javadoctag"> @param</span> mid
     *            第一个有序表的最后一个元素所在位置
     *<span class="hljs-javadoctag"> @param</span> right
     *            第二个有序表的最后一个元素所在位置
     *<span class="hljs-javadoctag"> @return</span>
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span>(<span class="hljs-keyword">int</span>[] target, <span class="hljs-keyword">int</span>[] copy, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> mid,
            <span class="hljs-keyword">int</span> right) {

        <span class="hljs-comment">// s1,s2是检查指针，index 是存放指针</span>
        <span class="hljs-keyword">int</span> s1 = left;
        <span class="hljs-keyword">int</span> s2 = mid + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> index = left;

        <span class="hljs-comment">// 两个表都未检查完，两两比较</span>
        <span class="hljs-keyword">while</span> (s1 &lt;= mid &amp;&amp; s2 &lt;= right) {
            <span class="hljs-keyword">if</span> (copy[s1] &lt;= copy[s2]) { <span class="hljs-comment">// 稳定性</span>
                target[index++] = copy[s1++];
            } <span class="hljs-keyword">else</span> {
                target[index++] = copy[s2++];
            }
        }

        <span class="hljs-comment">// 若第一个表未检查完，复制</span>
        <span class="hljs-keyword">while</span> (s1 &lt;= mid) {
            target[index++] = copy[s1++];
        }

        <span class="hljs-comment">// 若第二个表未检查完，复制</span>
        <span class="hljs-keyword">while</span> (s2 &lt;= right) {
            target[index++] = copy[s2++];
        }

        <span class="hljs-comment">// 更新辅助数组 copy</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left; i &lt;= right; i++) {
            copy[i] = target[i];
        }
    }<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li><li style="color: rgb(153, 153, 153);">31</li><li style="color: rgb(153, 153, 153);">32</li><li style="color: rgb(153, 153, 153);">33</li><li style="color: rgb(153, 153, 153);">34</li><li style="color: rgb(153, 153, 153);">35</li><li style="color: rgb(153, 153, 153);">36</li><li style="color: rgb(153, 153, 153);">37</li><li style="color: rgb(153, 153, 153);">38</li><li style="color: rgb(153, 153, 153);">39</li><li style="color: rgb(153, 153, 153);">40</li><li style="color: rgb(153, 153, 153);">41</li><li style="color: rgb(153, 153, 153);">42</li><li style="color: rgb(153, 153, 153);">43</li><li style="color: rgb(153, 153, 153);">44</li><li style="color: rgb(153, 153, 153);">45</li><li style="color: rgb(153, 153, 153);">46</li><li style="color: rgb(153, 153, 153);">47</li><li style="color: rgb(153, 153, 153);">48</li><li style="color: rgb(153, 153, 153);">49</li><li style="color: rgb(153, 153, 153);">50</li><li style="color: rgb(153, 153, 153);">51</li><li style="color: rgb(153, 153, 153);">52</li><li style="color: rgb(153, 153, 153);">53</li><li style="color: rgb(153, 153, 153);">54</li><li style="color: rgb(153, 153, 153);">55</li><li style="color: rgb(153, 153, 153);">56</li><li style="color: rgb(153, 153, 153);">57</li><li style="color: rgb(153, 153, 153);">58</li><li style="color: rgb(153, 153, 153);">59</li><li style="color: rgb(153, 153, 153);">60</li><li style="color: rgb(153, 153, 153);">61</li><li style="color: rgb(153, 153, 153);">62</li><li style="color: rgb(153, 153, 153);">63</li><li style="color: rgb(153, 153, 153);">64</li><li style="color: rgb(153, 153, 153);">65</li><li style="color: rgb(153, 153, 153);">66</li><li style="color: rgb(153, 153, 153);">67</li><li style="color: rgb(153, 153, 153);">68</li><li style="color: rgb(153, 153, 153);">69</li><li style="color: rgb(153, 153, 153);">70</li><li style="color: rgb(153, 153, 153);">71</li><li style="color: rgb(153, 153, 153);">72</li><li style="color: rgb(153, 153, 153);">73</li><li style="color: rgb(153, 153, 153);">74</li><li style="color: rgb(153, 153, 153);">75</li><li style="color: rgb(153, 153, 153);">76</li><li style="color: rgb(153, 153, 153);">77</li><li style="color: rgb(153, 153, 153);">78</li><li style="color: rgb(153, 153, 153);">79</li><li style="color: rgb(153, 153, 153);">80</li><li style="color: rgb(153, 153, 153);">81</li><li style="color: rgb(153, 153, 153);">82</li><li style="color: rgb(153, 153, 153);">83</li><li style="color: rgb(153, 153, 153);">84</li><li style="color: rgb(153, 153, 153);">85</li><li style="color: rgb(153, 153, 153);">86</li><li style="color: rgb(153, 153, 153);">87</li></ul></pre>

<p>　　Ps : 归并排序和快速排序都是典型的递归算法，因此它们比较容易理解和实现。关于递归思想和内涵深度剖析，请见博文<a href="http://blog.csdn.net/justloveyou_/article/details/71787149">《算法设计方法：递归的内涵与经典应用》</a>。</p>

<hr>

<h2 id="六-分配排序基数排序"><a name="t5"></a><a name="t5"></a>六. 分配排序(基数排序)</h2>

<p>　　<font color="red"><b>分配排序的基本思想</b></font>：用空间换时间。在整个排序过程中，无须比较关键字，而是通过用额外的空间来”分配”和”收集”来实现排序，它们的时间复杂度可达到线性阶：O(n)。其中，基数排序包括两个过程：首先，将目标序列各元素分配到各个桶中(分配过程)；然后，将各个桶中的元素按先进先出的顺序再放回去(收集过程)，如此往复，一共需要进行d趟，d为元素的位数。</p>



<pre class="prettyprint" name="code"><code class="language-java hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-javadoc">/**        
 * Title: 分配排序中的基数排序，不依赖于初始序列  
 * Description: 不是在对元素进行比较的基础上进行排序，而是采用 "分配 + 收集" 的办法 
 * 
 *              首先，将目标序列各元素分配到各个桶中；
 *              其次，将各个桶中的元素按先进先出的顺序再放回去
 *              如此往复...             
 * 
 *              时间复杂度：O(d*(r+n))或者 O(dn),d 的大小一般会受到 n的影响
 *              空间复杂度：O(rd + n)或者 O(n)
 *              稳    定   性：稳定
 *              内部排序(在排序过程中数据元素完全在内存)
 *<span class="hljs-javadoctag"> @author</span> rico       
 *<span class="hljs-javadoctag"> @created</span> 2017年5月20日 上午10:40:00    
 */</span>   
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RadixSort</span> {</span>

    <span class="hljs-javadoc">/**     
     *<span class="hljs-javadoctag"> @description</span> 分配 + 收集
     *<span class="hljs-javadoctag"> @author</span> rico       
     *<span class="hljs-javadoctag"> @created</span> 2017年5月21日 下午9:25:52     
     *<span class="hljs-javadoctag"> @param</span> target 待排序数组
     *<span class="hljs-javadoctag"> @param</span> r 基数
     *<span class="hljs-javadoctag"> @param</span> d 元素的位数
     *<span class="hljs-javadoctag"> @param</span> n 待排序元素个数
     *<span class="hljs-javadoctag"> @return</span>     
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] <span class="hljs-title">radixSort</span>(<span class="hljs-keyword">int</span>[] target, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> d, <span class="hljs-keyword">int</span> n){
        <span class="hljs-keyword">if</span> (target != <span class="hljs-keyword">null</span> &amp;&amp; target.length != <span class="hljs-number">1</span> ) {

            <span class="hljs-keyword">int</span>[][] bucket = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[r][n];  <span class="hljs-comment">// 一共有基数r个桶，每个桶最多放n个元素</span>
            <span class="hljs-keyword">int</span> digit;  <span class="hljs-comment">// 获取元素对应位上的数字，即装入那个桶</span>
            <span class="hljs-keyword">int</span> divisor = <span class="hljs-number">1</span>;   <span class="hljs-comment">// 定义每一轮的除数，1, 10, 100, ...</span>
            <span class="hljs-keyword">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[r];   <span class="hljs-comment">// 统计每个桶中实际存放元素的个数</span>

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; d; i++) {  <span class="hljs-comment">// d 位的元素，需要经过分配、收集d次即可完成排序</span>

                <span class="hljs-comment">// 分配</span>
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ele : target) {   
                    digit = (ele/divisor) % <span class="hljs-number">10</span>;  <span class="hljs-comment">// 获取元素对应位上的数字(巧妙！！！)</span>
                    bucket[digit][count[digit]++] = ele; <span class="hljs-comment">// 将元素放入对应桶，桶中元素数目加1</span>
                }

                <span class="hljs-comment">// 收集</span>
                <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 目标数组的下标</span>
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; r; j++) {
                    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 用于按照先进先出顺序获取桶中元素</span>
                    <span class="hljs-keyword">while</span>(k &lt; count[j]){
                        target[index++] = bucket[j][k++];  <span class="hljs-comment">// 按照先进先出依次取出桶中的元素</span>
                    }
                    count[j] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 计数器归零</span>
                }
                divisor *= <span class="hljs-number">10</span>;  <span class="hljs-comment">//用于获取元素对应位数字</span>
            }
        }
        <span class="hljs-keyword">return</span> target;
    }
}<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li><li style="color: rgb(153, 153, 153);">31</li><li style="color: rgb(153, 153, 153);">32</li><li style="color: rgb(153, 153, 153);">33</li><li style="color: rgb(153, 153, 153);">34</li><li style="color: rgb(153, 153, 153);">35</li><li style="color: rgb(153, 153, 153);">36</li><li style="color: rgb(153, 153, 153);">37</li><li style="color: rgb(153, 153, 153);">38</li><li style="color: rgb(153, 153, 153);">39</li><li style="color: rgb(153, 153, 153);">40</li><li style="color: rgb(153, 153, 153);">41</li><li style="color: rgb(153, 153, 153);">42</li><li style="color: rgb(153, 153, 153);">43</li><li style="color: rgb(153, 153, 153);">44</li><li style="color: rgb(153, 153, 153);">45</li><li style="color: rgb(153, 153, 153);">46</li><li style="color: rgb(153, 153, 153);">47</li><li style="color: rgb(153, 153, 153);">48</li><li style="color: rgb(153, 153, 153);">49</li><li style="color: rgb(153, 153, 153);">50</li><li style="color: rgb(153, 153, 153);">51</li><li style="color: rgb(153, 153, 153);">52</li><li style="color: rgb(153, 153, 153);">53</li><li style="color: rgb(153, 153, 153);">54</li><li style="color: rgb(153, 153, 153);">55</li><li style="color: rgb(153, 153, 153);">56</li><li style="color: rgb(153, 153, 153);">57</li><li style="color: rgb(153, 153, 153);">58</li></ul></pre>

<hr>



<h2 id="七-总结"><a name="t6"></a><a name="t6"></a>七. 总结</h2>

<p>　　 　　 　　 　　 　　 　<img src="http://static.zybuluo.com/Rico123/ymihfm526o5xv5bo1btvm1fy/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.jpg" alt="八大排序算法总结.jpg-201kB" title=""></p>

<hr>

<p>1、直接插入排序 Vs. 折半插入排序 Vs. 希尔排序</p>

<p>　　这三种排序方法都属于插入排序的范畴。与直接插入排序的顺序搜索插入位置相比，折半插入排序通过折半搜索的方法搜索插入位置，因此，在搜索插入位置方面，折半插入排序要快于直接插入排序。实际上，折半插入排序比直接插入排序只是减少了关键字之间的比较次数，但是移动次数是没有改变。所以，折半插入排序和插入排序的时间复杂度相同都是O（n^2），但减少了比较次数，所以该算法要比直接插入排序好一点。希尔排序可以看作是对直接插入排序的一种优化，它将全部元素分为间隔为gap的gap个子序列并对每一个子序列进行直接插入排序，同时不断缩小间隔gap，直至所有元素位于同一个序列。使用这种方式可以保证排序效率，因为刚开始时，gap较大，每个子序列元素较少，排序速度较快；待到排序后期，gap变小，每个子序列元素较多，但大部分元素基本有序，所以排序速度仍较快。因此，希尔排序比直接插入排序 、折半插入排序都要高效，但它不是稳定的。</p>

<hr>

<p>2、直接选择排序 Vs. 堆排序</p>

<p>　　这两种排序方法都属于插入选择排序的范畴，它们的核心思想都是每一趟都选择一个极值元素放在靠前/靠后位置，直到序列有序。与直接选择排序不同的是，堆排序不是“蛮力选择”，而是不断进行堆调整以取得每趟中的极值。因此，堆排序比直接选择排序要高效，不过它们都是不稳定的。</p>

<hr>

<p>3、冒泡排序 Vs. 快速排序</p>

<p>　　这两种排序方法都属于选择排序的范畴，它们的核心思想都是元素的交换，冒泡排序中每一趟相邻元素互相比较，并将较小的交换到前面(较大的自然沉到后面)位置，快速排序则是以基准点为基础，将比它小的元素和比它大的元素分别交换到它的两边。因此，快速排序比冒泡排序要高效，但它不是稳定的。</p>

<hr>

<p>4、归并排序 Vs. 快速排序</p>

<p>　　这两种排序方法都属于递归算法的范畴，因此，它们都比较容易让人理解和实现。与快速排序相比，归并排序不但是稳定的，还是与原始序列无关的(不依赖于原始序列的顺序，时间复杂度总是O(nlgn))，但是需要与原始序列一样大小的空间；而快速排序则一般情况下都要比其他高效排序算法（包括归并排序）快，而且空间复杂度只为O(1)。另外，我们从算法实现中可以看出这两种递归算法有以下区别和联系：</p>

<ul>
<li>二者的递归终止条件相同；</li>
<li>二者的实现结构较为类似，归并排序是先归后并，快速排序是先分后排；</li>
<li>归并排序的核心实现在于有序子序列的合并，而快速排序的核心实现在于对原始序列的划分；</li>
</ul>

<hr>

<p>5、小结</p>

<p>　　直接插入排序、直接选择排序和冒泡排序是基本的排序方法，它们平均情况下的时间复杂度都是O(n^2)，实现也比较简单，它们对规模较小的元素序列很有效。</p>

<p>　　快速排序、堆排序和归并排序是高效的排序方法，它们平均情况下的时间复杂度都是O(nlgn)，其中快速排序是最通用的高效排序算法，但其是不稳定的；归并排序是上述几种排序算法中唯一与初始序列无关的，而且时间复杂度总是O(nlgn)，但其空间复杂度是O(n)，是一种稳定的排序算法；堆排序的时间复杂度总是O(nlgn)，空间复杂度是O(1)，也是不稳定的。它们对规模较大的元素序列很有效。</p>

<p>　　希尔排序的效率介于基本排序方法与高效排序方法之间，是一种不稳定的排序算法。它们各有所长，都拥有特定的使用场景。基数排序虽然具有线性增长的时间复杂度，但实际上开销并不比快速排序小很多，应用相对不太广泛。</p>

<p>　　因此，在实际应用中，我们必须根据实际任务的特点和各种排序算法的特性来做出最合适的选择。</p>

<hr>



<h2 id="八-更多"><a name="t7"></a><a name="t7"></a>八. 更多</h2>

<p>　　归并排序和快速排序都是典型的递归算法，因此它们比较容易理解和实现。关于递归思想和内涵深度剖析，请见博文<a href="http://blog.csdn.net/justloveyou_/article/details/71787149" target="_blank">《算法设计方法：递归的内涵与经典应用》</a>。</p>

<hr>

<blockquote>
  <h2 id="引用"><a name="t8"></a><a name="t8"></a>引用</h2>

  <p><a href="http://blog.csdn.net/hguisu/article/details/7776068/" target="_blank">《八大排序算法》</a></p>
</blockquote>                                    </div>
                <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-60ecaf1f42.css" rel="stylesheet">
                                </div>]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
</search>

---
title: 并发编程第一章知识点
date: 2020-06-16 19:44:08
tags: 并发编程
categories: 并发编程
---

## 概述

> 本章介绍并发编程第一章知识点

<!--more-->

## 正文

1 进程和线程的区别

看了一遍排在前面的答案，类似”**进程是资源分配的最小单位，线程是CPU调度的最小单位“**这样的回答感觉太抽象，都不太容易让人理解。

做个简单的比喻：进程=火车，线程=车厢

- 线程在进程下行进（单纯的车厢无法运行）
- 一个进程可以包含多个线程（一辆火车可以有多个车厢）
- 不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）
- 同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）
- 进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）
- 进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）
- 进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）
- 进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－"互斥锁"
- 进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”

\2. 竞态

p15

\3. 竞态的两种模式

\4. 原子性

p15

\5. java实现原子性



\6. 可见性

可见性是指当一个线程修改了共享变量后，其他线程能够立即得知这个修改。通过之前对[synchronzed](https://www.jianshu.com/p/d53bf830fa09)内存语义进行了分析，当线程获取锁时会从主内存中获取共享变量的最新值，释放锁的时候会将共享变量同步到主内存中。从而，**synchronized具有可见性**。同样的在[volatile分析中](https://www.jianshu.com/p/157279e6efdb)，会通过在指令中添加**lock指令**，以实现内存可见性。因此, **volatile具有可见性**



\7. 重排序

\8.  锁的概述



\9.  锁的分类

\10. 锁的作用

\11. 使用所保证线程安全是有条件的

\12. 锁的几个概念

\13. 内部锁

\14. 显示锁与内部锁的比较

\15. 锁的选用

\16. 改进锁（读写锁）ReadWriteLock

\17. 锁的使用场景

\18. 线程同步的底层助手：内存屏障

\19. 锁与重排序

\20. 轻量级同步机制volatile

\21. volatile的作用



\22. CAS与原子变量

\23. 字段更新器

\24. 对象初始化线程安全：重放final和static

\25. 线程数的设置

\26. 等待与通知：notify/notify

\27. wait,notify的开销及问题

\28. 多线程编程的硬件基础与java内存模型

\29. volatile关键字的实现

![](https://photos.alitaalice.cn/image/20200616210931.png)

\30. Java实现生产者消费者的三种方法

\31. 启动线程

\32. volatile关键字的作用

![](https://photos.alitaalice.cn/image/20200616210716.png)

\33. final域的内存语义

\34. 双重检查加锁与延迟初始化

\35. 线程优先级

\36. 什么是线程安全

\37. 线程池线程数量

\38. 线程池超负载了怎么办（jdk内置的拒绝策略）

\39. sleep和wait的区别

\40. Java中的NIO，BIO，AIO分别是什么
---
title: 散列表详解
date: 2020-05-13 15:58:48
tags: DataStructure
categories: 算法
---

## 概述

> 本章介绍散列表。

<!--more-->

## 正文

## 散列函数

我们面对的第一个问题就是散列函数的计算，这个过程会将键转化为数组的索引。如果我们有一个能够保存 M个键值对的数组，那么我们就需要一个能够将任意键转化为该数组范围内的索引([0,M-1] 范围内的整数）的散列函数 -

散列函数和键的类型有关。**严格地说，对于每种类型的键都我们都需要一个与之对应的散列函数 。**如果键是一个数，比如社会保险号，我们就可以直接使用这个数；如果键是一个字符串，比如一个人的名字，
我们就需要将这个字符串转化为一个数；**如果键含有多个部分，比如邮件地址，我们需要用某种方法将这些部分结合起来**。对于许多常见类型的键，我们可以利用 Java 提供的默认实现。我们会简略讨论多种数
据类型的散列函数。你应该看看它们是如何实现的，因为你也需要为自定义的类型实现散列函数。  

### 正整数

将整数散列最常用方法是**除留余数法** 。我们选择大小为素数 的数组，对于任意正整数 ，计算除以M 的余数。这个函数的计算非常容易（在 Java 中为 k% M ）并能够有效地将键散布在 0 到M-1的范围内。  

![](https://photos.alitaalice.cn/image/20200513162105.png)

### 浮点数

如果键是 0 到 1 之间的实数，我们可以将它乘以 M并四舍五入得到一个 0 至 M-1之间的索引值。
尽管这个方法很容易理解，但它是有缺陷的，因为这种情况下键的高位起的作用更大，最低位对散列的结果没有影响。修正这个问题的办法是将键表示为二进制数然后再使用除留余数法（Java 就是这么做的）  

## 字符串

## 组合键

## JAVA的约定

每种数据类型都需要相应的散列函数，于是 Java 令所有数据类型都继承了一个能够返回一个 32 比特整数的 hashCode() 方法。每一种数据类型的 hashCode() 方法都必须和 equals() 方法一致 。也就是说，如果 a.equals(b) 返回 true ，那么 a.hashCode() 的返回值必然和 b.hashCode()的返回值相同。相反，如果两个对象的 hashCode() 方法的返回值不同，那么我们就知道这两个对象是不同的。但如果两个对象的 hashCode() 方法的返回值相同，这两个对象也有可能不同，我们还需要用equals() 方法进行判断。请注意，这说明如果你要为自定义的数据类型定义散列函数，你需要同时重写 hashCode() 和 equals() 两个方法。默认散列函数会返回对象的内存地址，但这只适用于很少的情况。Java 为很多常用的数据类型重写了 hashCode() 方法（包括 String 、Integer 、Double、File 和 URL ）。  

### 将hashCode()的返回值转化为一个数组索引

因为我们需要的是数组的索引而不是一个 32 位的整数，我们在实现中会将默认的 hashCode() 方法和除留余数法结合起来产生一个 0 到M-1 的整数，方法如下：  

```java
private int hash(Key x)
{ return (x.hashCode() & 0x7fffffff) % M; }
```

这段代码会将符号位屏蔽（将一个 32 位整数变为一个 31 位非负整数），然后用除留余数法计算它除以M 的余数。在使用这样的代码时我们一般会将数组的大小 M 取为素数 以充分利用原散列值的所有位。  

### 自定义的hashCode()方法

```java
public class Transaction
{
...
private final String who;
private final Date when;
private final double amount;
public int hashCode()
{
int hash = 17;
hash = 31 * hash + who.hashCode();
hash = 31 * hash + when.hashCode();
hash = 31 * hash+ ((Double) amount).hashCode();
return hash;
}
...
}
```

自定义类型中 hashCode() 方法的实现  

对于原始类型的对象，可以将其转化为对应的数据类型然后再调用 hashCode() 方法。和以前一样，系数的具体值（这里是 31）并不是很重要。  

### 软缓存

如果散列值的计算很耗时，那么我们或许可以将每个键的散列值缓存起来 ，即在每个键中使用一个hash 变量来保存它的 hashCode() 的返回值（请见练习 3.4.25）。第一次调用 hashCode() 方法时，我们需要计算对象的散列值，但之后对 hashCode() 方法的调用会直接返回 hash 变量的值。
Java 的 String 对象的 hashCode() 方法就使用了这种方法来减少计算量。  
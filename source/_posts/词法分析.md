---
title: 词法分析
date: 2020-05-21 11:03:46
tags: 编译原理
categories: 编译原理
---

## 概述

> 本章介绍

<!--more-->

## 正文

<div id="article_content" class="article_content clearfix" style="height: 2193px; overflow: hidden;">
            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-211130ba7a.css">
                            <div id="content_views" class="markdown_views">
                    <!-- flowchart 箭头图标 勿删 -->
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                                            <p><strong>摘要：</strong></p>

<p>　　所谓排序，就是根据排序码的递增或者递减顺序把数据元素依次排列起来，使一组任意排列的元素变为一组按其排序码线性有序的元素。本文将介绍八种最为经典常用的内部排序算法的基本思想与实现，包括插入排序(直接插入排序，希尔排序)、选择排序(直接选择排序，堆排序)、交换排序(冒泡排序，快速排序)、归并排序、分配排序(基数排序)，并给出各种算法的时间复杂度、空间复杂度和稳定性。</p>

<hr>

<p><strong>版权声明：</strong></p>

<p>　　本文原创作者：<a href="http://my.csdn.net/justloveyou_" rel="nofollow" target="_blank">书呆子Rico</a> <br>
　　作者博客地址：<a href="http://blog.csdn.net/justloveyou_/" target="_blank">http://blog.csdn.net/justloveyou_/</a></p>

<hr>

<p><strong>友情提示：</strong></p>

<p>　　若读者需要本博文相关完整代码，请移步我的Github自行获取，项目名为 DataStructure(具体算法实现在cn.tju.edu.rico.sort包)，项目链接地址为：<a href="https://github.com/githubofrico/DataStructure" target="_blank">https://github.com/githubofrico/DataStructure</a>。</p>

<hr>



<h2 id="一-排序算法概述"><a name="t0"></a><a name="t0"></a>一. 排序算法概述</h2>

<p>　　所谓排序，就是根据排序码的递增或者递减顺序把数据元素依次排列起来，使一组任意排列的元素变为一组按其排序码线性有序的元素。本文将介绍八种最为经典常用的内部排序算法，包括插入排序(直接插入排序，希尔排序)、选择排序(直接选择排序，堆排序)、交换排序(冒泡排序，快速排序)、归并排序、分配排序(基数排序)。实际上，无论是基本排序方法(直接插入排序，直接选择排序，冒泡排序)，还是高效排序方法(快速排序，堆排序，归并排序)等，它们各有所长，都拥有特定的使用场景。因此，在实际应用中，我们必须根据实际任务的特点和各种排序算法的特性来做出最合适的选择。一般地，我们衡量一个算法的指标包括：</p>

<ul>
<li><p>时间复杂度 (在排序过程中需要比较和交换的次数)</p></li>
<li><p>空间复杂度 (在排序过程中需要的辅助存储空间)</p></li>
<li><p>稳定性 (该算法的实现是否可以保证排序后相等元素的初始顺序，只要该算法存在一种实现可以保证这种特征，那么该算法就是稳定的)</p></li>
<li><p>内部排序/外部排序 (在排序过程中数据元素是否完全在内存)</p></li>
</ul>



<hr>

<p>　　笔者将在本文着重探讨上述八种排序算法的思想和实现，并就各算法根据以上指标进行分析和归类，以便进一步熟悉它们各自的应用场景。</p>

<hr>



<h2 id="二-插入排序"><a name="t1"></a><a name="t1"></a>二. 插入排序</h2>

<p>　　<font color="red"><b>插入排序的基本思想</b></font>：每步将一个待排序元素，按其排序码大小插入到前面已经排好序的一组元素中，直到元素全部插入为止。在这里，我们介绍三种具体的插入排序算法：直接插入排序，希尔排序与折半插入排序。</p>

<hr>

<p><strong>1、直接插入排序</strong></p>

<p>　　<font color="red"><b>直接插入排序的思想：</b></font>当插入第i(i&gt;=1)个元素时，前面的V[0],…,V[i-1]等i-1个 元素已经有序。这时，将第i个元素与前i-1个元素V[i-1]，…，V[0]依次比较，找到插入位置即将V[i]插入，同时原来位置上的元素向后顺移。在这里，插入位置的查找是顺序查找。直接插入排序是一种稳定的排序算法，其实现如下：</p>



<pre class="prettyprint" name="code"><code class="language-java hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-javadoc">/**        
 * Title: 插入排序中的直接插入排序，依赖于初始序列    
 * Description: 在有序序列中不断插入新的记录以达到扩大有序区到整个数组的目的
 *              时间复杂度：最好情形O(n)，平均情形O(n^2)，最差情形O(n^2)
 *              空间复杂度：O(1)
 *              稳    定   性：稳定
 *              内部排序(在排序过程中数据元素完全在内存)
 *<span class="hljs-javadoctag"> @author</span> rico       
 *<span class="hljs-javadoctag"> @created</span> 2017年5月20日 上午10:40:00    
 */</span>      
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StraightInsertionSort</span> {</span>

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] <span class="hljs-title">insertSort</span>(<span class="hljs-keyword">int</span>[] target){
    
        <span class="hljs-keyword">if</span>(target != <span class="hljs-keyword">null</span> &amp;&amp; target.length != <span class="hljs-number">1</span>){   <span class="hljs-comment">// 待排序数组不为空且长度大于1</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; target.length; i++) { <span class="hljs-comment">// 不断扩大有序序列，直到扩展到整个数组</span>
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &gt; <span class="hljs-number">0</span>; j--) {    <span class="hljs-comment">// 向有序序列中插入新的元素</span>
                    <span class="hljs-keyword">if</span>(target[j]  &lt; target[j-<span class="hljs-number">1</span>]){  <span class="hljs-comment">// 交换</span>
                        <span class="hljs-keyword">int</span> temp = target[j];
                        target[j] = target[j-<span class="hljs-number">1</span>];
                        target[j-<span class="hljs-number">1</span>] = temp;
                    }
                }
            }
        }
        <span class="hljs-keyword">return</span> target;
    }
}<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li></ul></pre>

<hr>

<p><strong>2、希尔排序</strong></p>

<p>　　<font color="red"><b>希尔排序的思想：</b></font>设待排序序列共n个元素，首先取一个整数gap&lt;n作为间隔，将全部元素分为间隔为gap的gap个子序列并对每一个子序列进行直接插入排序。然后，缩小间隔gap，重复上述操作，直至gap缩小为1，此时所有元素位于同一个序列且有序。由于刚开始时，gap较大，每个子序列元素较少，排序速度较快；待到排序后期，gap变小，每个子序列元素较多，但大部分元素基本有序，所以排序速度仍较快。一般地，gap取 （gap/3 + 1）。希尔排序是一种不稳定的排序方法，其实现如下：</p>



<pre class="prettyprint" name="code"><code class="language-java hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-javadoc">/**        
 * Title: 插入排序中的希尔排序，依赖于初始序列    
 * Description: 分别对间隔为gap的gap个子序列进行直接插入排序，不断缩小gap,直至为 1 
 * 
 *              刚开始时，gap较大，每个子序列元素较少，排序速度较快；
 *              待到排序后期，gap变小，每个子序列元素较多，但大部分元素基本有序，所以排序速度仍较快。                
 * 
 *              时间复杂度：O(n) ~ O(n^2)
 *              空间复杂度：O(1)
 *              稳    定   性：不稳定
 *              内部排序(在排序过程中数据元素完全在内存)
 *<span class="hljs-javadoctag"> @author</span> rico       
 *<span class="hljs-javadoctag"> @created</span> 2017年5月20日 上午10:40:00    
 */</span>      
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShellSort</span> {</span>

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shellSort</span>(<span class="hljs-keyword">int</span>[] target) {
        <span class="hljs-keyword">if</span> (target != <span class="hljs-keyword">null</span> &amp;&amp; target.length != <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">int</span> gap = target.length;    
            <span class="hljs-keyword">while</span> (gap &gt; <span class="hljs-number">1</span>) {      <span class="hljs-comment">// gap为int型，自动取整</span>
                gap = gap / <span class="hljs-number">3</span> + <span class="hljs-number">1</span>;
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = gap; i &lt; target.length; i++) {
                    <span class="hljs-keyword">int</span> j = i - gap;
                    <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span>) {
                        <span class="hljs-keyword">if</span> (target[j + gap] &lt; target[j]) {
                            swap(target, j, j+gap);
                            j -= gap;
                        }<span class="hljs-keyword">else</span>{
                            <span class="hljs-keyword">break</span>;
                        }
                    }
                }
            }
        }
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span>(<span class="hljs-keyword">int</span>[] target, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j) {
        <span class="hljs-keyword">int</span> temp = target[i];
        target[i] = target[j];
        target[j] = temp;
    }
}<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li><li style="color: rgb(153, 153, 153);">31</li><li style="color: rgb(153, 153, 153);">32</li><li style="color: rgb(153, 153, 153);">33</li><li style="color: rgb(153, 153, 153);">34</li><li style="color: rgb(153, 153, 153);">35</li><li style="color: rgb(153, 153, 153);">36</li><li style="color: rgb(153, 153, 153);">37</li><li style="color: rgb(153, 153, 153);">38</li><li style="color: rgb(153, 153, 153);">39</li><li style="color: rgb(153, 153, 153);">40</li><li style="color: rgb(153, 153, 153);">41</li><li style="color: rgb(153, 153, 153);">42</li></ul></pre>

<hr>

<p><strong>3、折半插入排序</strong></p>

<p>　　<font color="red"><b>折半插入排序的思想：</b></font>当插入第i(i&gt;=1)个元素时，前面的V[0],…,V[i-1]等i-1个 元素已经有序。这时，折半搜索第i个元素在前i-1个元素V[i-1]，…，V[0]中的插入位置，然后直接将V[i]插入，同时原来位置上的元素向后顺移。与直接插入排序不同的是，折半插入排序比直接插入排序明显减少了关键字之间的比较次数，但是移动次数是没有改变。所以，折半插入排序和插入排序的时间复杂度相同都是O（N^2），但其减少了比较次数，所以该算法仍然比直接插入排序好。折半插入排序是一种稳定的排序算法，其实现如下：</p>



<pre class="prettyprint" name="code"><code class="language-java hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-javadoc">/**        
 * Title: 插入排序中的折半插入排序，依赖于初始序列  
 * Description: 折半搜索出插入位置，并直接插入;与直接插入搜索的区别是，后者的搜索要快于顺序搜索
 *              时间复杂度：折半插入排序比直接插入排序明显减少了关键字之间的比较次数，但是移动次数是没有改变。所以，
 *              折半插入排序和插入排序的时间复杂度相同都是O（N^2），在减少了比较次数方面它确实相当优秀，所以该算法仍然比直接插入排序好。
 *              空间复杂度：O(1)
 *              稳    定   性：稳定
 *              内部排序(在排序过程中数据元素完全在内存)
 *<span class="hljs-javadoctag"> @author</span> rico       
 *<span class="hljs-javadoctag"> @created</span> 2017年5月25日 下午12:03:23    
 */</span>      
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinaryInsertSort</span> {</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] <span class="hljs-title">binaryInsertSort</span>(<span class="hljs-keyword">int</span>[] target) {
        <span class="hljs-keyword">if</span> (target != <span class="hljs-keyword">null</span> &amp;&amp; target.length &gt; <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; target.length; i++) {
                <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">int</span> right = i - <span class="hljs-number">1</span>;
                <span class="hljs-keyword">int</span> mid;
                <span class="hljs-keyword">int</span> temp = target[i];
                <span class="hljs-keyword">if</span>(temp &lt; target[right]){   <span class="hljs-comment">// 当前值小于有序序列的最大值时，开始查找插入位置</span>
                    <span class="hljs-keyword">while</span>(left &lt;= right){
                        mid = (left + right)/<span class="hljs-number">2</span>;
                        <span class="hljs-keyword">if</span>(target[mid] &lt; temp){
                            left = mid + <span class="hljs-number">1</span>;    <span class="hljs-comment">// 缩小插入区间</span>
                        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target[mid] &gt; temp){
                            right = mid - <span class="hljs-number">1</span>;    <span class="hljs-comment">// 缩小插入区间</span>
                        }<span class="hljs-keyword">else</span>{        <span class="hljs-comment">// 待插入值与有序序列中的target[mid]相等，保证稳定性的处理</span>
                            left = left + <span class="hljs-number">1</span>;   
                        }
                    }

                    <span class="hljs-comment">// left及其后面的数据顺序向后移动，并在left位置插入</span>
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &gt; left; j--) {
                        target[j] = target[j-<span class="hljs-number">1</span>];
                    }
                    target[left] = temp;
                }
            }
        }
        <span class="hljs-keyword">return</span> target;
    }
}<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li><li style="color: rgb(153, 153, 153);">31</li><li style="color: rgb(153, 153, 153);">32</li><li style="color: rgb(153, 153, 153);">33</li><li style="color: rgb(153, 153, 153);">34</li><li style="color: rgb(153, 153, 153);">35</li><li style="color: rgb(153, 153, 153);">36</li><li style="color: rgb(153, 153, 153);">37</li><li style="color: rgb(153, 153, 153);">38</li><li style="color: rgb(153, 153, 153);">39</li><li style="color: rgb(153, 153, 153);">40</li><li style="color: rgb(153, 153, 153);">41</li><li style="color: rgb(153, 153, 153);">42</li></ul></pre>

<hr>



<h2 id="三-选择排序"><a name="t2"></a><a name="t2"></a>三. 选择排序</h2>

<p>　　<font color="red"><b>选择排序的基本思想：</b></font>每一趟 (例如第i趟，i = 0,1,…)在后面第n-i个待排序元素中选出最小元素作为有序序列的第i个元素，直到第n-1趟结束后，所有元素有序。在这里，我们介绍两种具体的选择排序算法：直接选择排序与堆排序。</p>

<hr>

<p><strong>1、直接选择排序</strong></p>

<p>　　<font color="red"><b>直接选择排序的思想：</b></font>第一次从R[0]~R[n-1]中选取最小值，与R[0]交换，第二次从R<a href="http://static.zybuluo.com/Rico123/ymihfm526o5xv5bo1btvm1fy/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.jpg" rel="nofollow" target="_blank">1</a>~R[n-1]中选取最小值，与R<a href="http://static.zybuluo.com/Rico123/ymihfm526o5xv5bo1btvm1fy/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.jpg" rel="nofollow" target="_blank">1</a>交换，….，第i次从R[i-1]~R[n-1]中选取最小值，与R[i-1]交换，…..，第n-1次从R[n-2]~R[n-1]中选取最小值，与R[n-2]交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列。直接选择排序是一种不稳定的排序算法，其实现如下：</p>



<pre class="prettyprint" name="code"><code class="language-java hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-javadoc">/**        
 * Title: 选择排序中的直接选择排序，依赖于初始序列     
 * Description: 每一趟 (例如第i趟，i = 0,1,...)在后面第n-i个待排序元素中选出最小元素作为有序序列的第i个元素
 *              时间复杂度：最好情形O(n^2)，平均情形O(n^2)，最差情形O(n^2)
 *              空间复杂度：O(1)
 *              稳    定   性：不稳定
 *              内部排序(在排序过程中数据元素完全在内存)
 *<span class="hljs-javadoctag"> @author</span> rico       
 *<span class="hljs-javadoctag"> @created</span> 2017年5月20日 上午10:40:00    
 */</span>      
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StraightSelectSort</span> {</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] <span class="hljs-title">selectSort</span>(<span class="hljs-keyword">int</span>[] target){
        <span class="hljs-keyword">if</span>(target != <span class="hljs-keyword">null</span> &amp;&amp; target.length != <span class="hljs-number">1</span>){
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; target.length; i++) {
                <span class="hljs-keyword">int</span> min_index = i;
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; target.length; j++) {
                    <span class="hljs-keyword">if</span>(target[min_index] &gt; target[j]){
                        min_index = j;
                    }
                }
                <span class="hljs-keyword">if</span>(target[min_index] != target[i]){  <span class="hljs-comment">// 导致不稳定的因素：交换</span>
                    <span class="hljs-keyword">int</span> min = target[min_index];
                    target[min_index] = target[i];
                    target[i] = min;
                }
            }
        }
        <span class="hljs-keyword">return</span> target;
    }
}<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li></ul></pre>

<hr>

<p><strong>2、堆排序</strong></p>

<p>　　<font color="red"><b>堆排序的核心是堆调整算法。</b></font>首先根据初始输入数据，利用堆调整算法shiftDown()形成初始堆；然后，将堆顶元素与堆尾元素交换，缩小堆的范围并重新调整为堆，如此往复。堆排序是一种不稳定的排序算法，其实现如下：</p>



<pre class="prettyprint" name="code"><code class="language-java hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-javadoc">/**        
 * Title: 堆排序(选择排序)，升序排序(最大堆)，依赖于初始序列     
 * Description: 现将给定序列调整为最大堆，然后每次将堆顶元素与堆尾元素交换并缩小堆的范围，直到将堆缩小至1
 * 时间复杂度：O(nlgn)
 * 空间复杂度：O(1) 
 * 稳 定 性：不稳定
 * 内部排序(在排序过程中数据元素完全在内存)
 *<span class="hljs-javadoctag"> @author</span> rico       
 *<span class="hljs-javadoctag"> @created</span> 2017年5月25日 上午9:48:06    
 */</span>      
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeapSort</span> {</span>

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] <span class="hljs-title">heapSort</span>(<span class="hljs-keyword">int</span>[] target) {
        <span class="hljs-keyword">if</span> (target != <span class="hljs-keyword">null</span> &amp;&amp; target.length &gt; <span class="hljs-number">1</span>) {
    
            <span class="hljs-comment">// 调整为最大堆</span>
            <span class="hljs-keyword">int</span> pos = (target.length - <span class="hljs-number">2</span>) / <span class="hljs-number">2</span>;
            <span class="hljs-keyword">while</span> (pos &gt;= <span class="hljs-number">0</span>) {
                shiftDown(target, pos, target.length - <span class="hljs-number">1</span>);
                pos--;
            }
    
            <span class="hljs-comment">// 堆排序</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = target.length-<span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) {
                <span class="hljs-keyword">int</span> temp = target[i];
                target[i] = target[<span class="hljs-number">0</span>];
                target[<span class="hljs-number">0</span>] = temp;
                shiftDown(target, <span class="hljs-number">0</span>, i-<span class="hljs-number">1</span>);
            }
            <span class="hljs-keyword">return</span> target;
        }
        <span class="hljs-keyword">return</span> target;
    }


    <span class="hljs-javadoc">/**     
     *<span class="hljs-javadoctag"> @description</span> 自上而下调整为最大堆
     *<span class="hljs-javadoctag"> @author</span> rico       
     *<span class="hljs-javadoctag"> @created</span> 2017年5月25日 上午9:45:40     
     *<span class="hljs-javadoctag"> @param</span> target
     *<span class="hljs-javadoctag"> @param</span> start
     *<span class="hljs-javadoctag"> @param</span> end     
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shiftDown</span>(<span class="hljs-keyword">int</span>[] target, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end) {
        <span class="hljs-keyword">int</span> i = start;
        <span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span> * start + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> temp = target[i];
        <span class="hljs-keyword">while</span> (j &lt;= end) {   <span class="hljs-comment">// 迭代条件</span>
            <span class="hljs-keyword">if</span> (j &lt; end &amp;&amp; target[j + <span class="hljs-number">1</span>] &gt; target[j]) {  <span class="hljs-comment">//找出较大子女</span>
                j = j + <span class="hljs-number">1</span>;
            }
            <span class="hljs-keyword">if</span> (target[j] &lt;= temp) {  <span class="hljs-comment">// 父亲大于子女</span>
                <span class="hljs-keyword">break</span>;
            } <span class="hljs-keyword">else</span> {
                target[i] = target[j];
                i = j;
                j = <span class="hljs-number">2</span> * j + <span class="hljs-number">1</span>;
            }
        }
        target[i] = temp;
    }
}<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li><li style="color: rgb(153, 153, 153);">31</li><li style="color: rgb(153, 153, 153);">32</li><li style="color: rgb(153, 153, 153);">33</li><li style="color: rgb(153, 153, 153);">34</li><li style="color: rgb(153, 153, 153);">35</li><li style="color: rgb(153, 153, 153);">36</li><li style="color: rgb(153, 153, 153);">37</li><li style="color: rgb(153, 153, 153);">38</li><li style="color: rgb(153, 153, 153);">39</li><li style="color: rgb(153, 153, 153);">40</li><li style="color: rgb(153, 153, 153);">41</li><li style="color: rgb(153, 153, 153);">42</li><li style="color: rgb(153, 153, 153);">43</li><li style="color: rgb(153, 153, 153);">44</li><li style="color: rgb(153, 153, 153);">45</li><li style="color: rgb(153, 153, 153);">46</li><li style="color: rgb(153, 153, 153);">47</li><li style="color: rgb(153, 153, 153);">48</li><li style="color: rgb(153, 153, 153);">49</li><li style="color: rgb(153, 153, 153);">50</li><li style="color: rgb(153, 153, 153);">51</li><li style="color: rgb(153, 153, 153);">52</li><li style="color: rgb(153, 153, 153);">53</li><li style="color: rgb(153, 153, 153);">54</li><li style="color: rgb(153, 153, 153);">55</li><li style="color: rgb(153, 153, 153);">56</li><li style="color: rgb(153, 153, 153);">57</li><li style="color: rgb(153, 153, 153);">58</li><li style="color: rgb(153, 153, 153);">59</li><li style="color: rgb(153, 153, 153);">60</li><li style="color: rgb(153, 153, 153);">61</li><li style="color: rgb(153, 153, 153);">62</li></ul></pre>

<hr>



<h2 id="四-交换排序"><a name="t3"></a><a name="t3"></a>四. 交换排序</h2>

<p>　　<font color="red"><b>交换排序的基本思想：</b></font>根据序列中两个元素的比较结果来对换这两个记录在序列中的位置，也就是说，将键值较大的记录向序列的尾部移动，键值较小的记录向序列的前部移动。</p>

<hr>

<p><strong>1、冒泡排序</strong></p>

<p>　　<font color="red"><b>冒泡排序的思想：</b></font>根据序列中两个元素的比较结果来对换这两个记录在序列中的位置，将键值较大的记录向序列的尾部移动，键值较小的记录向序列的前部移动。因此，每一趟都将较小的元素移到前面，较大的元素自然就逐渐沉到最后面了，也就是说，最大的元素最后才能确定，这就是冒泡。冒泡排序是一种稳定的排序算法，其实现如下：</p>



<pre class="prettyprint" name="code"><code class="language-java hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-javadoc">/**
 * Title: 交换排序中的冒泡排序 ，一般情形下指的是优化后的冒泡排序，最多进行n-1次比较，依赖于初始序列  
 * Description:因为越大的元素会经由交换慢慢"浮"到数列的顶端(最后位置)，最大的数最后才确定下来，所以称为冒泡排序
 * 时间复杂度：最好情形O(n)，平均情形O(n^2)，最差情形O(n^2) 
 * 空间复杂度：O(1) 
 * 稳 定 性：稳定
 * 内部排序(在排序过程中数据元素完全在内存)
 * 
 *<span class="hljs-javadoctag"> @author</span> rico
 *<span class="hljs-javadoctag"> @created</span> 2017年5月20日 上午10:40:00
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BubbleSort</span> {</span>

    <span class="hljs-javadoc">/**     
     *<span class="hljs-javadoctag"> @description</span> 朴素冒泡排序(共进行n-1次比较)
     *<span class="hljs-javadoctag"> @author</span> rico         
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] <span class="hljs-title">bubbleSort</span>(<span class="hljs-keyword">int</span>[] target) {
        <span class="hljs-keyword">int</span> n = target.length;
        <span class="hljs-keyword">if</span> (target != <span class="hljs-keyword">null</span> &amp;&amp; n != <span class="hljs-number">1</span>) {
            <span class="hljs-comment">// 最多需要进行n-1躺，每一趟将比较小的元素移到前面，比较大的元素自然就逐渐沉到最后面了，这就是冒泡</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n-<span class="hljs-number">1</span>; i++) {      
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = n-<span class="hljs-number">1</span>; j &gt; i; j--) {
                    <span class="hljs-keyword">if</span>(target[j] &lt; target[j-<span class="hljs-number">1</span>]){
                        <span class="hljs-keyword">int</span> temp = target[j];
                        target[j] = target[j-<span class="hljs-number">1</span>];
                        target[j-<span class="hljs-number">1</span>] = temp;
                    }
                }
                System.out.println(Arrays.toString(target));
            }
        }
        <span class="hljs-keyword">return</span> target;
    }
    
    <span class="hljs-javadoc">/**     
     *<span class="hljs-javadoctag"> @description</span> 优化冒泡排序
     *<span class="hljs-javadoctag"> @author</span> rico         
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] <span class="hljs-title">optimizeBubbleSort</span>(<span class="hljs-keyword">int</span>[] target) {
        <span class="hljs-keyword">int</span> n = target.length;
        <span class="hljs-keyword">if</span> (target != <span class="hljs-keyword">null</span> &amp;&amp; n != <span class="hljs-number">1</span>) {
            <span class="hljs-comment">// 最多需要进行n-1躺，每一趟将比较小的元素移到前面，比较大的元素自然就逐渐沉到最后面了，这就是冒泡</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n-<span class="hljs-number">1</span>; i++) {      
                <span class="hljs-keyword">boolean</span> exchange = <span class="hljs-keyword">false</span>;
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = n-<span class="hljs-number">1</span>; j &gt; i; j--) {
                    <span class="hljs-keyword">if</span>(target[j] &lt; target[j-<span class="hljs-number">1</span>]){
                        <span class="hljs-keyword">int</span> temp = target[j];
                        target[j] = target[j-<span class="hljs-number">1</span>];
                        target[j-<span class="hljs-number">1</span>] = temp;
                        exchange = <span class="hljs-keyword">true</span>;
                    }
                }
                System.out.println(Arrays.toString(target));
                <span class="hljs-keyword">if</span> (!exchange){    <span class="hljs-comment">// 若 i 到 n-1 这部分元素已经有序，则直接返回</span>
                    <span class="hljs-keyword">return</span> target;
                }
            }
        }
        <span class="hljs-keyword">return</span> target;
    }
}<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li><li style="color: rgb(153, 153, 153);">31</li><li style="color: rgb(153, 153, 153);">32</li><li style="color: rgb(153, 153, 153);">33</li><li style="color: rgb(153, 153, 153);">34</li><li style="color: rgb(153, 153, 153);">35</li><li style="color: rgb(153, 153, 153);">36</li><li style="color: rgb(153, 153, 153);">37</li><li style="color: rgb(153, 153, 153);">38</li><li style="color: rgb(153, 153, 153);">39</li><li style="color: rgb(153, 153, 153);">40</li><li style="color: rgb(153, 153, 153);">41</li><li style="color: rgb(153, 153, 153);">42</li><li style="color: rgb(153, 153, 153);">43</li><li style="color: rgb(153, 153, 153);">44</li><li style="color: rgb(153, 153, 153);">45</li><li style="color: rgb(153, 153, 153);">46</li><li style="color: rgb(153, 153, 153);">47</li><li style="color: rgb(153, 153, 153);">48</li><li style="color: rgb(153, 153, 153);">49</li><li style="color: rgb(153, 153, 153);">50</li><li style="color: rgb(153, 153, 153);">51</li><li style="color: rgb(153, 153, 153);">52</li><li style="color: rgb(153, 153, 153);">53</li><li style="color: rgb(153, 153, 153);">54</li><li style="color: rgb(153, 153, 153);">55</li><li style="color: rgb(153, 153, 153);">56</li><li style="color: rgb(153, 153, 153);">57</li><li style="color: rgb(153, 153, 153);">58</li><li style="color: rgb(153, 153, 153);">59</li><li style="color: rgb(153, 153, 153);">60</li><li style="color: rgb(153, 153, 153);">61</li><li style="color: rgb(153, 153, 153);">62</li></ul></pre>

<hr>

<p><strong>2、快速排序</strong></p>

<p>　　<font color="red"><b>快速排序的思想：</b></font>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小(划分过程)，然后再按此方法对这两部分数据分别进行快速排序(快速排序过程)，整个排序过程可以递归进行，以此达到整个数据变成有序序列。快速排序是一种不稳定的排序算法。</p>



<pre class="prettyprint" name="code"><code class="language-java hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-javadoc">/**
 * Title: 交换排序中的快速排序，目前应用最为广泛的排序算法，是一个递归算法，依赖于初始序列  
 * Description:快速排序包括两个过程：划分 和 快排
 * "划分"是指将原序列按基准元素划分两个子序列
 * "快排"是指分别对子序列进行快排
 * 
 * 就平均计算时间而言，快速排序是所有内部排序方法中最好的一个
 * 
 * 对大规模数据排序时，快排是快的；对小规模数据排序时，快排是慢的，甚至慢于简单选择排序等简单排序方法
 * 
 * 快速排序依赖于原始序列，因此其时间复杂度从O(nlgn)到O(n^2)不等
 * 时间复杂度：最好情形O(nlgn)，平均情形O(nlgn)，最差情形O(n^2)
 * 
 * 递归所消耗的栈空间
 * 空间复杂度：O(lgn)
 * 
 * 可选任一元素作为基准元素
 * 稳 定 性：不稳定
 * 
 * 
 * 内部排序(在排序过程中数据元素完全在内存)
 * 
 *<span class="hljs-javadoctag"> @author</span> rico
 *<span class="hljs-javadoctag"> @created</span> 2017年5月20日 上午10:40:00
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuickSort</span> {</span>

    <span class="hljs-javadoc">/**     
     *<span class="hljs-javadoctag"> @description</span> 快排算法(递归算法)：在递去过程中就把问题解决了
     *<span class="hljs-javadoctag"> @author</span> rico       
     *<span class="hljs-javadoctag"> @created</span> 2017年5月20日 下午5:12:06     
     *<span class="hljs-javadoctag"> @param</span> target
     *<span class="hljs-javadoctag"> @param</span> left
     *<span class="hljs-javadoctag"> @param</span> right
     *<span class="hljs-javadoctag"> @return</span>     
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] <span class="hljs-title">quickSort</span>(<span class="hljs-keyword">int</span>[] target, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right) {
    
        <span class="hljs-keyword">if</span>(right &gt; left){     <span class="hljs-comment">// 递归终止条件</span>
            <span class="hljs-keyword">int</span> base_index = partition(target,left, right);  <span class="hljs-comment">// 原序列划分后基准元素的位置</span>
            quickSort(target, left, base_index-<span class="hljs-number">1</span>);    <span class="hljs-comment">// 对第一个子序列快速排序，不包含基准元素！</span>
            quickSort(target, base_index+<span class="hljs-number">1</span>, right);   <span class="hljs-comment">// 对第二个子序列快速排序，不包含基准元素！</span>
            <span class="hljs-keyword">return</span> target;
        }
        <span class="hljs-keyword">return</span> target;
    }


    <span class="hljs-javadoc">/**     
     *<span class="hljs-javadoctag"> @description</span> 序列划分，以第一个元素为基准元素
     *<span class="hljs-javadoctag"> @author</span> rico       
     *<span class="hljs-javadoctag"> @created</span> 2017年5月20日 下午5:10:54     
     *<span class="hljs-javadoctag"> @param</span> target  序列
     *<span class="hljs-javadoctag"> @param</span> left 序列左端
     *<span class="hljs-javadoctag"> @param</span> right  序列右端
     *<span class="hljs-javadoctag"> @return</span>     
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span>(<span class="hljs-keyword">int</span>[] target, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right){
    
        <span class="hljs-keyword">int</span> base = target[left];   <span class="hljs-comment">// 基准元素的值</span>
        <span class="hljs-keyword">int</span> base_index = left;    <span class="hljs-comment">// 基准元素最终应该在的位置</span>
    
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left+<span class="hljs-number">1</span>; i &lt;= right; i++) {  <span class="hljs-comment">// 从基准元素的下一个元素开始</span>
            <span class="hljs-keyword">if</span>(target[i] &lt; base){       <span class="hljs-comment">//  若其小于基准元素</span>
                base_index++;           <span class="hljs-comment">// 若其小于基准元素,则基准元素最终位置后移；否则不用移动</span>
                <span class="hljs-keyword">if</span>(base_index != i){    <span class="hljs-comment">// 相等情况意味着i之前的元素都小于base,只需要换一次即可，不需要次次都换</span>
                    <span class="hljs-keyword">int</span> temp = target[base_index];
                    target[base_index] = target[i];
                    target[i] = temp;
                }
            }
        }
    
        <span class="hljs-comment">// 将基准元素就位</span>
        target[left] = target[base_index];   
        target[base_index] = base;
    
        System.out.println(Arrays.toString(target));
    
        <span class="hljs-keyword">return</span> base_index;  <span class="hljs-comment">//返回划分后基准元素的位置</span>
    }
}<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li><li style="color: rgb(153, 153, 153);">31</li><li style="color: rgb(153, 153, 153);">32</li><li style="color: rgb(153, 153, 153);">33</li><li style="color: rgb(153, 153, 153);">34</li><li style="color: rgb(153, 153, 153);">35</li><li style="color: rgb(153, 153, 153);">36</li><li style="color: rgb(153, 153, 153);">37</li><li style="color: rgb(153, 153, 153);">38</li><li style="color: rgb(153, 153, 153);">39</li><li style="color: rgb(153, 153, 153);">40</li><li style="color: rgb(153, 153, 153);">41</li><li style="color: rgb(153, 153, 153);">42</li><li style="color: rgb(153, 153, 153);">43</li><li style="color: rgb(153, 153, 153);">44</li><li style="color: rgb(153, 153, 153);">45</li><li style="color: rgb(153, 153, 153);">46</li><li style="color: rgb(153, 153, 153);">47</li><li style="color: rgb(153, 153, 153);">48</li><li style="color: rgb(153, 153, 153);">49</li><li style="color: rgb(153, 153, 153);">50</li><li style="color: rgb(153, 153, 153);">51</li><li style="color: rgb(153, 153, 153);">52</li><li style="color: rgb(153, 153, 153);">53</li><li style="color: rgb(153, 153, 153);">54</li><li style="color: rgb(153, 153, 153);">55</li><li style="color: rgb(153, 153, 153);">56</li><li style="color: rgb(153, 153, 153);">57</li><li style="color: rgb(153, 153, 153);">58</li><li style="color: rgb(153, 153, 153);">59</li><li style="color: rgb(153, 153, 153);">60</li><li style="color: rgb(153, 153, 153);">61</li><li style="color: rgb(153, 153, 153);">62</li><li style="color: rgb(153, 153, 153);">63</li><li style="color: rgb(153, 153, 153);">64</li><li style="color: rgb(153, 153, 153);">65</li><li style="color: rgb(153, 153, 153);">66</li><li style="color: rgb(153, 153, 153);">67</li><li style="color: rgb(153, 153, 153);">68</li><li style="color: rgb(153, 153, 153);">69</li><li style="color: rgb(153, 153, 153);">70</li><li style="color: rgb(153, 153, 153);">71</li><li style="color: rgb(153, 153, 153);">72</li><li style="color: rgb(153, 153, 153);">73</li><li style="color: rgb(153, 153, 153);">74</li><li style="color: rgb(153, 153, 153);">75</li><li style="color: rgb(153, 153, 153);">76</li><li style="color: rgb(153, 153, 153);">77</li><li style="color: rgb(153, 153, 153);">78</li><li style="color: rgb(153, 153, 153);">79</li><li style="color: rgb(153, 153, 153);">80</li><li style="color: rgb(153, 153, 153);">81</li><li style="color: rgb(153, 153, 153);">82</li></ul></pre>

<hr>



<h2 id="五-归并排序"><a name="t4"></a><a name="t4"></a>五. 归并排序</h2>

<p>　　<font color="red"><b>归并排序包含两个过程：”归”和”并”。</b></font>其中，”归”是指将原序列分成半子序列，分别对子序列进行递归排序；”并”是指将排好序的各子序列合并成原序列。归并排序算法是一个典型的递归算法，因此也是概念上最为简单的排序算法。与快速排序算法相比，归并排序算法不依赖于初始序列，并且是一种稳定的排序算法，但需要与原序列一样大小的辅助存储空间。</p>



<pre class="prettyprint" name="code"><code class="language-java hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-javadoc">/**
 * Title: 归并排序 ，概念上最为简单的排序算法，是一个递归算法 Description:归并排序包括两个过程：归 和 并
 * "归"是指将原序列分成半子序列，分别对子序列进行递归排序 "并"是指将排好序的各子序列合并成原序列
 * 
 * 归并排序的主要问题是：需要一个与原待排序数组一样大的辅助数组空间
 * 
 * 归并排序不依赖于原始序列，因此其最好情形、平均情形和最差情形时间复杂度都一样 时间复杂度：最好情形O(n)，平均情形O(n^2)，最差情形O(n^2)
 * 空间复杂度：O(n) 稳 定 性：稳定 内部排序(在排序过程中数据元素完全在内存)
 * 
 *<span class="hljs-javadoctag"> @author</span> rico
 *<span class="hljs-javadoctag"> @created</span> 2017年5月20日 上午10:40:00
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MergeSort</span> {</span>

    <span class="hljs-javadoc">/**
     *<span class="hljs-javadoctag"> @description</span> 归并排序算法(递归算法)：递去分解，归来合并
     *<span class="hljs-javadoctag"> @author</span> rico
     *<span class="hljs-javadoctag"> @created</span> 2017年5月20日 下午4:04:52
     *<span class="hljs-javadoctag"> @param</span> target
     *            待排序序列
     *<span class="hljs-javadoctag"> @param</span> left
     *            待排序序列起始位置
     *<span class="hljs-javadoctag"> @param</span> right
     *            待排序序列终止位置
     *<span class="hljs-javadoctag"> @return</span>
     */</span>
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span>(<span class="hljs-keyword">int</span>[] target) {
        <span class="hljs-keyword">int</span>[] copy = Arrays.copyOf(target, target.length);    <span class="hljs-comment">// 空间复杂度O(n)</span>
        mergeSort(target, copy, <span class="hljs-number">0</span>, target.length - <span class="hljs-number">1</span>);
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span>(<span class="hljs-keyword">int</span>[] target, <span class="hljs-keyword">int</span>[] copy, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right) {
        <span class="hljs-keyword">if</span> (right &gt; left) { <span class="hljs-comment">// 递归终止条件</span>
            <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;
            mergeSort(target, copy, left, mid); <span class="hljs-comment">// 归并排序第一个子序列</span>
            mergeSort(target, copy, mid + <span class="hljs-number">1</span>, right); <span class="hljs-comment">// 归并排序第二个子序列</span>
            merge(target, copy, left, mid, right); <span class="hljs-comment">// 合并子序列成原序列</span>
        }
    }
    
    <span class="hljs-javadoc">/**
     *<span class="hljs-javadoctag"> @description</span> 两路归并算法
     *<span class="hljs-javadoctag"> @author</span> rico
     *<span class="hljs-javadoctag"> @created</span> 2017年5月20日 下午3:59:16
     *<span class="hljs-javadoctag"> @param</span> target
     *            用于存储归并结果
     *<span class="hljs-javadoctag"> @param</span> left
     *            第一个有序表的第一个元素所在位置
     *<span class="hljs-javadoctag"> @param</span> mid
     *            第一个有序表的最后一个元素所在位置
     *<span class="hljs-javadoctag"> @param</span> right
     *            第二个有序表的最后一个元素所在位置
     *<span class="hljs-javadoctag"> @return</span>
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span>(<span class="hljs-keyword">int</span>[] target, <span class="hljs-keyword">int</span>[] copy, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> mid,
            <span class="hljs-keyword">int</span> right) {
    
        <span class="hljs-comment">// s1,s2是检查指针，index 是存放指针</span>
        <span class="hljs-keyword">int</span> s1 = left;
        <span class="hljs-keyword">int</span> s2 = mid + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> index = left;
    
        <span class="hljs-comment">// 两个表都未检查完，两两比较</span>
        <span class="hljs-keyword">while</span> (s1 &lt;= mid &amp;&amp; s2 &lt;= right) {
            <span class="hljs-keyword">if</span> (copy[s1] &lt;= copy[s2]) { <span class="hljs-comment">// 稳定性</span>
                target[index++] = copy[s1++];
            } <span class="hljs-keyword">else</span> {
                target[index++] = copy[s2++];
            }
        }
    
        <span class="hljs-comment">// 若第一个表未检查完，复制</span>
        <span class="hljs-keyword">while</span> (s1 &lt;= mid) {
            target[index++] = copy[s1++];
        }
    
        <span class="hljs-comment">// 若第二个表未检查完，复制</span>
        <span class="hljs-keyword">while</span> (s2 &lt;= right) {
            target[index++] = copy[s2++];
        }
    
        <span class="hljs-comment">// 更新辅助数组 copy</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left; i &lt;= right; i++) {
            copy[i] = target[i];
        }
    }<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li><li style="color: rgb(153, 153, 153);">31</li><li style="color: rgb(153, 153, 153);">32</li><li style="color: rgb(153, 153, 153);">33</li><li style="color: rgb(153, 153, 153);">34</li><li style="color: rgb(153, 153, 153);">35</li><li style="color: rgb(153, 153, 153);">36</li><li style="color: rgb(153, 153, 153);">37</li><li style="color: rgb(153, 153, 153);">38</li><li style="color: rgb(153, 153, 153);">39</li><li style="color: rgb(153, 153, 153);">40</li><li style="color: rgb(153, 153, 153);">41</li><li style="color: rgb(153, 153, 153);">42</li><li style="color: rgb(153, 153, 153);">43</li><li style="color: rgb(153, 153, 153);">44</li><li style="color: rgb(153, 153, 153);">45</li><li style="color: rgb(153, 153, 153);">46</li><li style="color: rgb(153, 153, 153);">47</li><li style="color: rgb(153, 153, 153);">48</li><li style="color: rgb(153, 153, 153);">49</li><li style="color: rgb(153, 153, 153);">50</li><li style="color: rgb(153, 153, 153);">51</li><li style="color: rgb(153, 153, 153);">52</li><li style="color: rgb(153, 153, 153);">53</li><li style="color: rgb(153, 153, 153);">54</li><li style="color: rgb(153, 153, 153);">55</li><li style="color: rgb(153, 153, 153);">56</li><li style="color: rgb(153, 153, 153);">57</li><li style="color: rgb(153, 153, 153);">58</li><li style="color: rgb(153, 153, 153);">59</li><li style="color: rgb(153, 153, 153);">60</li><li style="color: rgb(153, 153, 153);">61</li><li style="color: rgb(153, 153, 153);">62</li><li style="color: rgb(153, 153, 153);">63</li><li style="color: rgb(153, 153, 153);">64</li><li style="color: rgb(153, 153, 153);">65</li><li style="color: rgb(153, 153, 153);">66</li><li style="color: rgb(153, 153, 153);">67</li><li style="color: rgb(153, 153, 153);">68</li><li style="color: rgb(153, 153, 153);">69</li><li style="color: rgb(153, 153, 153);">70</li><li style="color: rgb(153, 153, 153);">71</li><li style="color: rgb(153, 153, 153);">72</li><li style="color: rgb(153, 153, 153);">73</li><li style="color: rgb(153, 153, 153);">74</li><li style="color: rgb(153, 153, 153);">75</li><li style="color: rgb(153, 153, 153);">76</li><li style="color: rgb(153, 153, 153);">77</li><li style="color: rgb(153, 153, 153);">78</li><li style="color: rgb(153, 153, 153);">79</li><li style="color: rgb(153, 153, 153);">80</li><li style="color: rgb(153, 153, 153);">81</li><li style="color: rgb(153, 153, 153);">82</li><li style="color: rgb(153, 153, 153);">83</li><li style="color: rgb(153, 153, 153);">84</li><li style="color: rgb(153, 153, 153);">85</li><li style="color: rgb(153, 153, 153);">86</li><li style="color: rgb(153, 153, 153);">87</li></ul></pre>

<p>　　Ps : 归并排序和快速排序都是典型的递归算法，因此它们比较容易理解和实现。关于递归思想和内涵深度剖析，请见博文<a href="http://blog.csdn.net/justloveyou_/article/details/71787149">《算法设计方法：递归的内涵与经典应用》</a>。</p>

<hr>

<h2 id="六-分配排序基数排序"><a name="t5"></a><a name="t5"></a>六. 分配排序(基数排序)</h2>

<p>　　<font color="red"><b>分配排序的基本思想</b></font>：用空间换时间。在整个排序过程中，无须比较关键字，而是通过用额外的空间来”分配”和”收集”来实现排序，它们的时间复杂度可达到线性阶：O(n)。其中，基数排序包括两个过程：首先，将目标序列各元素分配到各个桶中(分配过程)；然后，将各个桶中的元素按先进先出的顺序再放回去(收集过程)，如此往复，一共需要进行d趟，d为元素的位数。</p>



<pre class="prettyprint" name="code"><code class="language-java hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-javadoc">/**        
 * Title: 分配排序中的基数排序，不依赖于初始序列  
 * Description: 不是在对元素进行比较的基础上进行排序，而是采用 "分配 + 收集" 的办法 
 * 
 *              首先，将目标序列各元素分配到各个桶中；
 *              其次，将各个桶中的元素按先进先出的顺序再放回去
 *              如此往复...             
 * 
 *              时间复杂度：O(d*(r+n))或者 O(dn),d 的大小一般会受到 n的影响
 *              空间复杂度：O(rd + n)或者 O(n)
 *              稳    定   性：稳定
 *              内部排序(在排序过程中数据元素完全在内存)
 *<span class="hljs-javadoctag"> @author</span> rico       
 *<span class="hljs-javadoctag"> @created</span> 2017年5月20日 上午10:40:00    
 */</span>   
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RadixSort</span> {</span>

    <span class="hljs-javadoc">/**     
     *<span class="hljs-javadoctag"> @description</span> 分配 + 收集
     *<span class="hljs-javadoctag"> @author</span> rico       
     *<span class="hljs-javadoctag"> @created</span> 2017年5月21日 下午9:25:52     
     *<span class="hljs-javadoctag"> @param</span> target 待排序数组
     *<span class="hljs-javadoctag"> @param</span> r 基数
     *<span class="hljs-javadoctag"> @param</span> d 元素的位数
     *<span class="hljs-javadoctag"> @param</span> n 待排序元素个数
     *<span class="hljs-javadoctag"> @return</span>     
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] <span class="hljs-title">radixSort</span>(<span class="hljs-keyword">int</span>[] target, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> d, <span class="hljs-keyword">int</span> n){
        <span class="hljs-keyword">if</span> (target != <span class="hljs-keyword">null</span> &amp;&amp; target.length != <span class="hljs-number">1</span> ) {
    
            <span class="hljs-keyword">int</span>[][] bucket = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[r][n];  <span class="hljs-comment">// 一共有基数r个桶，每个桶最多放n个元素</span>
            <span class="hljs-keyword">int</span> digit;  <span class="hljs-comment">// 获取元素对应位上的数字，即装入那个桶</span>
            <span class="hljs-keyword">int</span> divisor = <span class="hljs-number">1</span>;   <span class="hljs-comment">// 定义每一轮的除数，1, 10, 100, ...</span>
            <span class="hljs-keyword">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[r];   <span class="hljs-comment">// 统计每个桶中实际存放元素的个数</span>
    
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; d; i++) {  <span class="hljs-comment">// d 位的元素，需要经过分配、收集d次即可完成排序</span>
    
                <span class="hljs-comment">// 分配</span>
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ele : target) {   
                    digit = (ele/divisor) % <span class="hljs-number">10</span>;  <span class="hljs-comment">// 获取元素对应位上的数字(巧妙！！！)</span>
                    bucket[digit][count[digit]++] = ele; <span class="hljs-comment">// 将元素放入对应桶，桶中元素数目加1</span>
                }
    
                <span class="hljs-comment">// 收集</span>
                <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 目标数组的下标</span>
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; r; j++) {
                    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 用于按照先进先出顺序获取桶中元素</span>
                    <span class="hljs-keyword">while</span>(k &lt; count[j]){
                        target[index++] = bucket[j][k++];  <span class="hljs-comment">// 按照先进先出依次取出桶中的元素</span>
                    }
                    count[j] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 计数器归零</span>
                }
                divisor *= <span class="hljs-number">10</span>;  <span class="hljs-comment">//用于获取元素对应位数字</span>
            }
        }
        <span class="hljs-keyword">return</span> target;
    }
}<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li><li style="color: rgb(153, 153, 153);">31</li><li style="color: rgb(153, 153, 153);">32</li><li style="color: rgb(153, 153, 153);">33</li><li style="color: rgb(153, 153, 153);">34</li><li style="color: rgb(153, 153, 153);">35</li><li style="color: rgb(153, 153, 153);">36</li><li style="color: rgb(153, 153, 153);">37</li><li style="color: rgb(153, 153, 153);">38</li><li style="color: rgb(153, 153, 153);">39</li><li style="color: rgb(153, 153, 153);">40</li><li style="color: rgb(153, 153, 153);">41</li><li style="color: rgb(153, 153, 153);">42</li><li style="color: rgb(153, 153, 153);">43</li><li style="color: rgb(153, 153, 153);">44</li><li style="color: rgb(153, 153, 153);">45</li><li style="color: rgb(153, 153, 153);">46</li><li style="color: rgb(153, 153, 153);">47</li><li style="color: rgb(153, 153, 153);">48</li><li style="color: rgb(153, 153, 153);">49</li><li style="color: rgb(153, 153, 153);">50</li><li style="color: rgb(153, 153, 153);">51</li><li style="color: rgb(153, 153, 153);">52</li><li style="color: rgb(153, 153, 153);">53</li><li style="color: rgb(153, 153, 153);">54</li><li style="color: rgb(153, 153, 153);">55</li><li style="color: rgb(153, 153, 153);">56</li><li style="color: rgb(153, 153, 153);">57</li><li style="color: rgb(153, 153, 153);">58</li></ul></pre>

<hr>



<h2 id="七-总结"><a name="t6"></a><a name="t6"></a>七. 总结</h2>

<p>　　 　　 　　 　　 　　 　<img src="http://static.zybuluo.com/Rico123/ymihfm526o5xv5bo1btvm1fy/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.jpg" alt="八大排序算法总结.jpg-201kB" title=""></p>

<hr>

<p>1、直接插入排序 Vs. 折半插入排序 Vs. 希尔排序</p>

<p>　　这三种排序方法都属于插入排序的范畴。与直接插入排序的顺序搜索插入位置相比，折半插入排序通过折半搜索的方法搜索插入位置，因此，在搜索插入位置方面，折半插入排序要快于直接插入排序。实际上，折半插入排序比直接插入排序只是减少了关键字之间的比较次数，但是移动次数是没有改变。所以，折半插入排序和插入排序的时间复杂度相同都是O（n^2），但减少了比较次数，所以该算法要比直接插入排序好一点。希尔排序可以看作是对直接插入排序的一种优化，它将全部元素分为间隔为gap的gap个子序列并对每一个子序列进行直接插入排序，同时不断缩小间隔gap，直至所有元素位于同一个序列。使用这种方式可以保证排序效率，因为刚开始时，gap较大，每个子序列元素较少，排序速度较快；待到排序后期，gap变小，每个子序列元素较多，但大部分元素基本有序，所以排序速度仍较快。因此，希尔排序比直接插入排序 、折半插入排序都要高效，但它不是稳定的。</p>

<hr>

<p>2、直接选择排序 Vs. 堆排序</p>

<p>　　这两种排序方法都属于插入选择排序的范畴，它们的核心思想都是每一趟都选择一个极值元素放在靠前/靠后位置，直到序列有序。与直接选择排序不同的是，堆排序不是“蛮力选择”，而是不断进行堆调整以取得每趟中的极值。因此，堆排序比直接选择排序要高效，不过它们都是不稳定的。</p>

<hr>

<p>3、冒泡排序 Vs. 快速排序</p>

<p>　　这两种排序方法都属于选择排序的范畴，它们的核心思想都是元素的交换，冒泡排序中每一趟相邻元素互相比较，并将较小的交换到前面(较大的自然沉到后面)位置，快速排序则是以基准点为基础，将比它小的元素和比它大的元素分别交换到它的两边。因此，快速排序比冒泡排序要高效，但它不是稳定的。</p>

<hr>

<p>4、归并排序 Vs. 快速排序</p>

<p>　　这两种排序方法都属于递归算法的范畴，因此，它们都比较容易让人理解和实现。与快速排序相比，归并排序不但是稳定的，还是与原始序列无关的(不依赖于原始序列的顺序，时间复杂度总是O(nlgn))，但是需要与原始序列一样大小的空间；而快速排序则一般情况下都要比其他高效排序算法（包括归并排序）快，而且空间复杂度只为O(1)。另外，我们从算法实现中可以看出这两种递归算法有以下区别和联系：</p>

<ul>
<li>二者的递归终止条件相同；</li>
<li>二者的实现结构较为类似，归并排序是先归后并，快速排序是先分后排；</li>
<li>归并排序的核心实现在于有序子序列的合并，而快速排序的核心实现在于对原始序列的划分；</li>
</ul>

<hr>

<p>5、小结</p>

<p>　　直接插入排序、直接选择排序和冒泡排序是基本的排序方法，它们平均情况下的时间复杂度都是O(n^2)，实现也比较简单，它们对规模较小的元素序列很有效。</p>

<p>　　快速排序、堆排序和归并排序是高效的排序方法，它们平均情况下的时间复杂度都是O(nlgn)，其中快速排序是最通用的高效排序算法，但其是不稳定的；归并排序是上述几种排序算法中唯一与初始序列无关的，而且时间复杂度总是O(nlgn)，但其空间复杂度是O(n)，是一种稳定的排序算法；堆排序的时间复杂度总是O(nlgn)，空间复杂度是O(1)，也是不稳定的。它们对规模较大的元素序列很有效。</p>

<p>　　希尔排序的效率介于基本排序方法与高效排序方法之间，是一种不稳定的排序算法。它们各有所长，都拥有特定的使用场景。基数排序虽然具有线性增长的时间复杂度，但实际上开销并不比快速排序小很多，应用相对不太广泛。</p>

<p>　　因此，在实际应用中，我们必须根据实际任务的特点和各种排序算法的特性来做出最合适的选择。</p>

<hr>



<h2 id="八-更多"><a name="t7"></a><a name="t7"></a>八. 更多</h2>

<p>　　归并排序和快速排序都是典型的递归算法，因此它们比较容易理解和实现。关于递归思想和内涵深度剖析，请见博文<a href="http://blog.csdn.net/justloveyou_/article/details/71787149" target="_blank">《算法设计方法：递归的内涵与经典应用》</a>。</p>

<hr>

<blockquote>
  <h2 id="引用"><a name="t8"></a><a name="t8"></a>引用</h2>

  <p><a href="http://blog.csdn.net/hguisu/article/details/7776068/" target="_blank">《八大排序算法》</a></p>
</blockquote>                                    </div>
                <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-60ecaf1f42.css" rel="stylesheet">
                                </div>